diff -abuN source/angles.f source_distrib/angles.f
--- source/angles.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/angles.f	2010-08-26 11:38:22.000000000 +0200
@@ -26,6 +26,9 @@
       include 'atoms.i'
       include 'couple.i'
       include 'iounit.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
 c
 c
@@ -36,6 +39,14 @@
          m = 0
          do j = 1, n12(i)-1
             do k = j+1, n12(i)
+cqmmm Remove angles between QM-only atoms
+cqmmm The case Y-Q-C is computationally possible
+cqmmm but rather unrealistic !
+               if(qmmm(i12(j,i)).ge.2 .and. qmmm(i).eq.2 .and.
+     &            qmmm(i12(k,i)).ge.2) goto 20
+               if(qmmm(i12(j,i)).eq.2 .and. qmmm(i).eq.3 .and.
+     &            qmmm(i12(k,i)).eq.2) goto 20
+cqmmm
                nangle = nangle + 1
                if (nangle .gt. maxang) then
                   write (iout,10)
@@ -49,6 +60,9 @@
                iang(2,nangle) = i
                iang(3,nangle) = i12(k,i)
                iang(4,nangle) = 0
+cqmmm
+   20          continue
+cqmmm
             end do
          end do
 c
diff -abuN source/avgmd.f source_distrib/avgmd.f
--- source/avgmd.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/avgmd.f	2010-08-26 11:38:26.000000000 +0200
@@ -0,0 +1,408 @@
+c
+c     ###############################################################
+c     ##                                                           ##
+c     ##  subroutine avgmd -- average coordinates and interactions ##
+c     ##                                                           ##
+c     ###############################################################
+c
+c
+c     "avgmd" updates the average coordinates and interaction 
+c     energies with the current MD snapshot (called from mdsave)
+c     snap contains its filename
+c  
+c     Only QM/MM interaction computed
+c
+c
+      subroutine avgmd(snap)
+      implicit none
+      include 'sizes.i'
+      include 'atmtyp.i'
+      include 'atoms.i'
+      include 'charge.i'
+      include 'energi.i'
+      include 'iounit.i'
+      include 'units.i'
+      include 'usage.i'
+      include 'files.i'
+      include 'group.i'
+      include 'inform.i'
+      include 'potent.i'
+      include 'qmmm.i'
+      include 'scales.i'
+      include 'couple.i'
+      include 'bound.i'
+      include 'mpole.i'
+      include 'polar.i'
+      include 'analyz.i'
+      include 'bath.i'
+      include 'mdstuf.i'
+      include 'deriv.i'
+      integer iavg,freeunit,i,k
+      integer igrd,iep,ien,nequi
+      logical found, inuse(maxatm)
+      real*8 epf,epg(3),eph(6)
+      real*8 energy,eprmsd_old,eppre
+      real*8 derivs(3,maxatm),epgpre(3)
+      real*8 rmsd_old,diff,epgrmsd_old
+      real*8 tcurrprod,ttargetprod
+      character*60 snap
+c
+      if (mmmdmode .eq. 0) return
+c
+c     Update the total number of snapshots
+c
+      nsnap = nsnap + 1
+c
+c     Number of structures for equilibration
+c     mdnequi: number of steps written in the key file
+c     dt: length of a MD step in ps
+c     dtdump: time between two dumps in ps
+c
+      nequi = nint((mdnequi*dt)/dtdump) + 1
+c
+c    Stores the initial active/inactive situation
+c    before changing it to compute all the QM/MM
+c    and MM only interactions
+c 
+      do i = 1, n
+         inuse(i) = use(i)
+      end do   
+c
+c    Electrostatic QM-MM interaction not to be computed
+c    for the full energy evaluation, the QM, MM and LA 
+c    must be activated while the MM atoms are inactivated
+c
+      e4qmmm = 0
+      doespf = .true.
+      do i = 1, n
+         use(i) = use(i) .or. (atinqm(i).ne.0)
+      end do
+c
+c    Calling gradient for energy and derivatives
+c
+      if (debug) then
+         write (iout,9)
+   9    format (/,' Analysis of the MM energy in avgmd')
+         call analysis(energy)
+      end if
+      call gradient(energy,derivs)
+c
+c     Store the last RMSD value
+c     for coordinates and electrostatic potential
+c     and initialize the current values to zero
+c
+c
+      rmsd_old = rmsd
+      eprmsd_old = eprmsd
+      rmsd = 0.0d0
+c
+c     Calculation of RMSD on coordinates relative to
+c     the inital structure
+c     Output of RMSD and absolute value of the 
+c     difference between current and previous RMSD
+c
+      do i = 1, n
+         rmsd = rmsd + (xpre(i) - x(i))**2 + (ypre(i) - y(i))**2 +
+     &        (zpre(i) - z(i))**2
+      end do
+      rmsd = sqrt(rmsd/n)
+      write(iout,10), rmsd
+   10 format (' Current RMSD',8x,f15.6,' Angstroms')
+      diff = abs(rmsd - rmsd_old)
+      write(iout,20), diff
+   20 format (' RMSD Difference',5x,f15.6,' Angstroms')
+c
+c     If the number of snapshots reaches the number of structures
+c     requested for equilibration in the key file, 
+c     the averaging procedure ("MD production") is started 
+c
+      rmsdchk = (nsnap .ge. nequi)
+c  -----------------------------------------------------------
+c
+c     Alternative way to start averaging: RMSD difference
+c     below a threshold (hard coded as 0.01) - currently disabled
+c
+c      if ((diff .lt. 0.01) .and. (.not.rmsdchk)) then
+c         write(iout,*) 'RMSD difference below threshold'
+c         write(iout,*) 'Averaging of structures starts NOW!'
+c      end if
+c      rmsdchk = ((diff .lt. 0.01) .and. (rmsd .ne. 0))
+c
+c  -----------------------------------------------------------
+c
+c     If the averaging has started, the required average
+c     quantities - coordinates, gradients, potential and
+c     its derivatives - are computed
+c
+      if (rmsdchk) then
+c 
+c  -----------------------------------------------------------
+c     Writing of log files, for testing purpose - all obsolete
+c
+c
+c     Check for existence the gradients log and open it
+c
+c         inquire(file='gradients.log',exist=found)
+c         igrd = freeunit()
+c         if (found) then
+c            open (unit=igrd,file='gradients.log',access='append')
+c         else
+c            open (unit=igrd,file='gradients.log',status='new')
+c         end if
+c         write(igrd,30) 'Atom','Fx','Fy','Fz','AvgFx',
+c     &        'AvgFy','AvgFz'
+c   30 format(A8,3A12,3A12)
+c
+c    Check for existence the average coordinates log and open it
+c
+c         inquire(file='xyz_average.log',exist=found)
+c         iavg = freeunit()
+c         if (found) then
+c            open (unit=iavg,file='xyz_average.log',access='append')
+c         else
+c            open (unit=iavg,file='xyz_average.log',status='new')
+c         end if
+c         write(iavg,40) 'Atom ','AvgX','AvgY','AvgZ'
+c   40 format(A8,2x,3A12)
+c
+c  -------------------------------------------------------------
+c
+c   Check for existence of the potential and 1st derivative log
+c   and open it
+c 
+         inquire(file='ep_all.log',exist=found)
+         iep = freeunit()
+         if (found) then
+            open (unit=iep,file='ep_all.log',access='append') 
+         else
+            open (unit=iep,file='ep_all.log',status='new')
+         end if
+c         write(iep,50) 'Atom','V','dV/dx','dV/dy','dV/dz'
+   50 format(A5,2x,4A12)
+c
+c   Increasing the number of structures to be averaged and 
+c   reinitializing the RMSD of electrostatic potential gradient 
+c
+         nstrut = nstrut + 1.0d0
+         eprmsd = 0.0d0
+         do k = 1, 3
+            epgrmsd(k) = 0.0d0
+         end do
+c
+c   Gradient average
+c
+         do i = 1, n  
+           do k = 1, 3
+           avgderiv(k,i) = ((nstrut - 1.0)*avgderiv(k,i) + derivs(k,i))
+     &        /nstrut
+           end do
+c            write(igrd,60) i, derivs(1,i),derivs(2,i),derivs(3,i),
+c     &        avgderiv(1,i),avgderiv(2,i),avgderiv(3,i)
+c   60 format(i5,3x,6f12.6)
+c
+c   Coordinates average
+c  
+            xavg(i) = ((nstrut - 1.0)*xavg(i) + x(i))/nstrut
+            yavg(i) = ((nstrut - 1.0)*yavg(i) + y(i))/nstrut
+            zavg(i) = ((nstrut - 1.0)*zavg(i) + z(i))/nstrut    
+c            write(iavg,70) i,xavg(i),yavg(i),zavg(i)
+c   70 format(i5,3x,3f12.6)
+c
+c   Electrostatic potential and derivatives calculation and 
+c   averages for atoms in the QM code
+c
+            if (atinqm(i) .ne. 0) then
+               eppre = epavg(i)
+               call elecpot(i,epf,epg,eph)
+               epavg(i) = ((nstrut - 1.0)*epavg(i) + epf)/nstrut
+               eprmsd = eprmsd + (eppre - epavg(i))**2
+               do k = 1, 3
+                  epgpre(k) = epgavg(k,i)
+                  epgavg(k,i) = ((nstrut - 1.0)*epgavg(k,i) + epg(k))
+     &        /nstrut
+                  epgrmsd(k) = epgrmsd(k) + (epgpre(k)-epgavg(k,i))**2
+                  ephavg(k,i) = ((nstrut - 1.0)*ephavg(k,i) + eph(k))
+     &        /nstrut
+               end do
+               do k = 4, 6
+                  ephavg(k,i) = ((nstrut - 1.0)*ephavg(k,i) + eph(k))
+     &        /nstrut
+               end do  
+            end if
+         end do
+c         write(igrd,*) '-- Snapshot  ',nstrut,' --'
+c         write(iavg,*) '-- Snapshot  ',nstrut,' --'
+c         write(iep,*) '-- Snapshot  ',int(nstrut),' --'
+         if (int(nstrut) .eq. 10) write(iep,*) 'EndRun'
+c
+c   Closing all the log files
+c
+
+c         close(igrd)
+c         close(iavg)
+         close(iep)
+c
+c   Calculation of RMSDs on potential and its 1st derivatives
+c
+         eprmsd = sqrt(eprmsd/real(nbinqm))
+         do k = 1, 3
+            epgrmsd(k) = sqrt(epgrmsd(k)/real(nbinqm))
+         end do
+c
+c   Check the energy components log for existence and open it
+c   and there write the energy terms for the current snapshot 
+c
+         ien = freeunit()
+         inquire(file='energy_terms.log',exist=found)
+         if (found) then
+            open(unit=ien,file='energy_terms.log',access='append')
+         else 
+            open(unit=ien,file='energy_terms.log',status='new')
+         end if
+         write(ien,*) 'Energy components of snapshot number ',
+     &                 int(nstrut)
+         if(eb .ne. 0.0d0) write(ien,110) ' eb   = ',eb
+         if(ea  .ne.0.0d0) write(ien,110) ' ea   = ',ea
+         if(eba .ne.0.0d0) write(ien,110) ' eba  = ',eba
+         if(eub .ne.0.0d0) write(ien,110) ' eub  = ',eub
+         if(eaa .ne.0.0d0) write(ien,110) ' eaa  = ',eaa
+         if(eopb.ne.0.0d0) write(ien,110) ' eopb = ',eopb
+         if(eopd.ne.0.0d0) write(ien,110) ' eopd = ',eopd
+         if(eid .ne.0.0d0) write(ien,110) ' eid  = ',eid
+         if(eit .ne.0.0d0) write(ien,110) ' eit  = ',eit
+         if(et  .ne.0.0d0) write(ien,110) ' et   = ',et
+         if(ebt .ne.0.0d0) write(ien,110) ' ebt  = ',ebt
+         if(ett .ne.0.0d0) write(ien,110) ' ett  = ',ett
+         if(ev  .ne.0.0d0) write(ien,110) ' ev   = ',ev
+         if(ec  .ne.0.0d0) write(ien,110) ' ec   = ',ec
+         if(ecd .ne.0.0d0) write(ien,110) ' ecd  = ',ecd
+         if(ed  .ne.0.0d0) write(ien,110) ' ed   = ',ed
+         if(em  .ne.0.0d0) write(ien,110) ' em   = ',em
+         if(ep  .ne.0.0d0) write(ien,110) ' ep   = ',ep
+         if(er  .ne.0.0d0) write(ien,110) ' er   = ',er
+         if(es  .ne.0.0d0) write(ien,110) ' es   = ',es
+         if(elf .ne.0.0d0) write(ien,110) ' elf  = ',elf
+         if(eg  .ne.0.0d0) write(ien,110) ' eg   = ',eg
+         if(ex  .ne.0.0d0) write(ien,110) ' ex   = ',ex
+  110 format(A8,f15.8)
+         close(ien)
+c
+c   Calculate the average of each energy component
+c
+         avgen(1) = ((nstrut - 1.0)*avgen(1) + eb)/nstrut
+         avgen(2) = ((nstrut - 1.0)*avgen(2) + ea)/nstrut
+         avgen(3) = ((nstrut - 1.0)*avgen(3) + eba)/nstrut
+         avgen(4) = ((nstrut - 1.0)*avgen(4) + eub)/nstrut
+         avgen(5) = ((nstrut - 1.0)*avgen(5) + eaa)/nstrut
+         avgen(6) = ((nstrut - 1.0)*avgen(6) + eopb)/nstrut
+         avgen(7) = ((nstrut - 1.0)*avgen(7) + eopd)/nstrut
+         avgen(8) = ((nstrut - 1.0)*avgen(8) + eid)/nstrut
+         avgen(9) = ((nstrut - 1.0)*avgen(9) + eit)/nstrut
+         avgen(10) = ((nstrut - 1.0)*avgen(10) + et)/nstrut
+         avgen(11) = ((nstrut - 1.0)*avgen(11) + ebt)/nstrut
+         avgen(12) = ((nstrut - 1.0)*avgen(12) + ett)/nstrut
+         avgen(13) = ((nstrut - 1.0)*avgen(13) + ev)/nstrut
+         avgen(14) = ((nstrut - 1.0)*avgen(14) + ec)/nstrut
+         avgen(15) = ((nstrut - 1.0)*avgen(15) + ecd)/nstrut
+         avgen(16) = ((nstrut - 1.0)*avgen(16) + ed)/nstrut
+         avgen(17) = ((nstrut - 1.0)*avgen(17) + em)/nstrut
+         avgen(18) = ((nstrut - 1.0)*avgen(18) + ep)/nstrut
+         avgen(19) = ((nstrut - 1.0)*avgen(19) + er)/nstrut
+         avgen(20) = ((nstrut - 1.0)*avgen(20) + es)/nstrut
+         avgen(21) = ((nstrut - 1.0)*avgen(21) + elf)/nstrut
+         avgen(22) = ((nstrut - 1.0)*avgen(22) + eg)/nstrut
+         avgen(23) = ((nstrut - 1.0)*avgen(23) + ex)/nstrut
+c
+c   Check the energy averages log for existence and open it
+c   to write the current averaged energy components
+c
+         ien = freeunit()
+         inquire(file='energy_avg.log',exist=found)
+         if (found) then
+            open(unit=ien,file='energy_avg.log',access='append')
+         else
+            open(unit=ien,file='energy_avg.log',status='new')
+         end if
+         write(ien,*) 'Average components after ',int(nstrut),
+     &                ' snapshots'
+         do k = 1, 23
+            if (avgen(k) .ne. 0.0d0) write(ien,120) k,avgen(k)
+  120    format(i3,3x,f15.8)
+         end do
+         close(ien)
+c
+c     Write the potential RMSDs in the output file,
+c     the number of snapshots used in the average,
+c     the target duration of MD production and 
+c     the current time of production (both in ps)
+c
+         write(iout,90) eprmsd
+   90 format('Elec Pot RMSD',3x,f15.8)
+         write(iout,100) 'dV/dx RMSD', epgrmsd(1)
+         write(iout,100) 'dV/dy RMSD', epgrmsd(2)
+         write(iout,100) 'dV/dz RMSD', epgrmsd(3)
+  100 format(A14,3x,f15.8)
+         write(iout,150) 'Number of averaged structures', int(nstrut)
+  150 format(A30,3x,i6)
+         tcurrprod = nstrut*dtdump
+         write(iout,160) 'Current production time (ps)',tcurrprod
+         ttargetprod = mdnprod*dt
+         write(iout,160) 'Target production time (ps)', ttargetprod
+  160 format(A30,3x,f8.3)
+c
+c    If the current production time equals the target
+c    potchk is true and simulation is finished (see tkr2qm.f)
+c
+c         potchk = (abs(tcurrprod-ttargetprod) .le. 1.0d-10)
+c
+c    Criteria to stop MD if RMSD on electrostatic potential 
+c    is below a threshold (hard coded as 1.0d-4) given that
+c    the equilibration time is finished
+c    ("convergence on potential")
+c
+c         potchk = ((eprmsd .lt. 1.0d-4).and.(eprmsd .ne. 0).and.
+c     &            (nsnap .ge. nequi))  
+      end if
+c
+c     Before going back to MD, electrostatic is
+c     switched back to including QM-MM interactions and QM,
+c     LA and MM boundary are switched to inactive by going back
+c     to the initial situation
+c
+      e4qmmm = 3
+      doespf = .false.
+      do i = 1, n
+         if (atinqm(i).ne.0) use(i) = .false.
+      end do
+c
+c    Saving the inactive atoms coordinates for Molcas hessian
+c    averaging, all the snapshots in snap.hess file, once the
+c    averaging of structure is started
+c
+      if (rmsdchk .and. domdhess) then
+         iavg = freeunit ()
+         inquire(file='snap.hess',exist=found)
+         if (found) then
+            open(unit=iavg,file='snap.hess',access='append')
+         else
+            open(unit=iavg,file='snap.hess',status='new')
+            write(iavg,140) (n-nbinqm)
+  140       format ('TKOnlyMM    ',i5)
+         end if
+         do i = 1, n
+            if (atinqm(i) .eq. 0) then
+               write(iavg,130) atomic(i),x(i),y(i),z(i)
+  130          format ('TKInaCoords ',i5,3f20.8)
+            end if
+         end do
+         close(iavg)
+      end if
+c
+c     Deleting the current snapshot structure
+c
+      iavg = freeunit ()
+      open (unit=iavg,file=snap,status='old')
+      close (unit=iavg,status='delete')
+      return
+      end
+   
diff -abuN source/bonds.f source_distrib/bonds.f
--- source/bonds.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/bonds.f	2010-08-26 11:38:26.000000000 +0200
@@ -24,6 +24,9 @@
       include 'bond.i'
       include 'couple.i'
       include 'iounit.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
 c
 c
@@ -34,6 +37,15 @@
          do j = 1, n12(i)
             k = i12(j,i)
             if (i .lt. k) then
+cqmmm Remove QM-QM and QM-Y bonds from the bonds list
+               if (qmmm(i).eq.2 .and. qmmm(k).ge.2) goto 20
+               if (qmmm(i).ge.2 .and. qmmm(k).eq.2) goto 20
+               if (qmmm(i).eq.3 .and. qmmm(k).eq.3) then
+                  write (iout,1) i,k
+    1             format (/,' BONDS -- A bond connects two Y atoms: ',
+     &                      i5,' and ',i5,'. Warning !!!')
+                  end if
+cqmmm
                nbond = nbond + 1
                if (nbond .gt. maxbnd) then
                   write (iout,10)
@@ -54,5 +66,30 @@
             end if
          end do
       end do
+c
+cqmmm Control there are enough link atoms
+c
+      do i = 1, nbond
+         j = ibnd(1,i)
+         k = ibnd(2,i)
+         if (qmmm(j).eq.0 .and. qmmm(k).eq.2) then
+            do m = 1, n
+               if (qmmm(m).eq.1 .and. i12(1,m).eq.j .and. i12(2,m).eq.k)
+     &         goto 30
+            end do
+         else if (qmmm(j).eq.2 .and. qmmm(k).eq.0) then
+            do m = 1, n
+               if (qmmm(m).eq.1 .and. i12(1,m).eq.k .and. i12(2,m).eq.j)
+     &         goto 30
+            end do
+         else
+             goto 30
+         end if
+         write (iout,31) j,k
+   31    format (/,' BONDS -- No LAH between MM atom ',i5,
+     &             ' and QM atom ',i5)
+   30    continue
+      end do
+cqmmm
       return
       end
diff -abuN source/county.f source_distrib/county.f
--- source/county.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/county.f	2010-08-26 11:38:25.000000000 +0200
@@ -0,0 +1,42 @@
+      subroutine county (iqm2tk)
+      implicit none
+      include 'sizes.i'
+      include 'atmtyp.i'
+      include 'atoms.i'
+      include 'couple.i'
+      include 'iounit.i'
+      include 'qmmm.i'
+      integer iqm2tk(nbinqm)
+      integer i,ii,j,jj,kk,icurr
+c
+      icurr = 1
+c Follow all atoms defined in the QM code
+      do i = 1, nbinqm
+         ii = iqm2tk(i)
+c If ii is a Y frontier atom
+         if (qmmm(ii).eq.3) then
+            do j = 1, n12(ii)
+               kk = i12(j,ii)
+c If kk is a QM atom, add them to the iybond list
+               if (qmmm(kk).eq.2) then
+                  iybond (1,icurr) = i
+c Look what is the numbering of the current QM atom in the QM code
+                  do jj = 1, nbinqm
+                     if (iqm2tk(jj).eq.kk) then
+                        iybond (2,icurr) = jj
+                        goto 10
+                     end if
+                  end do
+   10             icurr = icurr + 1
+              end if
+            end do
+         end if
+      end do
+      if (icurr.ne.(nybond+1)) then
+         write (iout,100)  (icurr-1),nybond
+  100    format (/,' COUNTY  --  Counted ',i2,' QM-Y bonds but ',
+     &           i2,' are expected.')
+         call fatal
+      end if
+      return
+      end
diff -abuN source/dynaqmmm.f source_distrib/dynaqmmm.f
--- source/dynaqmmm.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/dynaqmmm.f	2010-08-26 11:38:24.000000000 +0200
@@ -0,0 +1,252 @@
+c
+c     ########################################################################
+c     ##                                                                    ##
+c     ##  program dynaqmmm  --  run QM/MM molecular or stochastic dynamics  ##
+c     ##                                                                    ##
+c     ########################################################################
+c
+c
+c     "dynaqmmm" is a hack of the "dynamic" program, it aims to run QM/MM
+c     molecular dynamics
+c
+      program dynaqmmm
+      implicit none
+      include 'sizes.i'
+      include 'atoms.i'
+      include 'atmtyp.i'
+      include 'bath.i'
+      include 'bond.i'
+      include 'bound.i'
+      include 'couple.i'
+      include 'inform.i'
+      include 'iounit.i'
+      include 'mdstuf.i'
+      include 'potent.i'
+      include 'qmmm.i'
+      include 'solute.i'
+      include 'stodyn.i'
+      include 'usage.i'
+      integer istep,nstep,i,ilah
+      integer mode,modstep
+      real*8 gtmp
+      logical exist,query,domicro
+      character*120 string
+c
+c     set up the structure and molecular mechanics calculation
+c
+      call initial
+      call getxyz
+      call mechanic
+c
+c     initialize the temperature, pressure and coupling baths
+c
+      kelvin = 0.0d0
+      atmsph = 0.0d0
+      isothermal = .false.
+      isobaric = .false.
+c
+c     initialize the simulation length as number of time steps
+c
+      query = .true.
+      call nextarg (string,exist)
+      if (exist) then
+         read (string,*,err=10,end=10)  nstep
+         query = .false.
+      end if
+   10 continue
+      if (query) then
+         write (iout,20)
+   20    format (/,' Enter the Number of Dynamics Steps to be',
+     &              ' Taken :  ',$)
+         read (input,30)  nstep
+   30    format (i10)
+      end if
+c
+c     get the length of the dynamics time step in picoseconds
+c
+      dt = -1.0d0
+      call nextarg (string,exist)
+      if (exist)  read (string,*,err=40,end=40)  dt
+   40 continue
+      if (dt .le. 0.0d0) then
+         write (iout,50)
+   50    format (/,' Enter the Time Step Length in Femtoseconds',
+     &              ' [0.1] :  ',$)
+         read (input,60)  dt
+   60    format (f20.0)
+      end if
+      if (dt .le. 0.0d0)  dt = 0.1d0
+      dt = 1.0d-3 * dt
+c
+c     set bounds on the Berendsen thermostat coupling parameters
+c
+      tautemp = max(tautemp,dt)
+      taupres = max(taupres,dt)
+c
+c     set the time between trajectory snapshot coordinate dumps
+c
+      dtdump = -1.0d0
+      call nextarg (string,exist)
+      if (exist)  read (string,*,err=70,end=70)  dtdump
+   70 continue
+      if (dtdump .le. 0.0d0) then
+         write (iout,80)
+   80    format (/,' Enter Time between Dumps in Picoseconds',
+     &              ' [0.01] :  ',$)
+         read (input,90)  dtdump
+   90    format (f20.0)
+      end if
+      if (dtdump .le. 0.0d0)  dtdump = 0.01d0
+      iwrite = nint(dtdump/dt)
+c
+c     get choice of statistical ensemble for periodic system
+c
+      if (use_bounds) then
+         mode = 0
+         call nextarg (string,exist)
+         if (exist)  read (string,*,err=100,end=100)  mode
+  100    continue
+         if (mode.lt.1 .or. mode.gt.4) then
+            write (iout,110)
+  110       format (/,' Possible Statistical Mechanical Ensembles :',
+     &              //,4x,'(1) Microcanonical (NVE)',
+     &              /,4x,'(2) Canonical (NVT)',
+     &              /,4x,'(3) Isoenthalpic-Isobaric (NPH)',
+     &              /,4x,'(4) Isothermal-Isobaric (NPT)',
+     &              //,' Enter the Number of the Desired Choice',
+     &                 ' [1] :  ',$)
+            read (input,120)  mode
+  120       format (i10)
+         end if
+         if (mode.eq.2 .or. mode.eq.4) then
+            isothermal = .true.
+            kelvin = -1.0d0
+            call nextarg (string,exist)
+            if (exist)  read (string,*,err=130,end=130)  kelvin
+  130       continue
+            if (kelvin .le. 0.0d0) then
+               write (iout,140)
+  140          format (/,' Enter the Desired Temperature in Degrees',
+     &                    ' K [298] :  ',$)
+               read (input,150)  kelvin
+  150          format (f20.0)
+            end if
+            if (kelvin .le. 0.0d0)  kelvin = 298.0d0
+            kelvin0 = kelvin
+         end if
+         if (mode.eq.3 .or. mode.eq.4) then
+            isobaric = .true.
+            atmsph = -1.0d0
+            call nextarg (string,exist)
+            if (exist)  read (string,*,err=160,end=160)  atmsph
+  160       continue
+            if (atmsph .le. 0.0d0) then
+               write (iout,170)
+  170          format (/,' Enter the Desired Pressure in Atm',
+     &                    ' [1.0] :  ',$)
+               read (input,180)  atmsph
+  180          format (f20.0)
+            end if
+            if (atmsph .le. 0.0d0)  atmsph = 1.0d0
+         end if
+      end if
+c
+c     get desired temperature for nonperiodic system
+c
+      if (.not. use_bounds) then
+         isothermal = .true.
+         kelvin = -1.0d0
+         call nextarg (string,exist)
+         if (exist)  read (string,*,err=190,end=190)  kelvin
+  190    continue
+         if (kelvin .le. 0.0d0) then
+            write (iout,200)
+  200       format (/,' Enter the Desired Temperature in Degrees',
+     &                 ' K [298] :  ',$)
+            read (input,210)  kelvin
+  210       format (f20.0)
+         end if
+         if (kelvin .le. 0.0d0)  kelvin = 298.0d0
+      end if
+c
+c     determine the scaling factors defining a link atom position
+c     g = r(QM-LAH) / r(QM-MM) where r = the sum of the vdW radii
+c
+      ilah = 0
+      do i = 1, n
+         if (qmmm(i) .eq. 1) then
+            ilah = ilah + 1
+            lahg(ilah) = (rcov(atomic(i12(2,i)))+rcov(atomic(i)))/
+     &                   (rcov(atomic(i12(2,i)))+rcov(atomic(i12(1,i))))
+            gtmp = -1.0d0
+            call nextarg (string,exist)
+            if (exist)  read (string,*,err=410,end=410)  gtmp
+  410       continue
+            if (gtmp .le. 0.0d0 .or. gtmp .gt. 1.0d0) then
+               gtmp = lahg(ilah)
+               write(iout,420) i,lahg(ilah)
+  420          format (/,' LAH ',i5,' scaling factor [',f5.3,'] ? : ',$)
+               read (input,430) lahg(ilah)
+  430          format (f7.3)
+               if (lahg(ilah) .le. 0.0d0) lahg(ilah) = gtmp
+            else
+               lahg(ilah) = gtmp
+               write (iout,440) i,lahg(ilah)
+  440          format(/,' LAH ',i6,' scaling factor (user):',f6.3)
+            end if
+         end if
+      end do
+      doespf = .false.
+      domicro = .false.
+c
+c     initialize any rattle constraints and setup dynamics
+c
+      call shakeup
+      call mdinit
+c
+c     print out a header line for the dynamics computation
+c
+      if (integrate .eq. 'VERLET') then
+         write (iout,220)
+  220    format (/,' Molecular Dynamics Trajectory via',
+     &              ' Velocity Verlet Algorithm')
+      else if (integrate .eq. 'STOCHASTIC') then
+         write (iout,230)
+  230    format (/,' Stochastic Dynamics Trajectory via',
+     &              ' Velocity Verlet Algorithm')
+      else if (integrate .eq. 'RIGIDBODY') then
+         write (iout,240)
+  240    format (/,' Molecular Dynamics Trajectory via',
+     &              ' Rigid Body Algorithm')
+      else
+         write (iout,250)
+  250    format (/,' Molecular Dynamics Trajectory via',
+     &              ' Modified Beeman Algorithm')
+      end if
+c
+c     integrate equations of motion to take a time step
+c
+      do istep = 1, nstep
+         if (integrate .eq. 'VERLET') then
+            call verlet (istep,dt)
+         else if (integrate .eq. 'STOCHASTIC') then
+            call sdstep (istep,dt)
+         else if (integrate .eq. 'RIGIDBODY') then
+            call rgdstep (istep,dt)
+         else
+            call beeman (istep,dt)
+         end if
+c
+c     remove center of mass translation and rotation if needed
+c
+         modstep = mod(istep,iprint)
+         if (modstep.eq.0 .and. nuse.eq.n) then
+            if (integrate.ne.'STOCHASTIC' .and.
+     &          thermostat.ne.'ANDERSEN')  call mdrest
+         end if
+      end do
+c
+c     perform any final tasks before program exit
+c
+      call final
+      end
diff -abuN source/ebond2.f source_distrib/ebond2.f
--- source/ebond2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ebond2.f	2010-08-26 11:38:22.000000000 +0200
@@ -56,6 +56,9 @@
 c
          proceed = .true.
          if (use_group)  call groups (proceed,fgrp,ia,ib,0,0,0,0)
+cqmmm
+         proceed = proceed .and. (ib .ne. 0)
+cqmmm
 c
 c     compute the value of the bond length deviation
 c
diff -abuN source/ebuck1.f source_distrib/ebuck1.f
--- source/ebuck1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ebuck1.f	2010-08-26 11:38:24.000000000 +0200
@@ -87,6 +87,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -188,6 +191,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &         .or. (qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -545,6 +553,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm    
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -691,6 +702,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -881,6 +897,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -982,6 +1001,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/ebuck2.f source_distrib/ebuck2.f
--- source/ebuck2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ebuck2.f	2010-08-26 11:38:21.000000000 +0200
@@ -67,6 +67,9 @@
       include 'shunt.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -181,6 +184,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (k .ne. i)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the Hessian elements for this interaction
 c
diff -abuN source/ebuck3.f source_distrib/ebuck3.f
--- source/ebuck3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ebuck3.f	2010-08-26 11:38:22.000000000 +0200
@@ -98,6 +98,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -193,6 +196,11 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
             if (proceed)  proceed = (vscale(k) .ne. 0.0d0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -483,6 +491,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -622,6 +633,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -787,6 +803,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -881,6 +900,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/ebuck.f source_distrib/ebuck.f
--- source/ebuck.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ebuck.f	2010-08-26 11:38:23.000000000 +0200
@@ -77,6 +77,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -165,6 +168,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm 
 c
 c     compute the energy contribution for this interaction
 c
@@ -385,6 +393,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -518,6 +529,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -638,6 +654,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -726,6 +745,11 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echarge1.f source_distrib/echarge1.f
--- source/echarge1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echarge1.f	2010-08-26 11:38:25.000000000 +0200
@@ -75,6 +75,10 @@
       include 'shunt.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm 
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -121,6 +125,9 @@
 c
 c     compute the charge interaction energy and first derivatives
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion-1
          i = iion(ii)
          in = jion(ii)
@@ -136,21 +143,51 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 10
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
+cqmmm
+c
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kk = ii+1, nion
             k = iion(kk)
             kn = jion(kk)
@@ -158,6 +195,17 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(i),3) + mod(qmmm(k),3)) .eq. 0)
+            if (proceed .and. e4qmmm.eq.3)
+     &         proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -176,6 +224,12 @@
                   rb = r + ebuffer
                   rb2 = rb * rb
                   fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+                  if (qmmm(k) .eq. 3) then
+                     ky = ky + 1
+                     if (e4qmmm .eq. 0) fik = fi*qybond(ky)*cscale(kn)
+                  end if
+cqmmm
                   e = fik / rb
                   de = -fik / rb2
                   dc = 0.0d0
@@ -239,6 +293,26 @@
                   dec(2,kc) = dec(2,kc) - dedyc
                   dec(3,kc) = dec(3,kc) - dedzc
 c
+cqmmm substract some QM/MM contributions
+c
+                  if (doqmmmdyn .and. qmmm(i).ne.0) then
+                     ec = ec - e
+                     dec(1,i) = dec(1,i) - dedx
+                     dec(2,i) = dec(2,i) - dedy
+                     dec(3,i) = dec(3,i) - dedz
+                     dec(1,ic) = dec(1,ic) - dedxc
+                     dec(2,ic) = dec(2,ic) - dedyc
+                     dec(3,ic) = dec(3,ic) - dedzc
+                  else if (doqmmmdyn .and. qmmm(k).ne.0) then
+                     ec = ec - e
+                     dec(1,k) = dec(1,k) + dedx
+                     dec(2,k) = dec(2,k) + dedy
+                     dec(3,k) = dec(3,k) + dedz
+                     dec(1,kc) = dec(1,kc) + dedxc
+                     dec(2,kc) = dec(2,kc) + dedyc
+                     dec(3,kc) = dec(3,kc) + dedzc
+                  end if
+c
 c     increment the internal virial tensor components
 c
                   vxx = xr*dedx + xc*dedxc
@@ -289,6 +363,9 @@
 c
 c     calculate interaction energy with other unit cells
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion
          i = iion(ii)
          in = jion(ii)
@@ -304,21 +381,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 20
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 20
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   20    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kk = ii, nion
             k = iion(kk)
             kn = jion(kk)
@@ -326,6 +431,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm
+c            if (proceed .and. e4qmmm.eq.0)
+c     &         proceed = ((mod(qmmm(i),3) + mod(qmmm(k),3)) .eq. 0)
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or. 
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -345,6 +458,12 @@
                      rb = r + ebuffer
                      rb2 = rb * rb
                      fik = fi * pchg(kk)
+cqmmm
+                     if (qmmm(k) .eq. 3) then
+                        ky = ky + 1
+                        if (e4qmmm .eq. 0) fik = fi * qybond(ky)
+                     end if
+cqmmm
                      if (use_polymer) then
                         if (r2 .le. polycut2)  fik = fik * cscale(kn)
                      end if
@@ -414,6 +533,26 @@
                         dec(3,kc) = dec(3,kc) - dedzc
                      end if
 c
+cqmmm substract some QM/MM contributions
+c
+                     if (doqmmmdyn .and. qmmm(i).ne.0) then
+                        ec = ec - e
+                        dec(1,i) = dec(1,i) - dedx
+                        dec(2,i) = dec(2,i) - dedy
+                        dec(3,i) = dec(3,i) - dedz
+                        dec(1,ic) = dec(1,ic) - dedxc
+                        dec(2,ic) = dec(2,ic) - dedyc
+                        dec(3,ic) = dec(3,ic) - dedzc
+                     else if (doqmmmdyn .and. qmmm(k).ne.0) then
+                        ec = ec - e
+                        dec(1,k) = dec(1,k) + dedx
+                        dec(2,k) = dec(2,k) + dedy
+                        dec(3,k) = dec(3,k) + dedz
+                        dec(1,kc) = dec(1,kc) + dedxc
+                        dec(2,kc) = dec(2,kc) + dedyc
+                        dec(3,kc) = dec(3,kc) + dedzc
+                     end if
+c
 c     increment the internal virial tensor components
 c
                      vxx = xr*dedx + xc*dedxc
@@ -490,6 +629,9 @@
       include 'shunt.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer in,ic,kn,kc
       integer kgy,kgz,kmap
@@ -568,18 +710,31 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+c      If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 30
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   30    continue
+cqmmmm
 c
 c     loop over method of lights neighbors of current atom
 c
@@ -618,6 +773,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -715,6 +878,27 @@
                   dec(2,kc) = dec(2,kc) - dedyc
                   dec(3,kc) = dec(3,kc) - dedzc
 c
+cqmmm substract some QM/MM contributions
+c
+                  if (doqmmmdyn .and. qmmm(i).ne.0) then
+                     ec = ec - e
+                     dec(1,i) = dec(1,i) - dedx
+                     dec(2,i) = dec(2,i) - dedy
+                     dec(3,i) = dec(3,i) - dedz
+                     dec(1,ic) = dec(1,ic) - dedxc
+                     dec(2,ic) = dec(2,ic) - dedyc
+                     dec(3,ic) = dec(3,ic) - dedzc
+                  end if
+                  if (doqmmmdyn .and. qmmm(k).ne.0) then
+                     ec = ec - e
+                     dec(1,k) = dec(1,k) + dedx
+                     dec(2,k) = dec(2,k) + dedy
+                     dec(3,k) = dec(3,k) + dedz
+                     dec(1,kc) = dec(1,kc) + dedxc
+                     dec(2,kc) = dec(2,kc) + dedyc
+                     dec(3,kc) = dec(3,kc) + dedzc
+                  end if
+c
 c     increment the internal virial tensor components
 c
                   vxx = xr*dedx + xc*dedxc
@@ -797,6 +981,10 @@
       include 'shunt.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm 
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k
       integer ii,kk,kkk
       integer in,kn,ic,kc
@@ -842,6 +1030,9 @@
 c
 c     compute the charge interaction energy and first derivatives
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion
          i = iion(ii)
          in = jion(ii)
@@ -857,21 +1048,62 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 10
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
+cqmmm
+c         do j = 1, n12(in)
+c            cscale(i12(j,in)) = c2scale
+c         end do
+c         do j = 1, n13(in)
+c            cscale(i13(j,in)) = c3scale
+c         end do
+c         do j = 1, n14(in)
+c            cscale(i14(j,in)) = c4scale
+c         end do
+c         do j = 1, n15(in)
+c            cscale(i15(j,in)) = c5scale
+c         end do
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kkk = 1, nelst(ii)
             kk = elst(kkk,ii)
             k = iion(kk)
@@ -880,6 +1112,17 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(i),3) + mod(qmmm(k),3)) .eq. 0)
+            if (proceed .and. e4qmmm.eq.3)
+     &         proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -898,6 +1141,12 @@
                   rb = r + ebuffer
                   rb2 = rb * rb
                   fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+                  if (qmmm(k) .eq. 3) then
+                     ky = ky + 1
+                     if (e4qmmm .eq. 0) fik = fi*qybond(ky)*cscale(kn)
+                  end if
+cqmmm
                   e = fik / rb
                   de = -fik / rb2
                   dc = 0.0d0
@@ -961,6 +1210,26 @@
                   dec(2,kc) = dec(2,kc) - dedyc
                   dec(3,kc) = dec(3,kc) - dedzc
 c
+cqmmm substract some QM/MM contributions
+c
+                  if (doqmmmdyn .and. qmmm(i).ne.0) then
+                     ec = ec - e
+                     dec(1,i) = dec(1,i) - dedx
+                     dec(2,i) = dec(2,i) - dedy
+                     dec(3,i) = dec(3,i) - dedz
+                     dec(1,ic) = dec(1,ic) - dedxc
+                     dec(2,ic) = dec(2,ic) - dedyc
+                     dec(3,ic) = dec(3,ic) - dedzc
+                  else if (doqmmmdyn .and. qmmm(k).ne.0) then
+                     ec = ec - e
+                     dec(1,k) = dec(1,k) + dedx
+                     dec(2,k) = dec(2,k) + dedy
+                     dec(3,k) = dec(3,k) + dedz
+                     dec(1,kc) = dec(1,kc) + dedxc
+                     dec(2,kc) = dec(2,kc) + dedyc
+                     dec(3,kc) = dec(3,kc) + dedzc
+                  end if
+c
 c     increment the internal virial tensor components
 c
                   vxx = xr*dedx + xc*dedxc
@@ -1039,6 +1308,9 @@
       include 'shunt.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -1138,18 +1410,30 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -1159,6 +1443,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1202,6 +1494,21 @@
                   dec(2,k) = dec(2,k) - dedy
                   dec(3,k) = dec(3,k) - dedz
 c
+cqmmm substract some QM/MM contributions
+c
+                  if (doqmmmdyn .and. qmmm(i).ne.0) then
+                     ec = ec - e
+                     dec(1,i) = dec(1,i) - dedx
+                     dec(2,i) = dec(2,i) - dedy
+                     dec(3,i) = dec(3,i) - dedz
+                  end if
+                  if (doqmmmdyn .and. qmmm(k).ne.0) then
+                     ec = ec - e
+                     dec(1,k) = dec(1,k) + dedx
+                     dec(2,k) = dec(2,k) + dedy
+                     dec(3,k) = dec(3,k) + dedz
+                  end if
+c
 c     increment the internal virial tensor components
 c
                   vxx = xr * dedx
@@ -1264,18 +1571,30 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 20
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   20    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -1285,6 +1604,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or. 
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1337,6 +1664,21 @@
                         dec(3,k) = dec(3,k) - dedz
                      end if
 c
+cqmmm substract some QM/MM contributions
+c
+                      if (doqmmmdyn .and. qmmm(i).ne.0) then
+                         ec = ec - e
+                         dec(1,i) = dec(1,i) - dedx
+                         dec(2,i) = dec(2,i) - dedy
+                         dec(3,i) = dec(3,i) - dedz
+                      end if
+                      if(doqmmmdyn .and. qmmm(k).ne.0 .and. k.ne.i) then
+                         ec = ec - e
+                         dec(1,k) = dec(1,k) + dedx
+                         dec(2,k) = dec(2,k) + dedy
+                         dec(3,k) = dec(3,k) + dedz
+                      end if
+c
 c     increment the internal virial tensor components
 c
                      vxx = xr * dedx
@@ -1973,6 +2315,9 @@
       include 'molcul.i'
       include 'usage.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -2036,18 +2381,25 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -2057,6 +2409,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -2137,6 +2497,21 @@
                dec(2,k) = dec(2,k) - dedy
                dec(3,k) = dec(3,k) - dedz
 c
+cqmmm substract some QM/MM contributions
+c
+              if (doqmmmdyn .and. qmmm(i).ne.0) then
+                 ec = ec - e
+                 dec(1,i) = dec(1,i) - dedx
+                 dec(2,i) = dec(2,i) - dedy
+                 dec(3,i) = dec(3,i) - dedz
+              end if
+              if (doqmmmdyn .and. qmmm(k).ne.0) then
+                 ec = ec - e
+                 dec(1,k) = dec(1,k) + dedx
+                 dec(2,k) = dec(2,k) + dedy
+                 dec(3,k) = dec(3,k) + dedz
+              end if
+c
 c     increment the total intermolecular energy
 c
                if (molcule(i) .ne. molcule(k)) then
diff -abuN source/echarge2.f source_distrib/echarge2.f
--- source/echarge2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echarge2.f	2010-08-26 11:38:22.000000000 +0200
@@ -60,6 +60,10 @@
       include 'group.i'
       include 'hessn.i'
       include 'shunt.i'
+cqmmm
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k,kk
       integer in,kn,jcell
       real*8 e,de,d2e
@@ -84,6 +88,20 @@
          if (iion(k) .eq. i) then
             fi = electric * pchg(k) / dielec
             in = jion(k)
+cqmmm
+            if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 0) then
+               j = 0
+               iy = 0
+11             j = j + 1
+               if (qmmm(j).eq.3) iy = iy + 1
+               if (j.lt.n .or. j.ne.i) goto 11
+               if (j.eq.n .and. j.ne.i) then
+                  write(*,*) 'ECHARGE2 -- stop 1'
+                  call fatal
+               end if
+               fi = electric * qybond(iy) / dielec
+            end if
+cqmmm
             goto 10
          end if
       end do
@@ -98,21 +116,38 @@
 c
 c     set array needed to scale connected atom interactions
 c
+cqmmm modified
       do j = 1, nion
          cscale(iion(j)) = 1.0d0
+         if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
       end do
+      if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 20
+      if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 20
       do j = 1, n12(in)
          cscale(i12(j,in)) = c2scale
+         if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &      (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &      cscale(i12(j,in)) = qmmmscale
       end do
       do j = 1, n13(in)
          cscale(i13(j,in)) = c3scale
+         if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &      (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &      cscale(i13(j,in)) = qmmmscale
       end do
       do j = 1, n14(in)
          cscale(i14(j,in)) = c4scale
+         if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &      (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &      cscale(i14(j,in)) = qmmmscale
       end do
       do j = 1, n15(in)
          cscale(i15(j,in)) = c5scale
+         if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &      (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &      cscale(i15(j,in)) = qmmmscale
       end do
+   20 continue
 c
 c     set cutoff distances and switching function coefficients
 c
@@ -126,6 +161,16 @@
          proceed = .true.
          if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
          if (proceed)  proceed = (kn .ne. i)
+cqmmm Exclude some QM/MM interactions
+         if (proceed .and. e4qmmm.eq.0)
+     &      proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+         if (proceed .and. e4qmmm.eq.3)
+     &      proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+         if (doespf .and.
+     &        ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &         (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &      proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -140,6 +185,20 @@
                rb = r + ebuffer
                rb2 = rb * rb
                fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+               if (qmmm(k) .eq. 3 .and. e4qmmm .eq. 0) then
+                  j = 0
+                  ky = 0
+21                j = j + 1
+                  if (qmmm(j).eq.3) ky = ky + 1
+                  if (j.lt.n .or. j.ne.k) goto 21
+                  if (j.eq.n .and. j.ne.k) then
+                     write(*,*) 'ECHARGE2 -- stop 2'
+                     call fatal
+                  end if
+                  fik = fi * qybond(ky) * cscale(kn)
+               end if
+cqmmm
 c
 c     compute chain rule terms for Hessian matrix elements
 c
@@ -225,6 +284,15 @@
          kn = jion(kk)
          proceed = .true.
          if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
+cqmmm
+c            if (proceed .and. e4qmmm.eq.0)
+c     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
+cqmmm
 c
 c     compute the energy contribution for this interaction
 c
@@ -240,6 +308,20 @@
                   rb = r + ebuffer
                   rb2 = rb * rb
                   fik = fi * pchg(kk)
+cqmmm
+                  if (qmmm(k) .eq. 3 .and. e4qmmm .eq. 0) then
+                     j = 0
+                     ky = 0
+22                   j = j + 1
+                     if (qmmm(j).eq.3) ky = ky + 1
+                     if (j.lt.n .or. j.ne.k) goto 22
+                     if (j.eq.n .and. j.ne.k) then
+                        write(*,*) 'ECHARGE2 -- stop 3'
+                        call fatal
+                     end if
+                     fik = fi * qybond(ky)
+                  end if
+cqmmm
                   if (use_polymer) then
                      if (r2 .le. polycut2)  fik = fik * cscale(kn)
                   end if
@@ -349,6 +431,9 @@
       include 'group.i'
       include 'hessn.i'
       include 'math.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,kk
       integer in,kn,jcell
       real*8 fi,fik,fgrp
@@ -389,19 +474,29 @@
 c
       do j = 1, nion
          cscale(iion(j)) = 1.0d0
+         if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
       end do
+c
+cqmmm If one atom is QM, no scale factor
+c
+      if (qmmm(i).gt.0) goto 20
       do j = 1, n12(in)
          cscale(i12(j,in)) = c2scale
+         if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
       end do
       do j = 1, n13(in)
          cscale(i13(j,in)) = c3scale
+         if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
       end do
       do j = 1, n14(in)
          cscale(i14(j,in)) = c4scale
+         if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
       end do
       do j = 1, n15(in)
          cscale(i15(j,in)) = c5scale
+         if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
       end do
+   20 continue
 c
 c     calculate the real space Ewald interaction Hessian elements
 c
@@ -411,6 +506,14 @@
          if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
          proceed = .true.
          if (proceed)  proceed = (kn .ne. i)
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+         if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                          (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -484,6 +587,15 @@
          if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
          proceed = .true.
 c
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+         if (proceed) proceed = (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
+c
 c     compute the energy contribution for this interaction
 c
          if (proceed) then
@@ -576,6 +688,9 @@
       include 'hessn.i'
       include 'math.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,kk
       integer in,kn
       real*8 fi,fik,fgrp
@@ -616,19 +731,27 @@
 c
       do j = 1, nion
          cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
       end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 20
       do j = 1, n12(in)
          cscale(i12(j,in)) = c2scale
+         if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
       end do
       do j = 1, n13(in)
          cscale(i13(j,in)) = c3scale
+         if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
       end do
       do j = 1, n14(in)
          cscale(i14(j,in)) = c4scale
+         if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
       end do
       do j = 1, n15(in)
          cscale(i15(j,in)) = c5scale
+         if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
       end do
+   20 continue
 c
 c     set the smallest exponential terms to be calculated
 c
@@ -653,6 +776,14 @@
          proceed = .true.
          if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
          if (proceed)  proceed = (kn .ne. i)
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+         if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                          (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echarge3.f source_distrib/echarge3.f
--- source/echarge3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echarge3.f	2010-08-26 11:38:25.000000000 +0200
@@ -78,6 +78,10 @@
       include 'molcul.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -120,6 +124,9 @@
 c
 c     compute and partition the charge interaction energy
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion-1
          i = iion(ii)
          in = jion(ii)
@@ -135,21 +142,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 50
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 50
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   50    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kk = ii+1, nion
             k = iion(kk)
             kn = jion(kk)
@@ -158,6 +193,16 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
             if (proceed)  proceed = (cscale(kn) .ne. 0.0d0)
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &         proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -175,6 +220,12 @@
                   r = sqrt(r2)
                   rb = r + ebuffer
                   fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+                  if (qmmm(k) .eq. 3) then
+                     ky = ky + 1
+                     if (e4qmmm .eq. 0) fik = fi*qybond(ky)*cscale(kn)
+                  end if
+cqmmm
                   e = fik / rb
 c
 c     use shifted energy switching if near the cutoff distance
@@ -257,6 +308,9 @@
 c
 c     calculate interaction energy with other unit cells
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion
          i = iion(ii)
          in = jion(ii)
@@ -272,21 +326,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 60
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 60
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   60    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kk = ii, nion
             k = iion(kk)
             kn = jion(kk)
@@ -294,6 +376,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm
+c            if (proceed .and. e4qmmm.eq.0)
+c     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or. 
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -312,6 +402,12 @@
                      r = sqrt(r2)
                      rb = r + ebuffer
                      fik = fi * pchg(kk)
+cqmmm
+                     if (qmmm(k) .eq. 3) then
+                        ky = ky + 1
+                        if (e4qmmm .eq. 0) fik = fi * qybond(ky)
+                     end if
+cqmmm
                      if (use_polymer) then
                         if (r2 .le. polycut2)  fik = fik * cscale(kn)
                      end if
@@ -428,6 +524,9 @@
       include 'molcul.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer in,ic,kn,kc
       integer kgy,kgz,kmap
@@ -502,18 +601,34 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0.and.qmmm(i)-e4qmmm.ne.3)
+     &          cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0.and.qmmm(i).lt.3) goto 98 
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0.and.qmmm(i12(j,in))-e4qmmm.ne.3)
+     &          cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0.and.qmmm(i13(j,in))-e4qmmm.ne.3)
+     &          cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0.and.qmmm(i14(j,in))-e4qmmm.ne.3)
+     &          cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0.and.qmmm(i15(j,in))-e4qmmm.ne.3)
+     &          cscale(i15(j,in)) = qmmmscale
          end do
+   98    continue
 c
 c     loop over method of lights neighbors of current atom
 c
@@ -552,6 +667,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -710,6 +833,10 @@
       include 'neigh.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k
       integer ii,kk,kkk
       integer in,kn
@@ -752,6 +879,9 @@
 c
 c     compute and partition the charge interaction energy
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion-1
          i = iion(ii)
          in = jion(ii)
@@ -767,21 +897,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 50
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 50
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   50    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kkk = 1, nelst(ii)
             kk = elst(kkk,ii)
             k = iion(kk)
@@ -791,6 +949,16 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
             if (proceed)  proceed = (cscale(kn) .ne. 0.0d0)
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &         proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -808,6 +976,12 @@
                   r = sqrt(r2)
                   rb = r + ebuffer
                   fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+                  if (qmmm(k) .eq. 3) then
+                     ky = ky + 1
+                     if (e4qmmm .eq. 0) fik = fi*qybond(ky)*cscale(kn)
+                  end if
+cqmmm
                   e = fik / rb
 c
 c     use shifted energy switching if near the cutoff distance
@@ -921,6 +1095,9 @@
       include 'molcul.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -1006,18 +1183,34 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0.and.qmmm(i)-e4qmmm.ne.3)
+     &          cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0.and.qmmm(i).lt.3) goto 50
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0.and.qmmm(i12(j,in))-e4qmmm.ne.3)
+     &          cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0.and.qmmm(i13(j,in))-e4qmmm.ne.3)
+     &          cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0.and.qmmm(i14(j,in))-e4qmmm.ne.3)
+     &          cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0.and.qmmm(i15(j,in))-e4qmmm.ne.3)
+     &          cscale(i15(j,in)) = qmmmscale
          end do
+   50    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -1027,6 +1220,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1124,18 +1325,34 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0.and.qmmm(i)-e4qmmm.ne.3)
+     &          cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0.and.qmmm(i).lt.3) goto 60
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0.and.qmmm(i12(j,in))-e4qmmm.ne.3)
+     &          cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0.and.qmmm(i13(j,in))-e4qmmm.ne.3)
+     &          cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0.and.qmmm(i14(j,in))-e4qmmm.ne.3)
+     &          cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0.and.qmmm(i15(j,in))-e4qmmm.ne.3)
+     &          cscale(i15(j,in)) = qmmmscale
          end do
+   60    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -1145,6 +1362,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1259,6 +1484,9 @@
       include 'molcul.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm	
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk,in,kn
       integer kgy,kgz,kmap
@@ -1363,18 +1591,34 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0.and.qmmm(i)-e4qmmm.ne.3)
+     &          cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0.and.qmmm(i).lt.3) goto 99
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0.and.qmmm(i12(j,in))-e4qmmm.ne.3)
+     &          cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0.and.qmmm(i13(j,in))-e4qmmm.ne.3)
+     &          cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0.and.qmmm(i14(j,in))-e4qmmm.ne.3)
+     &          cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0.and.qmmm(i15(j,in))-e4qmmm.ne.3)
+     &          cscale(i15(j,in)) = qmmmscale
          end do
+   99    continue
 c
 c     loop over method of lights neighbors of current atom
 c
@@ -1412,6 +1656,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1778,6 +2030,9 @@
       include 'molcul.i'
       include 'usage.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -1838,18 +2093,34 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0.and.qmmm(i)-e4qmmm.ne.3)
+     &          cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0.and.qmmm(i).lt.3) goto 30
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0.and.qmmm(i12(j,in))-e4qmmm.ne.3)
+     &          cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0.and.qmmm(i13(j,in))-e4qmmm.ne.3)
+     &          cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0.and.qmmm(i14(j,in))-e4qmmm.ne.3)
+     &          cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0.and.qmmm(i15(j,in))-e4qmmm.ne.3)
+     &          cscale(i15(j,in)) = qmmmscale
          end do
+   30    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -1860,6 +2131,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k))
             if (proceed)  proceed = (cscale(kn) .ne. 0.0d0)
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echarge.f source_distrib/echarge.f
--- source/echarge.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echarge.f	2010-08-26 11:38:24.000000000 +0200
@@ -69,6 +69,10 @@
       include 'group.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -105,6 +109,9 @@
 c
 c     calculate the charge interaction energy term
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion-1
          i = iion(ii)
          in = jion(ii)
@@ -120,21 +127,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 10
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kk = ii+1, nion
             k = iion(kk)
             kn = jion(kk)
@@ -142,6 +177,16 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &         proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -159,6 +204,12 @@
                   r = sqrt(r2)
                   rb = r + ebuffer
                   fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+                  if (qmmm(k) .eq. 3) then
+                     ky = ky + 1
+                     if (e4qmmm .eq. 0) fik = fi*qybond(ky)*cscale(kn)
+                  end if
+cqmmm
                   e = fik / rb
 c
 c     use shifted energy switching if near the cutoff distance
@@ -213,6 +264,9 @@
 c
 c     calculate interaction energy with other unit cells
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion
          i = iion(ii)
          in = jion(ii)
@@ -228,21 +282,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 20
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 20
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   20    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kk = ii, nion
             k = iion(kk)
             kn = jion(kk)
@@ -250,6 +332,15 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm
+c            if (proceed .and. e4qmmm.eq.0)
+c     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+c
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -268,6 +359,12 @@
                      r = sqrt(r2)
                      rb = r + ebuffer
                      fik = fi * pchg(kk)
+cqmmm
+                     if (qmmm(k) .eq. 3) then
+                        ky = ky + 1
+                        if (e4qmmm .eq. 0) fik = fi * qybond(ky)
+                     end if
+cqmmm
                      if (use_polymer) then
                         if (r2 .le. polycut2)  fik = fik * cscale(kn)
                      end if
@@ -350,6 +447,9 @@
       include 'light.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer in,ic,kn,kc
       integer kgy,kgz,kmap
@@ -418,18 +518,29 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 30
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   30    continue
 c
 c     loop over method of lights neighbors of current atom
 c
@@ -468,6 +579,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -582,6 +701,10 @@
       include 'neigh.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+      integer iy,ky
+cqmmm
       integer i,j,k
       integer ii,kk,kkk
       integer in,kn,ic,kc
@@ -617,6 +740,9 @@
 c
 c     calculate the charge interaction energy term
 c
+cqmmm
+      iy = 0
+cqmmm
       do ii = 1, nion
          i = iion(ii)
          in = jion(ii)
@@ -632,21 +758,49 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+cqmmm If this atom is QM or LAH no scale factor, except if one is
+cqmmm defined in qmmmscale. The YA case is much more complicated !
+         if (qmmm(i) .eq. 3) then
+            iy = iy + 1
+            if (e4qmmm .eq. 0) fi = f * qybond(iy)
+         end if
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+         if (qmmm(i) .eq. 1 .or. qmmm(i) .eq. 2) goto 10
+         if (qmmm(i) .eq. 3 .and. e4qmmm .eq. 3) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).eq.1 .or. qmmm(i12(j,in)).eq.2 .or.
+     &         (qmmm(i12(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).eq.1 .or. qmmm(i13(j,in)).eq.2 .or.
+     &         (qmmm(i13(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).eq.1 .or. qmmm(i14(j,in)).eq.2 .or.
+     &         (qmmm(i14(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).eq.1 .or. qmmm(i15(j,in)).eq.2 .or.
+     &         (qmmm(i15(j,in)).eq.3 .and. e4qmmm.eq.3))
+     &         cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
 c
 c     decide whether to compute the current interaction
 c
+cqmmm
+         ky = iy
+cqmmm
          do kkk = 1, nelst(ii)
             kk = elst(kkk,ii)
             k = iion(kk)
@@ -655,6 +809,16 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kc))
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(i),3)+mod(qmmm(k),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &         proceed = (mod(qmmm(i),3).eq.0 .or. mod(qmmm(k),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -672,6 +836,12 @@
                   r = sqrt(r2)
                   rb = r + ebuffer
                   fik = fi * pchg(kk) * cscale(kn)
+cqmmm
+                  if (qmmm(k) .eq. 3) then
+                     ky = ky + 1
+                     if (e4qmmm .eq. 0) fik = fi*qybond(ky)*cscale(kn)
+                  end if
+cqmmm
                   e = fik / rb
 c
 c     use shifted energy switching if near the cutoff distance
@@ -749,6 +919,9 @@
       include 'math.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -822,18 +995,29 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -843,6 +1027,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -904,18 +1096,29 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 20
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   20    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -925,6 +1128,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).ne.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1008,6 +1219,9 @@
       include 'math.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk,in,kn
       integer kgy,kgz,kmap
@@ -1100,18 +1314,29 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 30
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   30    continue
 c
 c     loop over method of lights neighbors of current atom
 c
@@ -1149,6 +1374,14 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1408,6 +1641,9 @@
       include 'group.i'
       include 'usage.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer in,kn
@@ -1462,18 +1698,29 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = ii+1, nion
+            cscale(iion(j)) = 1.0d0
+            if (qmmm(i).gt.0) cscale(iion(j)) = qmmmscale
+         end do
+cqmmm If one atom is QM, no scale factor
+         if (qmmm(i).gt.0) goto 10
          do j = 1, n12(in)
             cscale(i12(j,in)) = c2scale
+            if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = qmmmscale
          end do
          do j = 1, n13(in)
             cscale(i13(j,in)) = c3scale
+            if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = qmmmscale
          end do
          do j = 1, n14(in)
             cscale(i14(j,in)) = c4scale
+            if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = qmmmscale
          end do
          do j = 1, n15(in)
             cscale(i15(j,in)) = c5scale
+            if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = qmmmscale
          end do
+   10    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -1483,6 +1730,14 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k))
+cqmmm Exclude all QM-QM interactions and possibly QM-MM interactions
+            if (proceed) proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0).and.
+     &                             (qmmm(i)+qmmm(k).le.e4qmmm)
+cqmmm ... and some MM/MM interactions too !
+            if (doespf .and.
+     &           ((atinqm(i).eq.0 .and. atinqm(k).ne.0) .or.
+     &            (atinqm(i).ne.0 .and. atinqm(k).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echgdpl1.f source_distrib/echgdpl1.f
--- source/echgdpl1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echgdpl1.f	2010-08-26 11:38:24.000000000 +0200
@@ -35,6 +35,9 @@
       include 'units.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer i1,k1,k2
       integer skip(maxatm)
@@ -104,6 +107,14 @@
             if (proceed)  proceed = (use(i1) .or. use(k1) .or. use(k2))
             if (proceed)  proceed = (skip(k1).ne.i1 .and.
      &                                 skip(k2).ne.i1)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -256,6 +267,13 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
             if (proceed)  proceed = (use(i1) .or. use(k1) .or. use(k2))
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echgdpl2.f source_distrib/echgdpl2.f
--- source/echgdpl2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echgdpl2.f	2010-08-26 11:38:21.000000000 +0200
@@ -30,6 +30,9 @@
       include 'hessn.i'
       include 'shunt.i'
       include 'units.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,k,jcell
       integer ii,i1,k1,k2
       integer skip(maxatm)
@@ -115,6 +118,13 @@
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
             if (proceed)  proceed = (skip(k1).ne.i1 .and.
      &                                 skip(k2).ne.i1)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -374,6 +384,13 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
             if (proceed)  proceed = (omit(i1) .ne. k)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -772,6 +789,13 @@
             k2 = idpl(2,k)
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1038,6 +1062,13 @@
             i1 = iion(ii)
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echgdpl3.f source_distrib/echgdpl3.f
--- source/echgdpl3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echgdpl3.f	2010-08-26 11:38:22.000000000 +0200
@@ -38,6 +38,9 @@
       include 'shunt.i'
       include 'units.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer i1,k1,k2
       integer skip(maxatm)
@@ -97,6 +100,13 @@
             if (proceed)  proceed = (use(i1) .or. use(k1) .or. use(k2))
             if (proceed)  proceed = (skip(k1).ne.i1 .and.
      &                                 skip(k2).ne.i1)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -194,6 +204,13 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
             if (proceed)  proceed = (use(i1) .or. use(k1) .or. use(k2))
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/echgdpl.f source_distrib/echgdpl.f
--- source/echgdpl.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/echgdpl.f	2010-08-26 11:38:23.000000000 +0200
@@ -30,6 +30,9 @@
       include 'shunt.i'
       include 'units.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer i1,k1,k2
       integer skip(maxatm)
@@ -82,6 +85,14 @@
             if (proceed)  proceed = (use(i1) .or. use(k1) .or. use(k2))
             if (proceed)  proceed = (skip(k1).ne.i1 .and.
      &                                 skip(k2).ne.i1)
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -152,6 +163,14 @@
             if (use_group)  call groups (proceed,fgrp,i1,k1,k2,0,0,0)
             if (proceed)  proceed = (use(i1) .or. use(k1) .or. use(k2))
 c
+cqmmm Bond dipoles are only pure MM ones !
+cqmmm Dipoles on QM atoms not yet implemented
+            if (proceed)  proceed = (qmmm(i1).le.e4qmmm).and.
+     &                    (qmmm(k1)+qmmm(k2).eq.0)
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(k1).ne.0
+     &       .or. atinqm(k2).ne.0))
+     &         proceed = .false.
+c
 c     compute the energy contribution for this interaction
 c
             if (proceed) then
diff -abuN source/edipole1.f source_distrib/edipole1.f
--- source/edipole1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/edipole1.f	2010-08-26 11:38:24.000000000 +0200
@@ -33,6 +33,9 @@
       include 'units.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer i1,i2,k1,k2
       real*8 xi,yi,zi
@@ -106,6 +109,13 @@
      &                                 use(k1) .or. use(k2))
             if (proceed)  proceed = (k1.ne.i1 .and. k1.ne.i2 .and.
      &                                 k2.ne.i1 .and. k2.ne.i2)
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -292,6 +302,13 @@
             if (use_group)  call groups (proceed,fgrp,i1,i2,k1,k2,0,0)
             if (proceed)  proceed = (use(i1) .or. use(i2) .or.
      &                                 use(k1) .or. use(k2))
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/edipole2.f source_distrib/edipole2.f
--- source/edipole2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/edipole2.f	2010-08-26 11:38:23.000000000 +0200
@@ -28,6 +28,9 @@
       include 'hessn.i'
       include 'units.i'
       include 'shunt.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,i1,i2,k1,k2
       integer jcell,idipole,kdipole
       real*8 f,fi,fik,fgrp
@@ -125,6 +128,13 @@
             if (use_group)  call groups (proceed,fgrp,i1,i2,k1,k2,0,0)
             if (proceed)  proceed = (k1.ne.i1 .and. k1.ne.i2 .and.
      &                                 k2.ne.i1 .and. k2.ne.i2)
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -756,6 +766,13 @@
             k2 = idpl(2,kdipole)
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i1,i2,k1,k2,0,0)
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
             if (.not. proceed)  goto 20
 c
 c     compute the energy contribution for this interaction
diff -abuN source/edipole3.f source_distrib/edipole3.f
--- source/edipole3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/edipole3.f	2010-08-26 11:38:23.000000000 +0200
@@ -36,6 +36,9 @@
       include 'shunt.i'
       include 'units.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer i1,i2,k1,k2
       real*8 xi,yi,zi
@@ -93,6 +96,13 @@
      &                                 use(k1) .or. use(k2))
             if (proceed)  proceed = (k1.ne.i1 .and. k1.ne.i2 .and.
      &                                 k2.ne.i1 .and. k2.ne.i2)
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -200,6 +210,13 @@
             if (use_group)  call groups (proceed,fgrp,i1,i2,k1,k2,0,0)
             if (proceed)  proceed = (use(i1) .or. use(i2) .or.
      &                                 use(k1) .or. use(k2))
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/edipole.f source_distrib/edipole.f
--- source/edipole.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/edipole.f	2010-08-26 11:38:26.000000000 +0200
@@ -28,6 +28,9 @@
       include 'shunt.i'
       include 'units.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer i1,i2,k1,k2
       real*8 xi,yi,zi
@@ -79,6 +82,13 @@
      &                                 use(k1) .or. use(k2))
             if (proceed)  proceed = (k1.ne.i1 .and. k1.ne.i2 .and.
      &                                 k2.ne.i1 .and. k2.ne.i2)
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -154,6 +164,13 @@
             if (use_group)  call groups (proceed,fgrp,i1,i2,k1,k2,0,0)
             if (proceed)  proceed = (use(i1) .or. use(i2) .or.
      &                                 use(k1) .or. use(k2))
+cqmmm Bond dipoles are only MM ones !
+            if (proceed) proceed = (qmmm(i1)+qmmm(i2)+qmmm(k1)+qmmm(k2))
+     &                             .eq.0
+cqmmm discard some MM/MM interactions too !
+            if (doespf .and. (atinqm(i1).ne.0 .or. atinqm(i2).ne.0
+     &       .or. atinqm(k1).ne.0 .or. atinqm(k2).ne.0))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/egauss1.f source_distrib/egauss1.f
--- source/egauss1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/egauss1.f	2010-08-26 11:38:24.000000000 +0200
@@ -69,6 +69,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
       integer ii,iv,it
       integer kk,kv,kt
@@ -164,6 +167,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -344,6 +351,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -857,6 +868,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -952,6 +966,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -1122,6 +1140,9 @@
       include 'vdwpot.i'
       include 'virial.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer iv,kv,it,kt
       integer iv14(maxatm)
@@ -1226,6 +1247,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/egauss2.f source_distrib/egauss2.f
--- source/egauss2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/egauss2.f	2010-08-26 11:38:25.000000000 +0200
@@ -61,6 +61,9 @@
       include 'shunt.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -167,6 +170,10 @@
             proceed = (k .ne. i)
             if (proceed .and. use_group)
      &         call groups (proceed,fgrp,i,k,0,0,0,0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the Hessian elements for this interaction
 c
@@ -385,6 +392,10 @@
             kv = ired(k)
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the Hessian elements for this interaction
 c
@@ -610,6 +621,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,iatom
       integer ii,iv,it
       integer kk,kv,kt
@@ -727,6 +741,10 @@
             proceed = (k .ne. i)
             if (proceed .and. use_group)
      &         call groups (proceed,fgrp,i,k,0,0,0,0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the Hessian elements for this interaction
 c
diff -abuN source/egauss3.f source_distrib/egauss3.f
--- source/egauss3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/egauss3.f	2010-08-26 11:38:23.000000000 +0200
@@ -70,6 +70,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
       integer ii,iv,it
       integer kk,kv,kt
@@ -159,6 +162,10 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
             if (proceed)  proceed = (vscale(k) .ne. 0.0d0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -299,6 +306,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -747,6 +758,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -835,6 +849,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -969,6 +987,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer iv,kv,it,kt
       integer iv14(maxatm)
@@ -1067,6 +1088,10 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
             if (proceed)  proceed = (vscale(k) .ne. 0.0d0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/egauss.f source_distrib/egauss.f
--- source/egauss.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/egauss.f	2010-08-26 11:38:26.000000000 +0200
@@ -62,6 +62,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
       integer ii,iv,it
       integer kk,kv,kt
@@ -144,6 +147,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -255,6 +262,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -611,6 +622,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -693,6 +707,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -791,6 +809,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer iv,kv,it,kt
       integer iv14(maxatm)
@@ -881,6 +902,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/ehal1.f source_distrib/ehal1.f
--- source/ehal1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ehal1.f	2010-08-26 11:38:21.000000000 +0200
@@ -78,6 +78,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -172,6 +175,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -525,6 +532,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -664,6 +674,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -852,6 +866,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -946,6 +963,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/ehal2.f source_distrib/ehal2.f
--- source/ehal2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ehal2.f	2010-08-26 11:38:22.000000000 +0200
@@ -29,6 +29,9 @@
       include 'shunt.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -136,6 +139,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (k .ne. i)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the Hessian elements for this interaction
 c
diff -abuN source/ehal3.f source_distrib/ehal3.f
--- source/ehal3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ehal3.f	2010-08-26 11:38:25.000000000 +0200
@@ -90,6 +90,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -176,6 +179,10 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
             if (proceed)  proceed = (vscale(k) .ne. 0.0d0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -460,6 +467,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -590,6 +600,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -751,6 +765,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -836,6 +853,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/ehal.f source_distrib/ehal.f
--- source/ehal.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/ehal.f	2010-08-26 11:38:23.000000000 +0200
@@ -68,6 +68,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -147,6 +150,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -359,6 +366,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -483,6 +493,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -599,6 +613,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -678,6 +695,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/elecpol.f source_distrib/elecpol.f
--- source/elecpol.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/elecpol.f	2010-08-26 11:38:24.000000000 +0200
@@ -0,0 +1,333 @@
+c
+c
+c     #######################################################################
+c     ##                                                                   ##
+c     ##  subroutine    elecpol  --  electrostatic multipole potential     ##
+c     ##                                                                   ##
+c     #######################################################################
+c
+c
+c     "elecpol" computes the electrostatic potential,
+c     due to the MM point charges, dipole & quadrupole in a QM/MM calculation.
+c     WARNING: units are e/A in elecf, e/A^2 in elecg, e/A^3 in elech !!!
+c
+c
+      subroutine elecpol(i,elecf,elecg,elech)
+      implicit none
+      include 'sizes.i'
+      include 'atoms.i'
+      include 'bound.i'
+      include 'cell.i'
+      include 'chgpot.i'
+      include 'couple.i'
+      include 'energi.i'
+      include 'group.i'
+      include 'mplpot.i'
+      include 'mpole.i'
+      include 'polar.i'
+      include 'polgrp.i'
+      include 'polpot.i'
+      include 'qmmm.i'
+      include 'shunt.i'
+      include 'units.i'
+      include 'usage.i'
+      integer i,k,kk,j,ii,ix,iz,kx,kz,ll
+      real*8 f,e,ei,xr,yr,zr
+      real*8 ci,dix,diy,diz
+      real*8 uix,uiy,uiz
+      real*8 qixx,qixy,qixz
+      real*8 qiyy,qiyz,qizz
+      real*8 ck,dkx,dky,dkz
+      real*8 ukx,uky,ukz
+      real*8 qkxx,qkxy,qkxz
+      real*8 qkyy,qkyz,qkzz
+      real*8 qix,qiy,qiz
+      real*8 qkx,qky,qkz
+      real*8 elecf,elecg(3),elech(6)
+      real*8 r,r2
+      real*8 rr1,rr3,rr5,rr7,rr9
+      real*8 fgrp,damp,fikp,fikm
+      real*8 scale3,scale5,scale7
+      real*8 sc(10),sci(8)
+      real*8 gl(0:4),gli(3)
+      real*8 mscale(maxatm)
+      real*8 pscale(maxatm)
+      real*8 mat(10,10)
+      real*8 pgamma
+      logical proceed,juse,kuse
+c
+c     Create an identity matrix
+c
+      do k = 1, 10
+         do j = 1, 10
+            mat(k,j) = 0.0d0
+         end do
+         mat(k,k) = 1.0d0
+      end do
+c
+c     Some initialization
+c
+      elecf = 0.0d0
+      do j = 1, 3
+         elecg(j) = 0.0d0
+      end do
+      do j = 1, 6
+         elech(j) = 0.0d0
+      end do
+c
+c     check the sign of multipole components at chiral sites
+c
+c      call chkpole
+c
+c     rotate the multipole components into the global frame
+c
+c      call rotpole
+c
+c     compute the induced dipoles at each polarizable atom
+c
+c      call induce
+c
+c     set conversion factor and switching function coefficients
+c     f is not electric / dielec since we don't need to convert
+c     the potential
+c
+      f = 1.0d0 / dielec
+      call switch ('MPOLE')
+c
+c     Initialize the charge value
+c
+      ii = ipole(i)
+      iz = zaxis(i)
+      ix = xaxis(i)
+c
+c     Loop to choose which interaction:
+c      * charge value     = 1     -> potential
+c      * dipole component = 1     -> field
+c      * quadrupole component = 1 -> field derivate
+c
+      do ll = 1, 10
+         ci   = mat(ll,1)
+         dix  = mat(ll,2)
+         diy  = mat(ll,3)
+         diz  = mat(ll,4)
+         qixx = mat(ll,5)
+         qixy = mat(ll,6)
+         qixz = mat(ll,7)
+         qiyy = mat(ll,8)
+         qiyz = mat(ll,9)
+         qizz = mat(ll,10)
+         uix  = 0.0d0
+         uiy  = 0.0d0
+         uiz  = 0.0d0
+         juse = (use(ii) .or. use(iz) .or. use(ix))
+         do j = 1, npole
+            mscale(ipole(j)) = 1.0d0
+            pscale(ipole(j)) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(ipole(j)) = qmmmscale
+               pscale(ipole(j)) = qmmmscale
+	    end if
+         end do
+         if (qmmm(ii) .gt. 0) goto 1234
+         do j = 1, n12(ii)
+            mscale(i12(j,ii)) = m2scale
+            pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = 0.0d0
+               pscale(i12(j,ii)) = 0.0d0
+            end if
+         end do
+         do j = 1, n13(ii)
+            mscale(i13(j,ii)) = m3scale
+            pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = 0.0d0
+               pscale(i13(j,ii)) = 0.0d0
+            end if
+         end do
+         do j = 1, n14(ii)
+            mscale(i14(j,ii)) = m4scale
+            pscale(i14(j,ii)) = p4scale
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = 0.0d0
+               pscale(i14(j,ii)) = 0.0d0
+            end if
+            do k = 1, np11(ii)
+                if (i14(j,ii) .eq. ip11(k,ii)) 
+     &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
+            end do
+         end do
+         do j = 1, n15(ii)
+            mscale(i15(j,ii)) = m5scale
+            pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = 0.0d0
+               pscale(i15(j,ii)) = 0.0d0
+            end if
+         end do
+ 1234    continue
+c
+c     decide whether to compute the current interaction
+c
+         do k = 1, npole
+c
+c     Zero out the multipole and polarization energies
+c
+            em = 0.0d0
+            ep = 0.0d0
+c
+c     Get the value of the MM multipole
+c
+            kk = ipole(k)
+            kz = zaxis(k)
+            kx = xaxis(k)
+            kuse = (use(kk) .or. use(kz) .or. use(kx))
+            proceed = .true.
+            if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
+            if (.not. use_intra)  proceed = .true.
+            if (proceed)  proceed = (juse .or. kuse)
+            if (proceed) proceed = (kk .ne. ii) .and. (atinqm(kk).eq.0)
+c
+c     compute the energy contribution for this interaction
+c
+            if (proceed) then
+               xr = x(kk) - x(ii)
+               yr = y(kk) - y(ii)
+               zr = z(kk) - z(ii)
+               call image (xr,yr,zr,0)
+               r2 = xr*xr + yr* yr + zr*zr
+               if (r2 .le. off2) then
+            	  r    = sqrt(r2)
+            	  ck   = rpole(1,k)
+            	  dkx  = rpole(2,k)
+            	  dky  = rpole(3,k)
+            	  dkz  = rpole(4,k)
+            	  qkxx = rpole(5,k)
+            	  qkxy = rpole(6,k)
+            	  qkxz = rpole(7,k)
+            	  qkyy = rpole(9,k)
+            	  qkyz = rpole(10,k)
+            	  qkzz = rpole(13,k)
+            	  ukx  = uind(1,k)
+            	  uky  = uind(2,k)
+            	  ukz  = uind(3,k)
+c
+c     construct some intermediate quadrupole values
+c
+                  qix = qixx*xr + qixy*yr + qixz*zr
+                  qiy = qixy*xr + qiyy*yr + qiyz*zr
+                  qiz = qixz*xr + qiyz*yr + qizz*zr
+                  qkx = qkxx*xr + qkxy*yr + qkxz*zr
+                  qky = qkxy*xr + qkyy*yr + qkyz*zr
+                  qkz = qkxz*xr + qkyz*yr + qkzz*zr
+c
+c     calculate the scalar products for permanent multipoles
+c
+                  sc(2)  = dix*dkx + diy*dky + diz*dkz
+                  sc(3)  = dix*xr + diy*yr + diz*zr
+                  sc(4)  = dkx*xr + dky*yr + dkz*zr
+                  sc(5)  = qix*xr + qiy*yr + qiz*zr
+                  sc(6)  = qkx*xr + qky*yr + qkz*zr
+                  sc(7)  = qix*dkx + qiy*dky + qiz*dkz
+                  sc(8)  = qkx*dix + qky*diy + qkz*diz
+                  sc(9)  = qix*qkx + qiy*qky + qiz*qkz
+                  sc(10) = 2.0d0*(qixy*qkxy+qixz*qkxz+qiyz*qkyz)
+     &            	 + qixx*qkxx + qiyy*qkyy + qizz*qkzz
+c
+c     calculate the scalar products for polarization components
+c
+                  sci(2) = uix*dkx + dix*ukx + uiy*dky
+     &            	 + diy*uky + uiz*dkz + diz*ukz
+                  sci(3) = uix*xr + uiy*yr + uiz*zr
+                  sci(4) = ukx*xr + uky*yr + ukz*zr
+                  sci(7) = qix*ukx + qiy*uky + qiz*ukz
+                  sci(8) = qkx*uix + qky*uiy + qkz*uiz
+c
+c     calculate the gl functions for permanent multipoles
+c
+                  gl(0) = ci*ck
+                  gl(1) = ck*sc(3) - ci*sc(4) + sc(2)
+                  gl(2) = ci*sc(6) + ck*sc(5) - sc(3)*sc(4)
+     &            	+ 2.0d0*(sc(7)-sc(8)+sc(10))
+                  gl(3) = sc(3)*sc(6) - sc(4)*sc(5) - 4.0d0*sc(9)
+                  gl(4) = sc(5)*sc(6)
+c
+c     calculate the gl functions for polarization components
+c
+                  gli(1) = ck*sci(3) - ci*sci(4) + sci(2)
+                  gli(2) = 2.0d0*(sci(7)-sci(8)) - sci(3)*sc(4)
+     &            	 - sc(3)*sci(4)
+                  gli(3) = sci(3)*sc(6) - sci(4)*sc(5)
+c
+c     compute the energy contributions for this interaction
+c
+                  rr1	 = 1.0d0 / r
+                  rr3	 = rr1 / r2
+                  rr5	 = 3.0d0 * rr3 / r2
+                  rr7	 = 5.0d0 * rr5 / r2
+                  rr9	 = 7.0d0 * rr7 / r2
+                  scale3 = 1.0d0
+                  scale5 = 1.0d0
+                  scale7 = 1.0d0
+                  damp   = pdamp(i) * pdamp(k)
+                  if (damp .ne. 0.0d0) then
+                     pgamma = thole(k)
+                     damp = -pgamma * (r/damp)**3
+                     if (damp .gt. -50.0d0) then
+                  	scale3 = 1.0d0 - exp(damp)
+                  	scale5 = 1.0d0 - (1.0d0-damp)*exp(damp)
+                  	scale7 = 1.0d0 - (1.0d0-damp+0.6d0*damp**2)
+     &            		       *exp(damp)
+                     end if
+                  end if
+                  e  = gl(0)*rr1 + gl(1)*rr3 + gl(2)*rr5
+     &               + gl(3)*rr7 + gl(4)*rr9
+                  ei = gli(1)*rr3*scale3 + gli(2)*rr5*scale5
+     &               + gli(3)*rr7*scale7
+c
+c     make the adjustment for scaled interactions
+c
+                  fikm =  f   * mscale(kk)
+                  fikp =  f   * pscale(kk)
+                  e    = fikm * e
+                  ei   = fikp * ei
+c
+c     scale the interaction based on its group membership;
+c     polarization cannot be group scaled as it is not pairwise
+c
+                  if (use_group) then
+                     e  = e  * fgrp
+c                    ei = ei * fgrp
+                  end if
+c
+c     increment the overall multipole and polarization energies
+c
+                  em = em + e
+                  ep = ep + ei
+c
+c     increment the value depending on the interaction
+c
+                  if (ll .eq. 1) elecf     = em + ep + elecf
+                  if (ll .eq. 2) elecg(1)  = em + ep + elecg(1)
+                  if (ll .eq. 3) elecg(2)  = em + ep + elecg(2)
+                  if (ll .eq. 4) elecg(3)  = em + ep + elecg(3)
+                  if (ll .eq. 5) elech(1)  = em + ep + elech(1)
+                  if (ll .eq. 6) elech(2)  = em + ep + elech(2)
+                  if (ll .eq. 7) elech(3)  = em + ep + elech(3)
+                  if (ll .eq. 8) elech(4)  = em + ep + elech(4)
+                  if (ll .eq. 9) elech(5)  = em + ep + elech(5)
+                  if (ll .eq. 10) elech(6) = em + ep + elech(6)
+               end if
+            end if
+         end do
+c
+c     for periodic boundary conditions with large cutoffs
+c     neighbors must be found by the replicates method
+c
+         if (use_replica) then
+            write(*,*) 'Replica NYI'
+            call fatal
+         endif
+      end do 
+      return
+      end
diff -abuN source/elecpot.f source_distrib/elecpot.f
--- source/elecpot.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/elecpot.f	2010-08-26 11:38:22.000000000 +0200
@@ -0,0 +1,294 @@
+c
+c
+c     #######################################################################
+c     ##                                                                   ##
+c     ##  subroutine elecpot  --  electrostatic potential and derivatives  ##
+c     ##                                                                   ##
+c     #######################################################################
+c
+c
+c     "elecpot" computes the electrostatic potential, field and field
+c     derivatives on the i site, due to the MM point charges (no dipoles
+c     yet), in a QM/MM calculation.
+c     WARNING: units are e/A in elecf, e/A^2 in elecg, e/A^3 in elech !!!
+c
+c
+      subroutine elecpot(i,elecf,elecg,elech)
+      implicit none
+      include 'sizes.i'
+      include 'atoms.i'
+      include 'bound.i'
+      include 'cell.i'
+      include 'charge.i'
+      include 'chgpot.i'
+      include 'couple.i'
+      include 'energi.i'
+      include 'group.i'
+      include 'qmmm.i'
+      include 'shunt.i'
+      include 'units.i'
+      integer i,j,k
+      integer in,kk,kn
+      real*8 e,fgrp
+      real*8 de,dedx,dedy,dedz
+      real*8 d2e,d2edx,d2edy,d2edz
+      real*8 f,fik
+      real*8 xi,yi,zi
+      real*8 xr,yr,zr
+      real*8 shift,taper,trans
+      real*8 dtrans,dtaper,d2taper,d2trans
+      real*8 r,r2,r3,r4
+      real*8 r5,r6,r7
+      real*8 cscale(maxatm)
+      real*8 elecf,elecg(3),elech(6)
+      logical proceed
+c
+c     first see if the atom of interest carries a charge
+c
+      in = i
+      do k = 1, nion
+         if (iion(k) .eq. i) then
+            in = jion(k)
+            goto 10
+         end if
+      end do
+   10 continue
+      elecf = 0.0d0
+      do j = 1, 3
+         elecg(j) = 0.0d0
+      end do
+      do j = 1, 6
+         elech(j) = 0.0d0
+      end do
+c
+c     store the coordinates of the atom of interest
+c
+      xi = x(i)
+      yi = y(i)
+      zi = z(i)
+c
+c     set the list of interactions to be scaled
+c     no scale factor if one atom is QM
+c
+      do j = 1, nion
+         cscale(iion(j)) = 1.0d0
+      end do
+      if (qmmm(i).gt.0) goto 20
+      do j = 1, n12(in)
+         cscale(i12(j,in)) = c2scale
+         if (qmmm(i12(j,in)).gt.0) cscale(i12(j,in)) = 1.0d0
+      end do
+      do j = 1, n13(in)
+         cscale(i13(j,in)) = c3scale
+         if (qmmm(i13(j,in)).gt.0) cscale(i13(j,in)) = 1.0d0
+      end do
+      do j = 1, n14(in)
+         cscale(i14(j,in)) = c4scale
+         if (qmmm(i14(j,in)).gt.0) cscale(i14(j,in)) = 1.0d0
+      end do
+      do j = 1, n15(in)
+         cscale(i15(j,in)) = c5scale
+         if (qmmm(i15(j,in)).gt.0) cscale(i15(j,in)) = 1.0d0
+      end do
+   20 continue
+c
+c     set conversion factor and switching function coefficients
+c     f is not electric / dielec since we don't need to convert
+c     the potential
+c
+      f = 1.0d0 / dielec
+      call switch ('CHARGE')
+c
+c     calculate the potential and derivatives terms for i
+c
+      do kk = 1, nion
+         k = iion(kk)
+         kn = jion(kk)
+         proceed = .true.
+         if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
+         if (proceed) proceed = (kn .ne. i) .and. (qmmm(k).eq.0)
+     &                          .and. (atinqm(k).eq.0)
+c
+c     compute the contributions for this interaction
+c
+         if (proceed) then
+            xr = xi - x(k)
+            yr = yi - y(k)
+            zr = zi - z(k)
+            if (use_replica)  call imager (xr,yr,zr,0)
+            r2 = xr*xr + yr*yr + zr*zr
+            if (r2 .le. off2) then
+               r = sqrt(r2)
+               fik = f * pchg(kk) * cscale(kn)
+               e = fik / r
+               de = -fik / r2
+               d2e = -2.0d0 * de/r
+c
+c     use shifted energy switching if near the cutoff distance
+c
+               shift = fik / (0.5d0*(off+cut))
+               e = e - shift
+               if (r2 .gt. cut2) then
+                  r3 = r2 * r
+                  r4 = r2 * r2
+                  r5 = r2 * r3
+                  r6 = r3 * r3
+                  r7 = r3 * r4
+                  taper = c5*r5 + c4*r4 + c3*r3
+     &                       + c2*r2 + c1*r + c0
+                  dtaper = 5.0d0*c5*r4 + 4.0d0*c4*r3
+     &                        + 3.0d0*c3*r2 + 2.0d0*c2*r + c1
+                  d2taper = 20.0d0*c5*r3 + 12.0d0*c4*r2
+     &                        + 6.0d0*c3*r + 2.0d0*c2
+                  trans = fik * (f7*r7 + f6*r6 + f5*r5 + f4*r4
+     &                            + f3*r3 + f2*r2 + f1*r + f0)
+                  dtrans = fik * (7.0d0*f7*r6 + 6.0d0*f6*r5
+     &                            + 5.0d0*f5*r4 + 4.0d0*f4*r3
+     &                          + 3.0d0*f3*r2 + 2.0d0*f2*r + f1)
+                  d2trans = fik * (42.0d0*f7*r5 + 30.0d0*f6*r4
+     &                          + 20.0d0*f5*r3 + 12.0d0*f4*r2
+     &                          + 6.0d0*f3*r + 2.0d0*f2)
+                  d2e = e*d2taper + 2.0d0*de*dtaper
+     &                  + d2e*taper + d2trans
+                  de = de*taper + e*dtaper + dtrans
+                  e = e*taper + trans
+               end if
+c
+c     scale the interaction based on its group membership
+c
+               if (use_group) then
+                  e = e * fgrp
+                  de = de * fgrp
+                  d2e = d2e * fgrp
+               end if
+c
+c     form the chain rule terms for derivative expressions
+c
+               de = de / r
+               dedx = de * xr
+               dedy = de * yr
+               dedz = de * zr
+               d2e = (d2e-de) / r2
+               d2edx = d2e * xr
+               d2edy = d2e * yr
+               d2edz = d2e * zr
+c
+c     increment the components
+c
+               elecf = elecf + e
+               elecg(1) = elecg(1) + dedx
+               elecg(2) = elecg(2) + dedy
+               elecg(3) = elecg(3) + dedz
+               elech(1) = elech(1) + d2edx*xr + de
+               elech(2) = elech(2) + d2edy*yr + de
+               elech(3) = elech(3) + d2edz*zr + de
+               elech(4) = elech(4) + d2edx*yr
+               elech(5) = elech(5) + d2edx*zr
+               elech(6) = elech(6) + d2edy*zr
+            end if
+         end if
+      end do
+c
+c     for periodic boundary conditions with large cutoffs
+c     neighbors must be found by the replicates method
+c
+      if (.not. use_replica)  return
+c
+c     calculate interaction energy with other unit cells
+c
+      do kk = 1, nion
+         k = iion(kk)
+         kn = jion(kk)
+         proceed = .true.
+         if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
+c
+c     no conditional proceed with other cells, even a QM atom should
+c     carry a point charge:
+c         if (proceed) proceed = (qmmm(k).eq.0) .and. (atinqm(k).eq.0)
+c
+c     compute the energy contribution for this interaction
+c
+         if (proceed) then
+            do j = 1, ncell
+               xr = xi - x(k)
+               yr = yi - y(k)
+               zr = zi - z(k)
+               call imager (xr,yr,zr,j)
+               r2 = xr*xr + yr*yr + zr*zr
+               if (r2 .le. off2) then
+                  r = sqrt(r2)
+                  fik = f * pchg(kk) 
+                  if (use_polymer) then
+                     if (r2 .le. polycut2) fik = fik * cscale(k)
+                  end if
+                  e = fik / r
+                  de = -fik / r2
+                  d2e = -2.0d0 * de/r
+c
+c     use shifted energy switching if near the cutoff distance
+c
+                 shift = fik / (0.5d0*(off+cut))
+                 e = e - shift
+                 if (r2 .gt. cut2) then
+                     r3 = r2 * r
+                     r4 = r2 * r2
+                     r5 = r2 * r3
+                     r6 = r3 * r3
+                     r7 = r3 * r4
+                     taper = c5*r5 + c4*r4 + c3*r3
+     &                          + c2*r2 + c1*r + c0
+                     dtaper = 5.0d0*c5*r4 + 4.0d0*c4*r3
+     &                        + 3.0d0*c3*r2 + 2.0d0*c2*r + c1
+                     d2taper = 20.0d0*c5*r3 + 12.0d0*c4*r2
+     &                        + 6.0d0*c3*r + 2.0d0*c2
+                     trans = fik * (f7*r7 + f6*r6 + f5*r5 + f4*r4
+     &                               + f3*r3 + f2*r2 + f1*r + f0)
+                     dtrans = fik * (7.0d0*f7*r6 + 6.0d0*f6*r5
+     &                            + 5.0d0*f5*r4 + 4.0d0*f4*r3
+     &                          + 3.0d0*f3*r2 + 2.0d0*f2*r + f1)
+                     d2trans = fik * (42.0d0*f7*r5 + 30.0d0*f6*r4
+     &                          + 20.0d0*f5*r3 + 12.0d0*f4*r2
+     &                          + 6.0d0*f3*r + 2.0d0*f2)
+                     d2e = e*d2taper + 2.0d0*de*dtaper
+     &                  + d2e*taper + d2trans
+                     de = de*taper + e*dtaper + dtrans
+                     e = e * taper + trans
+                  end if
+c
+c     scale the interaction based on its group membership
+c
+                 if (use_group) then
+                    e = e * fgrp
+                    de = de * fgrp
+                    d2e = d2e * fgrp
+                 end if
+c
+c     form the chain rule terms for derivative expressions
+c
+                  de = de / r
+                  dedx = de * xr
+                  dedy = de * yr
+                  dedz = de * zr
+                  d2e = (d2e-de) / r2
+                  d2edx = d2e * xr
+                  d2edy = d2e * yr
+                  d2edz = d2e * zr
+c
+c     increment the components
+c
+                  elecf = elecf + e
+                  elecg(1) = elecg(1) + dedx
+                  elecg(2) = elecg(2) + dedy
+                  elecg(3) = elecg(3) + dedz
+                  elech(1) = elech(1) + d2edx*xr + de
+                  elech(2) = elech(2) + d2edy*yr + de
+                  elech(3) = elech(3) + d2edz*zr + de
+                  elech(4) = elech(4) + d2edx*yr
+                  elech(5) = elech(5) + d2edx*zr
+                  elech(6) = elech(6) + d2edy*zr
+               end if
+            end do
+         end if
+      end do
+      return
+      end
diff -abuN source/elj1.f source_distrib/elj1.f
--- source/elj1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/elj1.f	2010-08-26 11:38:22.000000000 +0200
@@ -83,6 +83,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -174,6 +177,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -513,6 +520,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -649,6 +659,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -830,6 +844,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -921,6 +938,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0.or.qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -1111,6 +1132,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm 
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer iv,kv,it,kt
       integer iv14(maxatm)
@@ -1211,6 +1235,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/elj2.f source_distrib/elj2.f
--- source/elj2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/elj2.f	2010-08-26 11:38:25.000000000 +0200
@@ -63,6 +63,9 @@
       include 'shunt.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -169,6 +172,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (k .ne. i)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the Hessian elements for this interaction
 c
@@ -664,6 +671,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,iatom
       integer ii,iv,it
       integer kk,kv,kt
@@ -781,6 +791,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (k .ne. i)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the Hessian elements for this interaction
 c
diff -abuN source/elj3.f source_distrib/elj3.f
--- source/elj3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/elj3.f	2010-08-26 11:38:23.000000000 +0200
@@ -95,6 +95,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -180,6 +183,10 @@
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
             if (proceed)  proceed = (vscale(k) .ne. 0.0d0)
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -456,6 +463,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -585,6 +595,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -743,6 +757,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -827,6 +844,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3 .or. qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -988,6 +1009,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -1080,6 +1104,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/elj.f source_distrib/elj.f
--- source/elj.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/elj.f	2010-08-26 11:38:25.000000000 +0200
@@ -17,12 +17,13 @@
 c
       subroutine elj
       implicit none
-      real*8 elrc
       include 'sizes.i'
       include 'cutoff.i'
+      include 'warp.i'
+c 5.1.06
+      real*8 elrc
       include 'energi.i'
       include 'vdwpot.i'
-      include 'warp.i'
 c
 c
 c     choose the method for summing over pairwise interactions
@@ -38,6 +39,7 @@
       else
          call elj0a
       end if
+c 5.1.06
 c
 c     apply long range van der Waals correction if desired
 c
@@ -74,6 +76,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -152,6 +157,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -358,6 +367,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -481,6 +493,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -594,6 +610,9 @@
       include 'usage.i'
       include 'vdw.i'
       include 'vdwpot.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,iv,it
       integer kk,kv,kt
@@ -672,6 +691,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
@@ -794,6 +817,9 @@
       include 'vdw.i'
       include 'vdwpot.i'
       include 'warp.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ii,kk
       integer iv,kv,it,kt
       integer iv14(maxatm)
@@ -879,6 +905,10 @@
             proceed = .true.
             if (use_group)  call groups (proceed,fgrp,i,k,0,0,0,0)
             if (proceed)  proceed = (usei .or. use(k) .or. use(kv))
+cqmmm vdw if only one or none of the two atoms are QM
+            if (proceed)  proceed = (qmmm(i).eq.0 .or. qmmm(k).eq.0)
+     &        .or.(qmmm(i).eq.3.or.qmmm(k).eq.3)
+            if (proceed)  proceed = (qmmm(i).ne.1 .and. qmmm(k).ne.1)
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/empole1.f source_distrib/empole1.f
--- source/empole1.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/empole1.f	2010-08-26 11:38:25.000000000 +0200
@@ -102,6 +102,9 @@
       include 'shunt.i'
       include 'usage.i'
       include 'virial.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk,jcell
       integer ix,iz,kx,kz
@@ -229,17 +232,42 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, n
+            mscale(j) = 1.0d0
+            dscale(j) = 1.0d0
+            uscale(j) = 1.0d0
+            pscale(j) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(j) = qmmmscale
+               dscale(j) = qmmmscale
+               uscale(j) = qmmmscale
+               pscale(j) = qmmmscale
+	    end if
+         end do
+         if (qmmm(ii) .ne. 0) goto 1234
          do j = 1, n12(ii)
             mscale(i12(j,ii)) = m2scale
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = qmmmscale
+               pscale(i12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n13(ii)
             mscale(i13(j,ii)) = m3scale
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = qmmmscale
+               pscale(i13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n14(ii)
             mscale(i14(j,ii)) = m4scale
             pscale(i14(j,ii)) = p4scale
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = qmmmscale
+               pscale(i14(j,ii)) = qmmmscale
+            end if
             do k = 1, np11(ii)
                 if (i14(j,ii) .eq. ip11(k,ii))
      &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
@@ -248,23 +276,44 @@
          do j = 1, n15(ii)
             mscale(i15(j,ii)) = m5scale
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = qmmmscale
+               pscale(i15(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np11(ii)
             dscale(ip11(j,ii)) = d1scale
             uscale(ip11(j,ii)) = u1scale
+            if (qmmm(ip11(j,ii)).ne.0) then
+               dscale(ip11(j,ii)) = qmmmscale
+               uscale(ip11(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np12(ii)
             dscale(ip12(j,ii)) = d2scale
             uscale(ip12(j,ii)) = u2scale
+            if (qmmm(ip12(j,ii)).ne.0) then
+               dscale(ip12(j,ii)) = qmmmscale
+               uscale(ip12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np13(ii)
             dscale(ip13(j,ii)) = d3scale
             uscale(ip13(j,ii)) = u3scale
+            if (qmmm(ip13(j,ii)).ne.0) then
+               dscale(ip13(j,ii)) = qmmmscale
+               uscale(ip13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np14(ii)
             dscale(ip14(j,ii)) = d4scale
             uscale(ip14(j,ii)) = u4scale
+            if (qmmm(ip14(j,ii)).ne.0) then
+               dscale(ip14(j,ii)) = qmmmscale
+               uscale(ip14(j,ii)) = qmmmscale
+            end if
          end do
+ 1234    continue
          do k = i+1, npole
             kk = ipole(k)
             kz = zaxis(k)
@@ -274,6 +323,16 @@
             if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
             if (.not. use_intra)  proceed = .true.
             if (proceed)  proceed = (usei .or. usek)
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(ii),3)+mod(qmmm(kk),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &        proceed = (mod(qmmm(ii),3).eq.0 .or. mod(qmmm(kk),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(ii).eq.0 .and. atinqm(kk).ne.0) .or.
+     &            (atinqm(ii).ne.0 .and. atinqm(kk).eq.0)))
+     &         proceed = .false.
             if (.not. proceed)  goto 10
             xr = x(kk) - x(ii)
             yr = y(kk) - y(ii)
diff -abuN source/empole2.f source_distrib/empole2.f
--- source/empole2.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/empole2.f	2010-08-26 11:38:24.000000000 +0200
@@ -186,6 +186,9 @@
       include 'potent.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,nlist
       integer ii,iii,kk
       integer ix,iz,kx,kz
@@ -307,13 +310,32 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, n
+            mscale(j) = 1.0d0
+            pscale(j) = 1.0d0
+            uscale(j) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(j) = qmmmscale
+               uscale(j) = qmmmscale
+               pscale(j) = qmmmscale
+	    end if
+         end do
+         if (qmmm(ii) .ne. 0) goto 1234
          do j = 1, n12(ii)
             mscale(i12(j,ii)) = m2scale
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = qmmmscale
+               pscale(i12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n13(ii)
             mscale(i13(j,ii)) = m3scale
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = qmmmscale
+               pscale(i13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n14(ii)
             mscale(i14(j,ii)) = m4scale
@@ -322,27 +344,48 @@
                 if (i14(j,ii) .eq. ip11(k,ii))
      &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
             end do
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = qmmmscale
+               pscale(i14(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n15(ii)
             mscale(i15(j,ii)) = m5scale
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = qmmmscale
+               pscale(i15(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np11(ii)
             dscale(ip11(j,ii)) = d1scale
             uscale(ip11(j,ii)) = u1scale
+            if (qmmm(ip11(j,ii)).ne.0) then
+               uscale(ip11(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np12(ii)
             dscale(ip12(j,ii)) = d2scale
             uscale(ip12(j,ii)) = u2scale
+            if (qmmm(ip12(j,ii)).ne.0) then
+               uscale(ip12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np13(ii)
             dscale(ip13(j,ii)) = d3scale
             uscale(ip13(j,ii)) = u3scale
+            if (qmmm(ip13(j,ii)).ne.0) then
+               uscale(ip13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, np14(ii)
             dscale(ip14(j,ii)) = d4scale
             uscale(ip14(j,ii)) = u4scale
+            if (qmmm(ip14(j,ii)).ne.0) then
+               uscale(ip14(j,ii)) = qmmmscale
+            end if
          end do
+ 1234    continue
          do k = i+1, npole
             kk = ipole(k)
             kz = zaxis(k)
@@ -352,6 +395,16 @@
             if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
             if (.not. use_intra)  proceed = .true.
             if (proceed)  proceed = (usei .or. usek)
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(ii),3)+mod(qmmm(kk),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &        proceed = (mod(qmmm(ii),3).eq.0 .or. mod(qmmm(kk),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(ii).eq.0 .and. atinqm(kk).ne.0) .or.
+     &            (atinqm(ii).ne.0 .and. atinqm(kk).eq.0)))
+     &         proceed = .false.
             if (.not. proceed)  goto 10
             xr = x(kk) - x(ii)
             yr = y(kk) - y(ii)
diff -abuN source/empole3.f source_distrib/empole3.f
--- source/empole3.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/empole3.f	2010-08-26 11:38:22.000000000 +0200
@@ -103,6 +103,9 @@
       include 'potent.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer ix,iz
@@ -198,13 +201,30 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = i+1, npole
+            mscale(ipole(j)) = 1.0d0
+            pscale(ipole(j)) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(ipole(j)) = qmmmscale
+               pscale(ipole(j)) = qmmmscale
+            end if
+         end do
+         if (qmmm(ii) .ne. 0) goto 1234
          do j = 1, n12(ii)
             mscale(i12(j,ii)) = m2scale
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = qmmmscale
+               pscale(i12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n13(ii)
             mscale(i13(j,ii)) = m3scale
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = qmmmscale
+               pscale(i13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n14(ii)
             mscale(i14(j,ii)) = m4scale
@@ -213,11 +233,19 @@
                 if (i14(j,ii) .eq. ip11(k,ii))
      &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
             end do
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = qmmmscale
+               pscale(i14(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n15(ii)
             mscale(i15(j,ii)) = m5scale
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = qmmmscale
+            end if
          end do
+ 1234    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -230,6 +258,16 @@
             if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
             if (.not. use_intra)  proceed = .true.
             if (proceed)  proceed = (usei .or. usek)
+cqmmm Exclude some QM/MM interactions
+            if (proceed .and. e4qmmm.eq.0)
+     &         proceed = ((mod(qmmm(ii),3)+mod(qmmm(kk),3)).eq.0)
+            if (proceed .and. e4qmmm.eq.3)
+     &        proceed = (mod(qmmm(ii),3).eq.0 .or. mod(qmmm(kk),3).eq.0)
+cqmmm Exclude some MM/MM interactions when ESPF is set on
+            if (doespf .and.
+     &           ((atinqm(ii).eq.0 .and. atinqm(kk).ne.0) .or.
+     &            (atinqm(ii).ne.0 .and. atinqm(kk).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -436,22 +474,52 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = i+1, npole
+            mscale(ipole(j)) = 1.0d0
+            pscale(ipole(j)) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(ipole(j)) = qmmmscale
+               pscale(ipole(j)) = qmmmscale
+            end if
+         end do
+         if (qmmm(ii) .ne. 0) goto 2345
          do j = 1, n12(ii)
             mscale(i12(j,ii)) = m2scale
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = qmmmscale
+               pscale(i12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n13(ii)
             mscale(i13(j,ii)) = m3scale
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = qmmmscale
+               pscale(i13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n14(ii)
             mscale(i14(j,ii)) = m4scale
             pscale(i14(j,ii)) = p4scale
+            do k = 1, np11(ii)
+                if (i14(j,ii) .eq. ip11(k,ii))
+     &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
+            end do
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = qmmmscale
+               pscale(i14(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n15(ii)
             mscale(i15(j,ii)) = m5scale
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = qmmmscale
+               pscale(i15(j,ii)) = qmmmscale
+            end if
          end do
+ 2345    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -463,6 +531,11 @@
             if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. usek)
+cqmmm 
+            if (doespf .and.
+     &           ((atinqm(ii).eq.0 .and. atinqm(kk).ne.0) .or.
+     &            (atinqm(ii).ne.0 .and. atinqm(kk).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -1640,6 +1713,7 @@
                   if (use_polymer .and. r2.le.polycut2)
      &               e = e - efix*(1.0d0-mscale(kk))
                   ei = ei - eifix
+
 c
 c     increment the overall multipole and polarization energies
 c
diff -abuN source/empole.f source_distrib/empole.f
--- source/empole.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/empole.f	2010-08-26 11:38:24.000000000 +0200
@@ -77,6 +77,9 @@
       include 'polpot.i'
       include 'shunt.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer ii,kk
       integer ix,iz
@@ -162,13 +165,30 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = i+1, npole
+            mscale(ipole(j)) = 1.0d0
+            pscale(ipole(j)) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(ipole(j)) = qmmmscale
+               pscale(ipole(j)) = qmmmscale
+            end if
+         end do
+         if (qmmm(ii) .ne. 0) goto 1234
          do j = 1, n12(ii)
             mscale(i12(j,ii)) = m2scale
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = qmmmscale
+               pscale(i12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n13(ii)
             mscale(i13(j,ii)) = m3scale
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = qmmmscale
+               pscale(i13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n14(ii)
             mscale(i14(j,ii)) = m4scale
@@ -177,11 +197,20 @@
                 if (i14(j,ii) .eq. ip11(k,ii))
      &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
             end do
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = qmmmscale
+               pscale(i14(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n15(ii)
             mscale(i15(j,ii)) = m5scale
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = qmmmscale
+               pscale(i15(j,ii)) = qmmmscale
+            end if
          end do
+ 1234    continue
 c
 c     decide whether to compute the current interaction
 c
@@ -194,6 +223,11 @@
             if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
             if (.not. use_intra)  proceed = .true.
             if (proceed)  proceed = (usei .or. usek)
+cqmmm
+            if (doespf .and.
+     &           ((atinqm(ii).eq.0 .and. atinqm(kk).ne.0) .or.
+     &            (atinqm(ii).ne.0 .and. atinqm(kk).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
@@ -366,22 +400,53 @@
 c
 c     set interaction scaling coefficients for connected atoms
 c
+         do j = 1, npole
+            mscale(ipole(j)) = 1.0d0
+            pscale(ipole(j)) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               mscale(ipole(j)) = qmmmscale
+               pscale(ipole(j)) = qmmmscale
+            end if
+         end do
+         if (qmmm(ii) .ne. 0) goto 2345
          do j = 1, n12(ii)
             mscale(i12(j,ii)) = m2scale
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).ne.0) then
+               mscale(i12(j,ii)) = qmmmscale
+               pscale(i12(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n13(ii)
             mscale(i13(j,ii)) = m3scale
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).ne.0) then
+               mscale(i13(j,ii)) = qmmmscale
+               pscale(i13(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n14(ii)
             mscale(i14(j,ii)) = m4scale
             pscale(i14(j,ii)) = p4scale
+            do k = 1, np11(ii)
+                if (i14(j,ii) .eq. ip11(k,ii))
+     &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
+            end do
+            if (qmmm(i14(j,ii)).ne.0) then
+               mscale(i14(j,ii)) = qmmmscale
+               pscale(i14(j,ii)) = qmmmscale
+            end if
          end do
          do j = 1, n15(ii)
             mscale(i15(j,ii)) = m5scale
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).ne.0) then
+               mscale(i15(j,ii)) = qmmmscale
+               pscale(i15(j,ii)) = qmmmscale
+            end if
          end do
+ 2345    continue
+
 c
 c     decide whether to compute the current interaction
 c
@@ -393,6 +458,11 @@
             if (use_group)  call groups (proceed,fgrp,ii,kk,0,0,0,0)
             proceed = .true.
             if (proceed)  proceed = (usei .or. usek)
+cqmmm
+            if (doespf .and.
+     &           ((atinqm(ii).eq.0 .and. atinqm(kk).ne.0) .or.
+     &            (atinqm(ii).ne.0 .and. atinqm(kk).eq.0)))
+     &         proceed = .false.
 c
 c     compute the energy contribution for this interaction
 c
diff -abuN source/gradient.f source_distrib/gradient.f
--- source/gradient.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/gradient.f	2010-08-26 11:38:23.000000000 +0200
@@ -32,6 +32,47 @@
       integer i,j
       real*8 energy,cutoff
       real*8 derivs(3,maxatm)
+cqmmm
+      include 'qmmm.i'
+      include 'couple.i'
+      include 'inform.i'
+      include 'iounit.i'
+      integer imm,iqm,ilah
+      real*8 OMG,r1,r2
+      if (doqmmmdyn .and. (use_chgdpl .or. use_dipole)) then
+         write(iout,'(A)') 'DYNAQMMM: only charge-charge electrostatics'
+         call fatal
+      end if
+      if (nbinqm.ne.0 .and. use_ewald) then
+         write(iout,'(A)') 'DYNAQMMM: Ewald sums NYI'
+         call fatal
+      end if
+c
+cqmmm define the new position of the link atoms
+c
+      if (doqmmmdyn) then
+         ilah = 0
+         do i = 1, n
+            if (qmmm(i) .eq. 1) then
+               ilah = ilah + 1
+               imm = i12(1,i)
+               iqm = i12(2,i)
+               if (lahg(ilah) .gt. 0.0d0) then
+                  x(i) = x(iqm) + lahg(ilah) * (x(imm)-x(iqm))
+                  y(i) = y(iqm) + lahg(ilah) * (y(imm)-y(iqm))
+                  z(i) = z(iqm) + lahg(ilah) * (z(imm)-z(iqm))
+               else
+                  r1 = sqrt((x(i)-x(iqm))**2 + (y(i)-y(iqm))**2
+     &              + (z(i)-z(iqm))**2)
+                  r2 = sqrt((x(imm)-x(iqm))**2 + (y(imm)-y(iqm))**2
+     &              + (z(imm)-z(iqm))**2)
+                  lahg(ilah) = r1 / r2
+                  write(iout,10) i,lahg(ilah)
+10                format(' GRADIENT -- LAH ',i5,' scaling factor:',F7.3)
+               end if
+            end if
+         end do
+      end if
 c
 c
 c     zero out each of the potential energy components
@@ -122,6 +163,13 @@
 c
       if (use_orbit)  call piscf
 c
+cqmmm if this is a QM/MM job which driver is Tinker, run the QM code
+cqmmm and get back the energy and forces in ex/dex
+cqmmm more important, get back the ESPF multipoles used to compute the
+cqmmm electrostatic component of the MM gradient
+c
+      if (doqmmmdyn) call runqm
+c
 c     call the local geometry energy and gradient routines
 c
       if (use_bond)  call ebond1
@@ -150,18 +198,21 @@
 c
 c     call the electrostatic energy and gradient routines
 c
+      if (doqmmmdyn) e4qmmm = 3
       if (use_charge)  call echarge1
       if (use_chgdpl)  call echgdpl1
       if (use_dipole)  call edipole1
       if (use_mpole .or. use_polar)  call empole1
       if (use_rxnfld)  call erxnfld1
+      if (doqmmmdyn) e4qmmm = 0
 c
 c     call any miscellaneous energy and gradient routines
 c
       if (use_solv)  call esolv1
       if (use_metal)  call emetal1
       if (use_geom)  call egeom1
-      if (use_extra)  call extra1
+cqmmm      if (use_extra)  call extra1
+      if (use_extra .and. .not.doqmmmdyn)  call extra1
 c
 c     sum up to get the total energy and first derivatives
 c
@@ -182,5 +233,29 @@
             derivs(j,i) = desum(j,i)
          end do
       end do
+c
+cqmmm
+c     apply the Jacobian to project out the forces
+c     acting on the link atoms
+cqmmm
+c
+      if (doqmmmdyn) then
+         ilah = 0
+         do i = 1, n
+c            if (debug) write (iout,'(i5,3f12.5)') i,(derivs(j,i),j=1,3)
+            if (qmmm(i) .eq. 1) then
+               ilah = ilah + 1
+               imm = i12(1,i)
+               iqm = i12(2,i)
+               OMG = (1.0d0-lahg(ilah))
+               do j = 1, 3
+                 derivs(j,iqm) = derivs(j,iqm) + desum(j,i) * OMG
+                 derivs(j,imm) = derivs(j,imm) + desum(j,i) * lahg(ilah)
+                 derivs(j,i) = 0.0d0
+               end do
+            end if
+         end do
+      end if
+c
       return
       end
diff -abuN source/hess4qm.f source_distrib/hess4qm.f
--- source/hess4qm.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/hess4qm.f	2010-08-26 11:38:24.000000000 +0200
@@ -0,0 +1,255 @@
+c
+c     #############################################################
+c     ##                                                         ##
+c     ##  subroutine hess4qm  --  atom-by-atom Hessian elements  ##
+c     ##                                                         ##
+c     #############################################################
+c
+c
+c     "hess4qm" calls subroutines to calculate the Hessian elements
+c     for each atom in turn with respect to Cartesian coordinates
+c     it is a hack of the original hessian subroutine
+c
+c
+      subroutine hess4qm (h,hinit,hstop,hindex,hdiag)
+      implicit none
+      include 'sizes.i'
+      include 'atoms.i'
+      include 'bound.i'
+      include 'couple.i'
+      include 'hescut.i'
+      include 'hessn.i'
+      include 'inform.i'
+      include 'iounit.i'
+      include 'mpole.i'
+      include 'potent.i'
+      include 'rigid.i'
+      include 'usage.i'
+      include 'vdw.i'
+      include 'vdwpot.i'
+      include 'qmmm.i'
+      integer i,j,k,kk
+      integer ii,nhess
+      integer hinit(3,maxatm)
+      integer hstop(3,maxatm)
+      integer hindex(maxhess)
+      real*8 percent,filled
+      real*8 cutoff,rdn,hmax
+      real*8 xred(maxatm)
+      real*8 yred(maxatm)
+      real*8 zred(maxatm)
+      real*8 hdiag(3,maxatm)
+      real*8 h(maxhess)
+      logical keep(maxatm)
+c
+c
+c     zero out total number of indexed Hessian elements
+c
+      nhess = 0
+      do i = 1, n
+         do j = 1, 3
+            hinit(j,i) = 1
+            hstop(j,i) = 0
+            hdiag(j,i) = 0.0d0
+         end do
+      end do
+c
+c     maintain any periodic boundary conditions
+c
+      if (use_bounds .and. .not.use_rigid)  call bounds
+c
+c     alter bond and torsion constants for pisystem
+c
+      if (use_orbit)  call piscf
+c
+c     set the Born radii for use with GB/SA solvation
+c
+      if (use_born)  call born
+c
+c     compute the induced dipoles at polarizable atoms
+c
+      if (use_polar) then
+         call chkpole
+         call rotpole
+         call induce
+      end if
+c
+c     calculate the "reduced" atomic coordinates
+c
+      if (use_vdw) then
+         do i = 1, n
+            ii = ired(i)
+            rdn = kred(i)
+            xred(i) = rdn*(x(i)-x(ii)) + x(ii)
+            yred(i) = rdn*(y(i)-y(ii)) + y(ii)
+            zred(i) = rdn*(z(i)-z(ii)) + z(ii)
+         end do
+      end if
+c
+c     zero out the Hessian elements for the current atom
+c
+      do i = 1, n
+         do k = 1, n
+            do j = 1, 3
+               hessx(j,k) = 0.0d0
+               hessy(j,k) = 0.0d0
+               hessz(j,k) = 0.0d0
+            end do
+         end do
+c
+c     remove any previous use of the replicates method
+c
+         cutoff = 0.0d0
+         if (use_replica)  call replica (cutoff)
+c
+c     call the local geometry Hessian component routines
+c
+         if (use_bond)  call ebond2 (i)
+         if (use_angle)  call eangle2 (i)
+         if (use_strbnd)  call estrbnd2 (i)
+         if (use_urey)  call eurey2 (i)
+         if (use_angang)  call eangang2 (i)
+         if (use_opbend)  call eopbend2 (i)
+         if (use_opdist)  call eopdist2 (i)
+         if (use_improp)  call eimprop2 (i)
+         if (use_imptor)  call eimptor2 (i)
+         if (use_tors)  call etors2 (i)
+         if (use_pitors)  call epitors2 (i)
+         if (use_strtor)  call estrtor2 (i)
+         if (use_tortor)  call etortor2 (i)
+c
+c     call the van der Waals Hessian component routines
+c
+         if (use_vdw) then
+            if (vdwtyp .eq. 'LENNARD-JONES') then
+               call elj2 (i,xred,yred,zred)
+            else if (vdwtyp .eq. 'BUCKINGHAM') then
+               call ebuck2 (i,xred,yred,zred)
+            else if (vdwtyp .eq. 'MM3-HBOND') then
+               call emm3hb2 (i,xred,yred,zred)
+            else if (vdwtyp .eq. 'BUFFERED-14-7') then
+               call ehal2 (i,xred,yred,zred)
+            else if (vdwtyp .eq. 'GAUSSIAN') then
+               call egauss2 (i,xred,yred,zred)
+            end if
+         end if
+c
+c     call the electrostatic Hessian component routines
+c
+         if (use_charge) call echarge2 (i)
+         if (use_chgdpl)  call echgdpl2 (i)
+         if (use_dipole)  call edipole2 (i)
+         if (use_mpole .or. use_polar)   call empole2 (i)
+         if (use_rxnfld)   call erxnfld2 (i)
+c
+c     call any miscellaneous Hessian component routines
+c
+         if (use_solv)  call esolv2 (i)
+         if (use_metal)  call emetal2 (i)
+         if (use_geom)  call egeom2 (i)
+         if (use_extra)  call extra2 (i)
+c
+c     set the diagonal Hessian matrix elements
+c
+         hdiag(1,i) = hdiag(1,i) + hessx(1,i)
+         hdiag(2,i) = hdiag(2,i) + hessy(2,i)
+         hdiag(3,i) = hdiag(3,i) + hessz(3,i)
+c
+c     search each 3x3 block to see which blocks will be kept
+c
+         do kk = ii+1, nbinqm
+            k = 0
+    2       k = k + 1
+            if (atinqm(k) .ne. kk) goto 2
+            keep(kk) = .false.
+            if (use(k)) then
+               hmax = max(abs(hessx(1,k)),abs(hessx(2,k)),
+     &   		  abs(hessx(3,k)),abs(hessy(1,k)),
+     &   		  abs(hessy(2,k)),abs(hessy(3,k)),
+     &   		  abs(hessz(1,k)),abs(hessz(2,k)),
+     &   		  abs(hessz(3,k)))
+               if (hmax .ge. hesscut)  keep(kk) = .true.
+            end if
+         end do
+c
+c     copy selected off-diagonal Hessian elements for current
+c     atom into an indexed master list of Hessian elements;
+c     if any elements of 3x3 block are kept, keep them all
+c
+         hinit(1,ii) = nhess + 1
+         do j = 2, 3
+            nhess = nhess + 1
+            hindex(nhess) = 3*ii + j - 3
+            h(nhess) = hessx(j,i)
+         end do
+         do kk = ii+1, nbinqm
+            if (keep(kk)) then
+               k = 0
+    3          k = k + 1
+               if (atinqm(k) .ne. kk) goto 3
+               do j = 1, 3
+                  nhess = nhess + 1
+                  hindex(nhess) = 3*kk + j - 3
+                  h(nhess) = hessx(j,k)
+               end do
+            end if
+         end do
+         hstop(1,ii) = nhess
+         hinit(2,ii) = nhess + 1
+         nhess = nhess + 1
+         hindex(nhess) = 3*ii
+         h(nhess) = hessy(3,i)
+         do kk = ii+1, nbinqm
+            if (keep(kk)) then
+               k = 0
+    4          k = k + 1
+               if (atinqm(k) .ne. kk) goto 4
+               do j = 1, 3
+                  nhess = nhess + 1
+                  hindex(nhess) = 3*kk + j - 3
+                  h(nhess) = hessy(j,k)
+               end do
+            end if
+         end do
+         hstop(2,ii) = nhess
+         hinit(3,ii) = nhess + 1
+         do kk = ii+1, nbinqm
+            if (keep(kk)) then
+               k = 0
+    5          k = k + 1
+               if (atinqm(k) .ne. kk) goto 5
+               do j = 1, 3
+                  nhess = nhess + 1
+                  hindex(nhess) = 3*kk + j - 3
+                  h(nhess) = hessz(j,k)
+               end do
+            end if
+         end do
+         hstop(3,ii) = nhess
+c
+c     check for storage of too many Hessian elements
+c
+         if (nhess .gt. maxhess) then
+            write (iout,10)  ii,n,nhess,maxhess,hesscut
+   10       format (/,' Current Atom :',i7,6x,'Total Atoms :',i7,
+     &   	    /,' Current Required Hessian Storage : ',i12,
+     &   	    /,' Maximum Allowed Hessian Storage :  ',i12,
+     &   	    /,' Minimum Significant Hessian Value :',f12.5)
+            write (iout,20)
+   20       format (/,' HESSIAN  --  Increase MAXHESS',
+     &   	       ' and/or HESSCUT')
+            call fatal
+         end if
+      end do
+c
+c     print message telling how much storage was finally used
+c
+      if (verbose) then
+         percent = 100.0d0 * dble(nhess)/dble(3*n*(3*n-1)/2)
+         filled = 100.0d0 * dble(nhess)/dble(maxhess)
+         write (iout,30)  nhess,percent,filled
+   30    format (' HESS4QM  --',i11,' Elements',f9.2,
+     &              ' % Off-diag H',f8.2,' % Storage')
+      end if
+      return
+      end
diff -abuN source/induce.f source_distrib/induce.f
--- source/induce.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/induce.f	2010-08-26 11:38:26.000000000 +0200
@@ -174,6 +174,9 @@
       include 'potent.i'
       include 'shunt.i'
       include 'units.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
       integer ii,kk
       integer iter,maxiter
@@ -248,15 +251,23 @@
          do j = i+1, npole
             dscale(ipole(j)) = 1.0d0
             pscale(ipole(j)) = 1.0d0
+            if (qmmm(ii).gt.0) then
+               dscale(ipole(j)) = qmmmscale
+               pscale(ipole(j)) = qmmmscale
+            end if
          end do
+         if (qmmm(ii) .ne. 0) goto 1234
          do j = 1, n12(ii)
             pscale(i12(j,ii)) = p2scale
+            if (qmmm(i12(j,ii)).gt.0) pscale(i12(j,ii)) = qmmmscale
          end do
          do j = 1, n13(ii)
             pscale(i13(j,ii)) = p3scale
+            if (qmmm(i13(j,ii)).gt.0) pscale(i13(j,ii)) = qmmmscale
          end do
          do j = 1, n14(ii)
             pscale(i14(j,ii)) = p4scale
+            if (qmmm(i14(j,ii)).gt.0) pscale(i14(j,ii)) = qmmmscale
             do k = 1, np11(ii)
                if (i14(j,ii) .eq. ip11(k,ii))
      &            pscale(i14(j,ii)) = 0.5d0 * pscale(i14(j,ii))
@@ -264,19 +275,25 @@
          end do
          do j = 1, n15(ii)
             pscale(i15(j,ii)) = p5scale
+            if (qmmm(i15(j,ii)).gt.0) pscale(i15(j,ii)) = qmmmscale
          end do
          do j = 1, np11(ii)
             dscale(ip11(j,ii)) = d1scale
+            if (qmmm(ip11(j,ii)).gt.0) dscale(ip11(j,ii)) = qmmmscale
          end do
          do j = 1, np12(ii)
             dscale(ip12(j,ii)) = d2scale
+            if (qmmm(ip12(j,ii)).gt.0) dscale(ip12(j,ii)) = qmmmscale
          end do
          do j = 1, np13(ii)
             dscale(ip13(j,ii)) = d3scale
+            if (qmmm(ip13(j,ii)).gt.0) dscale(ip13(j,ii)) = qmmmscale
          end do
          do j = 1, np14(ii)
             dscale(ip14(j,ii)) = d4scale
+            if (qmmm(ip14(j,ii)).gt.0) dscale(ip14(j,ii)) = qmmmscale
          end do
+ 1234    continue
          do k = i+1, npole
             kk = ipole(k)
             proceed = .true.
@@ -370,31 +387,45 @@
             do j = i, npole
                dscale(ipole(j)) = 1.0d0
                pscale(ipole(j)) = 1.0d0
+               if (qmmm(ii).gt.0) then
+                  dscale(ipole(j)) = qmmmscale
+                  pscale(ipole(j)) = qmmmscale
+               end if
             end do
+            if (qmmm(ii) .ne. 0) goto 2345
             do j = 1, n12(ii)
                pscale(i12(j,ii)) = p2scale
+               if (qmmm(i12(j,ii)).gt.0) pscale(i12(j,ii)) = qmmmscale
             end do
             do j = 1, n13(ii)
                pscale(i13(j,ii)) = p3scale
+               if (qmmm(i13(j,ii)).gt.0) pscale(i13(j,ii)) = qmmmscale
             end do
             do j = 1, n14(ii)
                pscale(i14(j,ii)) = p4scale
+               if (qmmm(i14(j,ii)).gt.0) pscale(i14(j,ii)) = qmmmscale
             end do
             do j = 1, n15(ii)
                pscale(i15(j,ii)) = p5scale
+               if (qmmm(i15(j,ii)).gt.0) pscale(i15(j,ii)) = qmmmscale
             end do
             do j = 1, np11(ii)
                dscale(ip11(j,ii)) = d1scale
+               if (qmmm(ip11(j,ii)).gt.0) dscale(ip11(j,ii)) = qmmmscale
             end do
             do j = 1, np12(ii)
                dscale(ip12(j,ii)) = d2scale
+               if (qmmm(ip12(j,ii)).gt.0) dscale(ip12(j,ii)) = qmmmscale
             end do
             do j = 1, np13(ii)
                dscale(ip13(j,ii)) = d3scale
+               if (qmmm(ip13(j,ii)).gt.0) dscale(ip13(j,ii)) = qmmmscale
             end do
             do j = 1, np14(ii)
                dscale(ip14(j,ii)) = d4scale
+               if (qmmm(ip14(j,ii)).gt.0) dscale(ip14(j,ii)) = qmmmscale
             end do
+ 2345       continue
             do k = i, npole
                kk = ipole(k)
                ck = rpole(1,k)
diff -abuN source/kcharge.f source_distrib/kcharge.f
--- source/kcharge.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/kcharge.f	2010-08-26 11:38:23.000000000 +0200
@@ -29,6 +29,9 @@
       include 'kchrge.i'
       include 'keys.i'
       include 'potent.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m
       integer ia,next
       integer nc12(maxatm)
@@ -113,15 +116,25 @@
 c
 c     remove zero partial charges from the list of charges
 c
+cqmmm not true if there are QM atoms
+c
+      j = 0
       nion = 0
       do i = 1, n
          chglist(i) = 0
-         if (pchg(i) .ne. 0.0d0) then
+         if (pchg(i) .ne. 0.0d0 .or. qmmm(i) .ne. 0) then
             nion = nion + 1
             iion(nion) = i
             jion(nion) = i
             kion(nion) = i
             pchg(nion) = pchg(i)
+cqmmm            if(qmmm(i) .ne. 0) pchg(nion) = 0.0d0
+cqmmm       Store the MM partial charge of the hybrid YA atom
+            if (qmmm(i) .eq. 3) then
+              j = j + 1
+              qybond(j) = pchg(i)
+            end if
+cqmmm
             chglist(i) = nion
          end if
       end do
diff -abuN source/kimprop.f source_distrib/kimprop.f
--- source/kimprop.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/kimprop.f	2010-08-26 11:38:22.000000000 +0200
@@ -28,6 +28,9 @@
       include 'keys.i'
       include 'kiprop.i'
       include 'potent.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,ndi
       integer ia,ib,ic,id
       integer ita,itb,itc,itd
@@ -113,6 +116,12 @@
                ib = i12(1,i)
                ic = i12(2,i)
                id = i12(3,i)
+cqmmm Do not count QM-only terms
+               if (qmmm(ia).eq.2.and.qmmm(ib).ge.2.and.qmmm(ic).ge.2
+     &             .and.qmmm(id).ge.2) goto 60
+               if (qmmm(ia).eq.3.and.qmmm(ib).eq.2.and.qmmm(ic).eq.2
+     &             .and.qmmm(id).eq.2) goto 60
+cqmmm
                ita = class(ia)
                itb = class(ib)
                itc = class(ic)
@@ -174,6 +183,7 @@
                      end do
                   end if
                end do
+   60          continue
                if (.not. done) then
                   do j = 1, ndi
                      if (kdi(j) .eq. pt1) then
diff -abuN source/kimptor.f source_distrib/kimptor.f
--- source/kimptor.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/kimptor.f	2010-08-26 11:38:25.000000000 +0200
@@ -29,6 +29,9 @@
       include 'kitors.i'
       include 'math.i'
       include 'potent.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,nti
       integer ia,ib,ic,id
       integer ita,itb,itc,itd
@@ -126,6 +129,12 @@
                ib = i12(2,i)
                ic = i
                id = i12(3,i)
+cqmmm Do not count only-QM terms
+               if (qmmm(ia).eq.2.and.qmmm(ib).ge.2.and.qmmm(ic).ge.2
+     &             .and.qmmm(id).ge.2) goto 60
+               if (qmmm(ia).eq.3.and.qmmm(ib).eq.2.and.qmmm(ic).eq.2
+     &             .and.qmmm(id).eq.2) goto 60
+cqmmm
                ita = class(ia)
                itb = class(ib)
                itc = class(ic)
@@ -191,6 +200,7 @@
                      end do
                   end if
                end do
+   60          continue
                if (.not. done) then
                   do j = 1, nti
                      if (kti(j) .eq. pt1) then
diff -abuN source/kopdist.f source_distrib/kopdist.f
--- source/kopdist.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/kopdist.f	2010-08-26 11:38:24.000000000 +0200
@@ -32,6 +32,9 @@
       include 'kopdst.i'
       include 'opdist.i'
       include 'potent.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,nopd
       integer ia,ib,ic,id
       integer ita,itb,itc,itd
@@ -132,6 +135,12 @@
                ib = i12(1,i)
                ic = i12(2,i)
                id = i12(3,i)
+cqmmm Do not count QM-only terms
+               if (qmmm(ia).eq.2.and.qmmm(ib).ge.2.and.qmmm(ic).ge.2
+     &             .and.qmmm(id).ge.2) goto 60
+               if (qmmm(ia).eq.3.and.qmmm(ib).eq.2.and.qmmm(ic).eq.2
+     &             .and.qmmm(id).eq.2) goto 60
+cqmmm
                ita = class(ia)
                itb = class(ib)
                itc = class(ic)
diff -abuN source/kpolar.f source_distrib/kpolar.f
--- source/kpolar.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/kpolar.f	2010-08-26 11:38:21.000000000 +0200
@@ -28,6 +28,9 @@
       include 'polar.i'
       include 'polpot.i'
       include 'potent.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k
       integer npg,next
       integer pg(maxval)
@@ -93,8 +96,15 @@
 c     find and store the atomic dipole polarizability parameters
 c
       do i = 1, n
+cqmmm
+         if (qmmm(i).ne.0) then
+            polarity(i) = 0.0d0
+            thole(i) = 0.0d0
+         else
+cqmmm
          polarity(i) = polr(type(i))
          thole(i) = athl(type(i))
+         endif
       end do
 c
 c     process keywords containing atom specific polarizabilities
@@ -171,6 +181,16 @@
 c
       call chkpole
 c
+c     zero out the values if it's a qmmm atom
+c
+      do i = 1, npole
+         if(qmmm(ipole(i)).ne.0) then
+            do j = 1, maxpole
+               pole(j,i) = 0.0d0
+            end do
+         end if
+      end do
+c
 c     turn off polarizable multipole potential if it is not used
 c
       if (npole .eq. 0)  use_mpole = .false.
diff -abuN source/Makefile source_distrib/Makefile
--- source/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/Makefile	2010-08-26 11:40:24.000000000 +0200
@@ -0,0 +1,1487 @@
+##
+###################################################################
+##                                                               ##
+##  Makefile for Building the Tinker Molecular Modeling Package  ##
+##                                                               ##
+###################################################################
+##
+##  Invocation Options:
+##
+##   1. make all              Build all the TINKER executables
+##   2. make rename           Move the executables to BINDIR
+##   3. make remove_links     Create soft links in LINKDIR
+##   4. make create_links     Remove soft links from LINKDIR
+##   6. make listing          Concatenate source to tinker.txt
+##   5. make clean            Delete objects and executables
+##
+##  Original version of this file is due to Peter Happersberger
+##  and Jochen Buehler of the University of Konstanz, Jan. 1998,
+##  Modifications by Reece Hart & Jay Ponder, Washington University
+##
+###################################################################
+
+###################################################################
+##  Master Directory Locations; Change as Needed for Local Site  ##
+###################################################################
+
+##
+##  TINKERDIR    TINKER Distribution Directory
+##  BINDIR       Hard Copies of TINKER Executables
+##  LINKDIR      Linked Copies of TINKER Executables
+##
+
+TINKERDIR = /home/ferre/CC_Software/tinker5.1.09
+BINDIR = $(TINKERDIR)/bin_qmmm
+#LINKDIR = /usr/local/bin
+
+####################################################################
+##  Known Machine Types; Uncomment One of the Following Sections  ##
+##  May Need Editing to Match Your Desired OS & Compiler Version  ##
+####################################################################
+
+##
+##  Machine:  Generic Linux
+##  CPU Type: Intel x86 Compatible
+##  Oper Sys: Fedora Core
+##  Compiler: GNU g77
+##
+
+#F77 = /usr/bin/g77
+#LIBS =
+#F77FLAGS = -c
+#OPTFLAGS = -O3 -ffast-math
+#LIBFLAGS = -crusv
+#LINKFLAGS =
+
+##
+##  Machine:  Generic Linux
+##  CPU Type: Intel x86 Compatible
+##  Oper Sys: Fedora Core
+##  Compiler: GNU gfortran
+##
+
+#F77 = /usr/bin/gfortran
+#LIBS =
+#F77FLAGS = -c
+#OPTFLAGS = -O
+#LIBFLAGS = -crusv
+#LINKFLAGS =
+
+##
+##  Machine:  Generic Linux
+##  CPU Type: Intel x86 Compatible (also AMD)
+##  Oper Sys: Fedora Core
+##  Compiler: Intel Fortran for Linux 11
+##
+
+#F77 = /opt/intel/Compiler/11.1/072/bin/ia32/ifort
+#LIBS =
+#F77FLAGS = -c -xHost -vec-report0
+#OPTFLAGS = -O3 -no-ipo -no-prec-div
+#LIBFLAGS = -crusv
+#LINKFLAGS = -static-intel
+
+##
+##  Machine:  Generic Linux
+##  CPU Type: Intel x86 Compatible
+##  Oper Sys: Fedora Core
+##  Compiler: Portland Group (PGI) Fortran
+##
+
+#F77 = /opt/pgi/linux86/bin/pgf77
+#LIBS =
+#F77FLAGS = -c
+#OPTFLAGS = -fast
+#LIBFLAGS = -crusv
+#LINKFLAGS =
+
+##
+##  Machine:  Macintosh (Intel)
+##  CPU Type: Intel x86_64 Compatible
+##  Oper Sys: OS X 10.5 (Leopard)
+##  Compiler: Intel Fortran for Mac 11
+##
+
+F77 = /opt/intel/Compiler/11.1/058/bin/intel64/ifort
+LIBS =
+F77FLAGS = -c -axSSSE3 -vec-report0
+OPTFLAGS = -O3 -no-ipo -no-prec-div
+LIBFLAGS = -crusv
+LINKFLAGS = -static-intel -mmacosx-version-min=10.4
+
+##
+##  Machine:  Macintosh (PPC)
+##  CPU Type: PowerPC G4/G5
+##  Oper Sys: OS X 10.4 (Tiger)
+##  Compiler: IBM XLF
+##
+
+#F77 = /opt/ibmcmp/xlf/8.1/bin/xlf
+#F77FLAGS = -c -qextname
+#CFLAGS = -c
+#OPTFLAGS = -O2 -qmaxmem=-1
+#LIBFLAGS = -r
+#LINKFLAGS =
+
+##
+##  Machine:  HP Alpha
+##  CPU Type: Alpha 21264
+##  Oper Sys: HP Tru64 Unix
+##  Compiler: HP Fortran
+##
+
+#F77 = /usr/bin/f77
+#LIBS =
+#F77FLAGS = -c
+#OPTFLAGS = -fast -arch host -tune host
+#LIBFLAGS = -rclvs
+#LINKFLAGS = -fast -non_shared -om -WL,-om_no_inst_sched
+
+##
+##  Machine:  Silicon Graphics
+##  CPU Type: MIPS R10000
+##  Oper Sys: SGI Irix 6.5
+##  Compiler: MIPSPro Fortran
+##
+
+#F77 = /bin/f77
+#LIBS =
+#F77FLAGS = -c
+#OPTFLAGS = -O -mips4
+#LIBFLAGS = -rclvs
+#LINKFLAGS = -O -mips4
+
+##
+##  Machine:  SUN Workstation
+##  CPU Type: UltraSPARC
+##  Oper Sys: Solaris 4.0
+##  Compiler: SUN Fortran
+##
+
+#F77 = /bin/f77
+#LIBS =
+#F77FLAGS = -c
+#OPTFLAGS = -fast -temp=.
+#LIBFLAGS = rcv
+#LINKFLAGS = -fast
+
+#################################################################
+##  Should not be Necessary to Change Things Below this Point  ##
+#################################################################
+
+OBJS = active.o \
+       alchemy.o \
+       analysis.o \
+       analyze.o \
+       angles.o \
+       anneal.o \
+       archive.o \
+       attach.o \
+       basefile.o \
+       beeman.o \
+       bicubic.o \
+       bitors.o \
+       bonds.o \
+       born.o \
+       bounds.o \
+       bspline.o \
+       calendar.o \
+       center.o \
+       chkpole.o \
+       chkring.o \
+       chkxyz.o \
+       cholesky.o \
+       clock.o \
+       cluster.o \
+       column.o \
+       command.o \
+       connect.o \
+       connolly.o \
+       control.o \
+       correlate.o \
+       crystal.o \
+       cspline.o \
+       cutoffs.o \
+       deflate.o \
+       delete.o \
+       diagq.o \
+       diffeq.o \
+       diffuse.o \
+       distgeom.o \
+       document.o \
+       dynamic.o \
+       eangang.o \
+       eangang1.o \
+       eangang2.o \
+       eangang3.o \
+       eangle.o \
+       eangle1.o \
+       eangle2.o \
+       eangle3.o \
+       ebond.o \
+       ebond1.o \
+       ebond2.o \
+       ebond3.o \
+       ebuck.o \
+       ebuck1.o \
+       ebuck2.o \
+       ebuck3.o \
+       echarge.o \
+       echarge1.o \
+       echarge2.o \
+       echarge3.o \
+       echgdpl.o \
+       echgdpl1.o \
+       echgdpl2.o \
+       echgdpl3.o \
+       edipole.o \
+       edipole1.o \
+       edipole2.o \
+       edipole3.o \
+       egauss.o \
+       egauss1.o \
+       egauss2.o \
+       egauss3.o \
+       egeom.o \
+       egeom1.o \
+       egeom2.o \
+       egeom3.o \
+       ehal.o \
+       ehal1.o \
+       ehal2.o \
+       ehal3.o \
+       eimprop.o \
+       eimprop1.o \
+       eimprop2.o \
+       eimprop3.o \
+       eimptor.o \
+       eimptor1.o \
+       eimptor2.o \
+       eimptor3.o \
+       elj.o \
+       elj1.o \
+       elj2.o \
+       elj3.o \
+       embed.o \
+       emetal.o \
+       emetal1.o \
+       emetal2.o \
+       emetal3.o \
+       emm3hb.o \
+       emm3hb1.o \
+       emm3hb2.o \
+       emm3hb3.o \
+       empole.o \
+       empole1.o \
+       empole2.o \
+       empole3.o \
+       energy.o \
+       eopbend.o \
+       eopbend1.o \
+       eopbend2.o \
+       eopbend3.o \
+       eopdist.o \
+       eopdist1.o \
+       eopdist2.o \
+       eopdist3.o \
+       epitors.o \
+       epitors1.o \
+       epitors2.o \
+       epitors3.o \
+       erf.o \
+       erxnfld.o \
+       erxnfld1.o \
+       erxnfld2.o \
+       erxnfld3.o \
+       esolv.o \
+       esolv1.o \
+       esolv2.o \
+       esolv3.o \
+       estrbnd.o \
+       estrbnd1.o \
+       estrbnd2.o \
+       estrbnd3.o \
+       estrtor.o \
+       estrtor1.o \
+       estrtor2.o \
+       estrtor3.o \
+       etors.o \
+       etors1.o \
+       etors2.o \
+       etors3.o \
+       etortor.o \
+       etortor1.o \
+       etortor2.o \
+       etortor3.o \
+       eurey.o \
+       eurey1.o \
+       eurey2.o \
+       eurey3.o \
+       evcorr.o \
+       extra.o \
+       extra1.o \
+       extra2.o \
+       extra3.o \
+       fatal.o \
+       fft3d.o \
+       fftpack.o \
+       field.o \
+       final.o \
+       flatten.o \
+       freeunit.o \
+       gda.o \
+       geometry.o \
+       getime.o \
+       getint.o \
+       getkey.o \
+       getmol2.o \
+       getnumb.o \
+       getpdb.o \
+       getprm.o \
+       getref.o \
+       getstring.o \
+       gettext.o \
+       getword.o \
+       getxyz.o \
+       gradient.o \
+       gradrgd.o \
+       gradrot.o \
+       groups.o \
+       grpline.o \
+       gyrate.o \
+       hessian.o \
+       hessrgd.o \
+       hessrot.o \
+       hybrid.o \
+       image.o \
+       impose.o \
+       induce.o \
+       inertia.o \
+       initial.o \
+       initprm.o \
+       initres.o \
+       initrot.o \
+       insert.o \
+       intedit.o \
+       intxyz.o \
+       invbeta.o \
+       invert.o \
+       jacobi.o \
+       kangang.o \
+       kangle.o \
+       katom.o \
+       kbond.o \
+       kcharge.o \
+       kdipole.o \
+       kewald.o \
+       kgeom.o \
+       kimprop.o \
+       kimptor.o \
+       kinetic.o \
+       kmetal.o \
+       kmpole.o \
+       kopbend.o \
+       kopdist.o \
+       korbit.o \
+       kpitors.o \
+       kpolar.o \
+       ksolv.o \
+       kstrbnd.o \
+       kstrtor.o \
+       ktors.o \
+       ktortor.o \
+       kurey.o \
+       kvdw.o \
+       lattice.o \
+       lbfgs.o \
+       lights.o \
+       makeint.o \
+       makepdb.o \
+       makeref.o \
+       makexyz.o \
+       maxwell.o \
+       mdinit.o \
+       mdrest.o \
+       mdsave.o \
+       mdstat.o \
+       mechanic.o \
+       merge.o \
+       minimize.o \
+       minirot.o \
+       minrigid.o \
+       molecule.o \
+       moments.o \
+       monte.o \
+       mutate.o \
+       nblist.o \
+       newton.o \
+       newtrot.o \
+       nextarg.o \
+       nexttext.o \
+       nspline.o \
+       nucleic.o \
+       number.o \
+       numeral.o \
+       numgrad.o \
+       ocvm.o \
+       openend.o \
+       optimize.o \
+       optirot.o \
+       optrigid.o \
+       optsave.o \
+       orbital.o \
+       orient.o \
+       orthog.o \
+       overlap.o \
+       path.o \
+       pdbxyz.o \
+       piscf.o \
+       pmepol.o \
+       pmpb.o \
+       polarize.o \
+       poledit.o \
+       polymer.o \
+       potential.o \
+       precise.o \
+       pressure.o \
+       prmedit.o \
+       prmkey.o \
+       promo.o \
+       protein.o \
+       prtdyn.o \
+       prterr.o \
+       prtint.o \
+       prtmol2.o \
+       prtpdb.o \
+       prtprm.o \
+       prtseq.o \
+       prtxyz.o \
+       pss.o \
+       pssrigid.o \
+       pssrot.o \
+       quatfit.o \
+       radial.o \
+       random.o \
+       rattle.o \
+       readdyn.o \
+       readgau.o \
+       readint.o \
+       readmol2.o \
+       readpdb.o \
+       readprm.o \
+       readseq.o \
+       readxyz.o \
+       replica.o \
+       rgdstep.o \
+       rings.o \
+       rmsfit.o \
+       rotlist.o \
+       rotpole.o \
+       saddle.o \
+       scan.o \
+       sdstep.o \
+       search.o \
+       server.o \
+       setime.o \
+       shakeup.o \
+       sigmoid.o \
+       sktstuff.o \
+       sniffer.o \
+       sort.o \
+       spacefill.o \
+       spectrum.o \
+       square.o \
+       suffix.o \
+       superpose.o \
+       surface.o \
+       surfatom.o \
+       switch.o \
+       sybylxyz.o \
+       temper.o \
+       testgrad.o \
+       testhess.o \
+       testpair.o \
+       testrot.o \
+       timer.o \
+       timerot.o \
+       tncg.o \
+       torphase.o \
+       torque.o \
+       torsions.o \
+       trimtext.o \
+       unitcell.o \
+       valence.o \
+       verlet.o \
+       version.o \
+       vibbig.o \
+       vibrate.o \
+       vibrot.o \
+       volume.o \
+       xtalfit.o \
+       xtalmin.o \
+       xyzatm.o \
+       xyzedit.o \
+       xyzint.o \
+       xyzpdb.o \
+       xyzsybyl.o \
+       zatom.o
+
+OBJQMMM = avgmd.o \
+          county.o \
+          dynaqmmm.o \
+          elecpol.o \
+          elecpot.o \
+          hess4qm.o \
+          mmpole.o \
+          qmmmsetup.o \
+          readxyz2.o \
+          runqm.o \
+          tkr2qm.o
+
+EXEFILES = alchemy.x \
+           analyze.x \
+           anneal.x \
+           archive.x \
+           correlate.x \
+           crystal.x \
+           diffuse.x \
+           distgeom.x \
+           document.x \
+           dynamic.x \
+           gda.x \
+           intedit.x \
+           intxyz.x \
+           minimize.x \
+           minirot.x \
+           minrigid.x \
+           monte.x \
+           newton.x \
+           newtrot.x \
+           nucleic.x \
+           optimize.x \
+           optirot.x \
+           optrigid.x \
+           path.x \
+           pdbxyz.x \
+           polarize.x \
+           poledit.x \
+           potential.x \
+           prmedit.x \
+           protein.x \
+           pss.x \
+           pssrigid.x \
+           pssrot.x \
+           radial.x \
+           saddle.x \
+           scan.x \
+           sniffer.x \
+           spacefill.x \
+           spectrum.x \
+           superpose.x \
+           sybylxyz.x \
+           testgrad.x \
+           testhess.x \
+           testpair.x \
+           testrot.x \
+           timer.x \
+           timerot.x \
+           valence.x \
+           vibbig.x \
+           vibrate.x \
+           vibrot.x \
+           xtalfit.x \
+           xtalmin.x \
+           xyzedit.x \
+           xyzint.x \
+           xyzpdb.x \
+           xyzsybyl.x
+
+EXEQMMM = dynaqmmm.x \
+          mmpole.x \
+          tkr2qm.x
+.f.o:
+	${F77} ${F77FLAGS} ${OPTFLAGS} $*.f 
+
+.c.o:
+	${CC} ${CFLAGS} ${INCLUDEDIR} ${OPTFLAGS} $*.c 
+
+pmpb.o:
+	${F77} ${F77FLAGS} ${OPTFLAGS} pmpb.f
+
+server.o:
+	${F77} ${F77FLAGS} ${OPTFLAGS} server.f
+
+%.x: %.o libtinker.a
+	${F77} ${LINKFLAGS} -o $@ $^ ${LIBS}
+
+all:	${EXEFILES} ${EXEQMMM}
+
+clean:
+	rm -f *.o *.a *.x
+
+listing:
+	cat *.i *.f > tinker.txt
+
+rename:
+	mv  alchemy.x    $(BINDIR)/alchemy
+	mv  analyze.x    $(BINDIR)/analyze
+	mv  anneal.x     $(BINDIR)/anneal
+	mv  archive.x    $(BINDIR)/archive
+	mv  correlate.x  $(BINDIR)/correlate
+	mv  crystal.x    $(BINDIR)/crystal
+	mv  diffuse.x    $(BINDIR)/diffuse
+	mv  distgeom.x   $(BINDIR)/distgeom
+	mv  document.x   $(BINDIR)/document
+	mv  dynamic.x    $(BINDIR)/dynamic
+	mv  gda.x        $(BINDIR)/gda
+	mv  intedit.x    $(BINDIR)/intedit
+	mv  intxyz.x     $(BINDIR)/intxyz
+	mv  minimize.x   $(BINDIR)/minimize
+	mv  minirot.x    $(BINDIR)/minirot
+	mv  minrigid.x   $(BINDIR)/minrigid
+	mv  monte.x      $(BINDIR)/monte
+	mv  newton.x     $(BINDIR)/newton
+	mv  newtrot.x    $(BINDIR)/newtrot
+	mv  nucleic.x    $(BINDIR)/nucleic
+	mv  optimize.x   $(BINDIR)/optimize
+	mv  optirot.x    $(BINDIR)/optirot
+	mv  optrigid.x   $(BINDIR)/optrigid
+	mv  path.x       $(BINDIR)/path
+	mv  pdbxyz.x     $(BINDIR)/pdbxyz
+	mv  polarize.x   $(BINDIR)/polarize
+	mv  poledit.x    $(BINDIR)/poledit
+	mv  potential.x  $(BINDIR)/potential
+	mv  prmedit.x    $(BINDIR)/prmedit
+	mv  protein.x    $(BINDIR)/protein
+	mv  pss.x        $(BINDIR)/pss
+	mv  pssrigid.x   $(BINDIR)/pssrigid
+	mv  pssrot.x     $(BINDIR)/pssrot
+	mv  radial.x     $(BINDIR)/radial
+	mv  saddle.x     $(BINDIR)/saddle
+	mv  scan.x       $(BINDIR)/scan
+	mv  sniffer.x    $(BINDIR)/sniffer
+	mv  spacefill.x  $(BINDIR)/spacefill
+	mv  spectrum.x   $(BINDIR)/spectrum
+	mv  superpose.x  $(BINDIR)/superpose
+	mv  sybylxyz.x   $(BINDIR)/sybylxyz
+	mv  testgrad.x   $(BINDIR)/testgrad
+	mv  testhess.x   $(BINDIR)/testhess
+	mv  testpair.x   $(BINDIR)/testpair
+	mv  testrot.x    $(BINDIR)/testrot
+	mv  timer.x      $(BINDIR)/timer
+	mv  timerot.x    $(BINDIR)/timerot
+	mv  valence.x    $(BINDIR)/valence
+	mv  vibbig.x     $(BINDIR)/vibbig
+	mv  vibrate.x    $(BINDIR)/vibrate
+	mv  vibrot.x     $(BINDIR)/vibrot
+	mv  xtalfit.x    $(BINDIR)/xtalfit
+	mv  xtalmin.x    $(BINDIR)/xtalmin
+	mv  xyzedit.x    $(BINDIR)/xyzedit
+	mv  xyzint.x     $(BINDIR)/xyzint
+	mv  xyzpdb.x     $(BINDIR)/xyzpdb
+	mv  xyzsybyl.x   $(BINDIR)/xyzsybyl
+	mv  dynaqmmm.x   $(BINDIR)/dynaqmmm
+	mv  mmpole.x     $(BINDIR)/mmpole
+	mv  tkr2qm.x     $(BINDIR)/tkr2qm
+
+remove_links:
+	rm -f $(LINKDIR)/alchemy
+	rm -f $(LINKDIR)/analyze
+	rm -f $(LINKDIR)/anneal
+	rm -f $(LINKDIR)/archive
+	rm -f $(LINKDIR)/correlate
+	rm -f $(LINKDIR)/crystal
+	rm -f $(LINKDIR)/diffuse
+	rm -f $(LINKDIR)/distgeom
+	rm -f $(LINKDIR)/document
+	rm -f $(LINKDIR)/dynamic
+	rm -f $(LINKDIR)/gda
+	rm -f $(LINKDIR)/intedit
+	rm -f $(LINKDIR)/intxyz
+	rm -f $(LINKDIR)/minimize
+	rm -f $(LINKDIR)/minirot
+	rm -f $(LINKDIR)/minrigid
+	rm -f $(LINKDIR)/monte
+	rm -f $(LINKDIR)/newton
+	rm -f $(LINKDIR)/newtrot
+	rm -f $(LINKDIR)/nucleic
+	rm -f $(LINKDIR)/optimize
+	rm -f $(LINKDIR)/optirot
+	rm -f $(LINKDIR)/optrigid
+	rm -f $(LINKDIR)/path
+	rm -f $(LINKDIR)/pdbxyz
+	rm -f $(LINKDIR)/polarize
+	rm -f $(LINKDIR)/poledit
+	rm -f $(LINKDIR)/potential
+	rm -f $(LINKDIR)/prmedit
+	rm -f $(LINKDIR)/protein
+	rm -f $(LINKDIR)/pss
+	rm -f $(LINKDIR)/pssrigid
+	rm -f $(LINKDIR)/pssrot
+	rm -f $(LINKDIR)/radial
+	rm -f $(LINKDIR)/saddle
+	rm -f $(LINKDIR)/scan
+	rm -f $(LINKDIR)/sniffer
+	rm -f $(LINKDIR)/spacefill
+	rm -f $(LINKDIR)/spectrum
+	rm -f $(LINKDIR)/superpose
+	rm -f $(LINKDIR)/sybylxyz
+	rm -f $(LINKDIR)/testgrad
+	rm -f $(LINKDIR)/testhess
+	rm -f $(LINKDIR)/testpair
+	rm -f $(LINKDIR)/testrot
+	rm -f $(LINKDIR)/timer
+	rm -f $(LINKDIR)/timerot
+	rm -f $(LINKDIR)/valence
+	rm -f $(LINKDIR)/vibbig
+	rm -f $(LINKDIR)/vibrate
+	rm -f $(LINKDIR)/vibrot
+	rm -f $(LINKDIR)/xtalfit
+	rm -f $(LINKDIR)/xtalmin
+	rm -f $(LINKDIR)/xyzedit
+	rm -f $(LINKDIR)/xyzint
+	rm -f $(LINKDIR)/xyzpdb
+	rm -f $(LINKDIR)/xyzsybyl
+
+create_links:
+	ln -s $(BINDIR)/alchemy    $(LINKDIR)/alchemy
+	ln -s $(BINDIR)/analyze    $(LINKDIR)/analyze
+	ln -s $(BINDIR)/anneal     $(LINKDIR)/anneal
+	ln -s $(BINDIR)/archive    $(LINKDIR)/archive
+	ln -s $(BINDIR)/correlate  $(LINKDIR)/correlate
+	ln -s $(BINDIR)/crystal    $(LINKDIR)/crystal
+	ln -s $(BINDIR)/diffuse    $(LINKDIR)/diffuse
+	ln -s $(BINDIR)/distgeom   $(LINKDIR)/distgeom
+	ln -s $(BINDIR)/document   $(LINKDIR)/document
+	ln -s $(BINDIR)/dynamic    $(LINKDIR)/dynamic
+	ln -s $(BINDIR)/gda        $(LINKDIR)/gda
+	ln -s $(BINDIR)/intedit    $(LINKDIR)/intedit
+	ln -s $(BINDIR)/intxyz     $(LINKDIR)/intxyz
+	ln -s $(BINDIR)/minimize   $(LINKDIR)/minimize
+	ln -s $(BINDIR)/minirot    $(LINKDIR)/minirot
+	ln -s $(BINDIR)/minrigid   $(LINKDIR)/minrigid
+	ln -s $(BINDIR)/monte      $(LINKDIR)/monte
+	ln -s $(BINDIR)/newton     $(LINKDIR)/newton
+	ln -s $(BINDIR)/newtrot    $(LINKDIR)/newtrot
+	ln -s $(BINDIR)/nucleic    $(LINKDIR)/nucleic
+	ln -s $(BINDIR)/optimize   $(LINKDIR)/optimize
+	ln -s $(BINDIR)/optirot    $(LINKDIR)/optirot
+	ln -s $(BINDIR)/optrigid   $(LINKDIR)/optrigid
+	ln -s $(BINDIR)/path       $(LINKDIR)/path
+	ln -s $(BINDIR)/pdbxyz     $(LINKDIR)/pdbxyz
+	ln -s $(BINDIR)/polarize   $(LINKDIR)/polarize
+	ln -s $(BINDIR)/poledit    $(LINKDIR)/poledit
+	ln -s $(BINDIR)/potential  $(LINKDIR)/potential
+	ln -s $(BINDIR)/prmedit    $(LINKDIR)/prmedit
+	ln -s $(BINDIR)/protein    $(LINKDIR)/protein
+	ln -s $(BINDIR)/pss        $(LINKDIR)/pss
+	ln -s $(BINDIR)/pssrigid   $(LINKDIR)/pssrigid
+	ln -s $(BINDIR)/pssrot     $(LINKDIR)/pssrot
+	ln -s $(BINDIR)/radial     $(LINKDIR)/radial
+	ln -s $(BINDIR)/saddle     $(LINKDIR)/saddle
+	ln -s $(BINDIR)/scan       $(LINKDIR)/scan
+	ln -s $(BINDIR)/sniffer    $(LINKDIR)/sniffer
+	ln -s $(BINDIR)/spacefill  $(LINKDIR)/spacefill
+	ln -s $(BINDIR)/spectrum   $(LINKDIR)/spectrum
+	ln -s $(BINDIR)/superpose  $(LINKDIR)/superpose
+	ln -s $(BINDIR)/sybylxyz   $(LINKDIR)/sybylxyz
+	ln -s $(BINDIR)/testgrad   $(LINKDIR)/testgrad
+	ln -s $(BINDIR)/testhess   $(LINKDIR)/testhess
+	ln -s $(BINDIR)/testpair   $(LINKDIR)/testpair
+	ln -s $(BINDIR)/testrot    $(LINKDIR)/testrot
+	ln -s $(BINDIR)/timer      $(LINKDIR)/timer
+	ln -s $(BINDIR)/timerot    $(LINKDIR)/timerot
+	ln -s $(BINDIR)/valence    $(LINKDIR)/valence
+	ln -s $(BINDIR)/vibbig     $(LINKDIR)/vibbig
+	ln -s $(BINDIR)/vibrate    $(LINKDIR)/vibrate
+	ln -s $(BINDIR)/vibrot     $(LINKDIR)/vibrot
+	ln -s $(BINDIR)/xtalfit    $(LINKDIR)/xtalfit
+	ln -s $(BINDIR)/xtalmin    $(LINKDIR)/xtalmin
+	ln -s $(BINDIR)/xyzedit    $(LINKDIR)/xyzedit
+	ln -s $(BINDIR)/xyzint     $(LINKDIR)/xyzint
+	ln -s $(BINDIR)/xyzpdb     $(LINKDIR)/xyzpdb
+	ln -s $(BINDIR)/xyzsybyl   $(LINKDIR)/xyzsybyl
+
+libtinker.a: ${OBJS} ${OBJQMMM}
+	ar ${LIBFLAGS} libtinker.a \
+        active.o \
+        analysis.o \
+        angles.o \
+        attach.o \
+        basefile.o \
+        beeman.o \
+        bicubic.o \
+        bitors.o \
+        bonds.o \
+        born.o \
+        bounds.o \
+        bspline.o \
+        calendar.o \
+        center.o \
+        chkpole.o \
+        chkring.o \
+        chkxyz.o \
+        cholesky.o \
+        clock.o \
+        cluster.o \
+        column.o \
+        command.o \
+        connect.o \
+        connolly.o \
+        control.o \
+        cspline.o \
+        cutoffs.o \
+        deflate.o \
+        delete.o \
+        diagq.o \
+        diffeq.o \
+        eangang.o \
+        eangang1.o \
+        eangang2.o \
+        eangang3.o \
+        eangle.o \
+        eangle1.o \
+        eangle2.o \
+        eangle3.o \
+        ebond.o \
+        ebond1.o \
+        ebond2.o \
+        ebond3.o \
+        ebuck.o \
+        ebuck1.o \
+        ebuck2.o \
+        ebuck3.o \
+        echarge.o \
+        echarge1.o \
+        echarge2.o \
+        echarge3.o \
+        echgdpl.o \
+        echgdpl1.o \
+        echgdpl2.o \
+        echgdpl3.o \
+        edipole.o \
+        edipole1.o \
+        edipole2.o \
+        edipole3.o \
+        egauss.o \
+        egauss1.o \
+        egauss2.o \
+        egauss3.o \
+        egeom.o \
+        egeom1.o \
+        egeom2.o \
+        egeom3.o \
+        ehal.o \
+        ehal1.o \
+        ehal2.o \
+        ehal3.o \
+        eimprop.o \
+        eimprop1.o \
+        eimprop2.o \
+        eimprop3.o \
+        eimptor.o \
+        eimptor1.o \
+        eimptor2.o \
+        eimptor3.o \
+        elj.o \
+        elj1.o \
+        elj2.o \
+        elj3.o \
+        embed.o \
+        emetal.o \
+        emetal1.o \
+        emetal2.o \
+        emetal3.o \
+        emm3hb.o \
+        emm3hb1.o \
+        emm3hb2.o \
+        emm3hb3.o \
+        empole.o \
+        empole1.o \
+        empole2.o \
+        empole3.o \
+        energy.o \
+        eopbend.o \
+        eopbend1.o \
+        eopbend2.o \
+        eopbend3.o \
+        eopdist.o \
+        eopdist1.o \
+        eopdist2.o \
+        eopdist3.o \
+        epitors.o \
+        epitors1.o \
+        epitors2.o \
+        epitors3.o \
+        erf.o \
+        erxnfld.o \
+        erxnfld1.o \
+        erxnfld2.o \
+        erxnfld3.o \
+        esolv.o \
+        esolv1.o \
+        esolv2.o \
+        esolv3.o \
+        estrbnd.o \
+        estrbnd1.o \
+        estrbnd2.o \
+        estrbnd3.o \
+        estrtor.o \
+        estrtor1.o \
+        estrtor2.o \
+        estrtor3.o \
+        etors.o \
+        etors1.o \
+        etors2.o \
+        etors3.o \
+        etortor.o \
+        etortor1.o \
+        etortor2.o \
+        etortor3.o \
+        eurey.o \
+        eurey1.o \
+        eurey2.o \
+        eurey3.o \
+        evcorr.o \
+        extra.o \
+        extra1.o \
+        extra2.o \
+        extra3.o \
+        fatal.o \
+        fft3d.o \
+        fftpack.o \
+        field.o \
+        final.o \
+        flatten.o \
+        freeunit.o \
+        geometry.o \
+        getime.o \
+        getint.o \
+        getkey.o \
+        getmol2.o \
+        getnumb.o \
+        getpdb.o \
+        getprm.o \
+        getref.o \
+        getstring.o \
+        gettext.o \
+        getword.o \
+        getxyz.o \
+        gradient.o \
+        gradrgd.o \
+        gradrot.o \
+        groups.o \
+        grpline.o \
+        gyrate.o \
+        hessian.o \
+        hessrgd.o \
+        hessrot.o \
+        hybrid.o \
+        image.o \
+        impose.o \
+        induce.o \
+        inertia.o \
+        initial.o \
+        initprm.o \
+        initres.o \
+        initrot.o \
+        insert.o \
+        invbeta.o \
+        invert.o \
+        jacobi.o \
+        kangang.o \
+        kangle.o \
+        katom.o \
+        kbond.o \
+        kcharge.o \
+        kdipole.o \
+        kewald.o \
+        kgeom.o \
+        kimprop.o \
+        kimptor.o \
+        kinetic.o \
+        kmetal.o \
+        kmpole.o \
+        kopbend.o \
+        kopdist.o \
+        korbit.o \
+        kpitors.o \
+        kpolar.o \
+        ksolv.o \
+        kstrbnd.o \
+        kstrtor.o \
+        ktors.o \
+        ktortor.o \
+        kurey.o \
+        kvdw.o \
+        lattice.o \
+        lbfgs.o \
+        lights.o \
+        makeint.o \
+        makepdb.o \
+        makeref.o \
+        makexyz.o \
+        maxwell.o \
+        mdinit.o \
+        mdrest.o \
+        mdsave.o \
+        mdstat.o \
+        mechanic.o \
+        merge.o \
+        molecule.o \
+        moments.o \
+        mutate.o \
+        nblist.o \
+        nextarg.o \
+        nexttext.o \
+        nspline.o \
+        number.o \
+        numeral.o \
+        numgrad.o \
+        ocvm.o \
+        openend.o \
+        optsave.o \
+        orbital.o \
+        orient.o \
+        orthog.o \
+        overlap.o \
+        piscf.o \
+        pmepol.o \
+        pmpb.o \
+        polymer.o \
+        precise.o \
+        pressure.o \
+        prmkey.o \
+        promo.o \
+        prtdyn.o \
+        prterr.o \
+        prtint.o \
+        prtmol2.o \
+        prtpdb.o \
+        prtprm.o \
+        prtseq.o \
+        prtxyz.o \
+        quatfit.o \
+        random.o \
+        rattle.o \
+        readdyn.o \
+        readgau.o \
+        readint.o \
+        readmol2.o \
+        readpdb.o \
+        readprm.o \
+        readseq.o \
+        readxyz.o \
+        replica.o \
+        rgdstep.o \
+        rings.o \
+        rmsfit.o \
+        rotlist.o \
+        rotpole.o \
+        sdstep.o \
+        search.o \
+        server.o \
+        setime.o \
+        shakeup.o \
+        sigmoid.o \
+        sktstuff.o \
+        sort.o \
+        square.o \
+        suffix.o \
+        surface.o \
+        surfatom.o \
+        switch.o \
+        temper.o \
+        testrot.o \
+        tncg.o \
+        torphase.o \
+        torque.o \
+        torsions.o \
+        trimtext.o \
+        unitcell.o \
+        verlet.o \
+        version.o \
+        volume.o \
+        xyzatm.o \
+        zatom.o
+	ar ${LIBFLAGS} libtinker.a \
+        avgmd.o \
+        county.o \
+        elecpol.o \
+        elecpot.o \
+        hess4qm.o \
+        qmmmsetup.o \
+        readxyz2.o \
+        runqm.o
+
+###############################################################
+##  Next Section has Explicit Dependencies on Include Files  ##
+###############################################################
+
+active.o: atoms.i inform.i iounit.i keys.i sizes.i usage.i
+alchemy.o: analyz.i atoms.i energi.i files.i inform.i iounit.i katoms.i mutant.i potent.i sizes.i units.i usage.i
+analysis.o: analyz.i atoms.i bound.i cutoff.i energi.i group.i inter.i potent.i sizes.i vdwpot.i
+analyze.o: action.i analyz.i angang.i angle.i angpot.i atmtyp.i atoms.i bitor.i bond.i bound.i boxes.i charge.i chgpot.i cutoff.i dipole.i energi.i ewald.i fields.i files.i improp.i imptor.i inform.i inter.i iounit.i korbs.i ktrtor.i kvdws.i math.i molcul.i moment.i mpole.i opbend.i opdist.i piorbs.i pistuf.i pitors.i pme.i polar.i polgrp.i potent.i sizes.i solute.i strbnd.i strtor.i tors.i tortor.i units.i urey.i vdw.i vdwpot.i virial.i
+angles.o: angle.i atmlst.i atoms.i couple.i iounit.i qmmm.i sizes.i
+anneal.o: atmtyp.i atoms.i bath.i bond.i bound.i inform.i iounit.i mdstuf.i potent.i sizes.i solute.i usage.i warp.i
+archive.o: atmtyp.i atoms.i couple.i files.i inform.i iounit.i sizes.i titles.i usage.i
+attach.o: atoms.i couple.i iounit.i sizes.i
+avgmd.o: analyz.i atmtyp.i atoms.i bath.i bound.i charge.i couple.i deriv.i energi.i files.i group.i inform.i iounit.i mdstuf.i mpole.i polar.i potent.i qmmm.i scales.i sizes.i units.i usage.i
+basefile.o: ascii.i files.i
+beeman.o: atmtyp.i atoms.i moldyn.i shake.i sizes.i units.i usage.i
+bicubic.o:
+bitors.o: angle.i bitor.i couple.i iounit.i sizes.i
+bonds.o: atmlst.i atoms.i bond.i couple.i iounit.i qmmm.i sizes.i
+born.o: atmtyp.i atoms.i bath.i chgpot.i couple.i deriv.i inform.i iounit.i math.i pb.i potent.i sizes.i solute.i virial.i
+bounds.o: atmtyp.i atoms.i boxes.i molcul.i sizes.i
+bspline.o:
+calendar.o:
+center.o: align.i sizes.i
+chkpole.o: atoms.i mpole.i sizes.i
+chkring.o: couple.i sizes.i
+chkxyz.o: atoms.i iounit.i sizes.i
+cholesky.o:
+clock.o:
+cluster.o: atmtyp.i atoms.i bound.i cutoff.i group.i inform.i iounit.i keys.i molcul.i sizes.i
+column.o: sizes.i
+command.o: argue.i
+connect.o: atoms.i couple.i sizes.i zclose.i zcoord.i
+connolly.o: atoms.i faces.i inform.i iounit.i math.i sizes.i
+control.o: argue.i inform.i keys.i output.i sizes.i
+correlate.o: ascii.i atmtyp.i atoms.i files.i inform.i iounit.i sizes.i
+county.o: atmtyp.i atoms.i couple.i iounit.i qmmm.i sizes.i
+crystal.o: atmtyp.i atoms.i bound.i boxes.i couple.i files.i iounit.i math.i molcul.i sizes.i
+cspline.o: iounit.i
+cutoffs.o: bound.i cutoff.i hescut.i keys.i neigh.i sizes.i
+deflate.o: iounit.i
+delete.o: atmtyp.i atoms.i couple.i inform.i iounit.i sizes.i
+diagq.o:
+diffeq.o: atoms.i iounit.i math.i sizes.i warp.i
+diffuse.o: atmtyp.i atoms.i boxes.i iounit.i molcul.i sizes.i
+distgeom.o: angle.i atmtyp.i atoms.i bond.i couple.i disgeo.i files.i inform.i iounit.i kgeoms.i math.i refer.i sizes.i tors.i
+document.o: iounit.i
+dynamic.o: atoms.i bath.i bond.i bound.i inform.i iounit.i mdstuf.i potent.i sizes.i solute.i stodyn.i usage.i
+dynaqmmm.o: atmtyp.i atoms.i bath.i bond.i bound.i couple.i inform.i iounit.i mdstuf.i potent.i qmmm.i sizes.i solute.i stodyn.i usage.i
+eangang1.o: angang.i angle.i angpot.i atoms.i bound.i deriv.i energi.i group.i math.i sizes.i usage.i virial.i
+eangang2.o: angang.i angle.i angpot.i atoms.i bound.i deriv.i group.i hessn.i math.i sizes.i
+eangang3.o: action.i analyz.i angang.i angle.i angpot.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i math.i sizes.i usage.i
+eangang.o: angang.i angle.i angpot.i atoms.i bound.i energi.i group.i math.i sizes.i usage.i
+eangle1.o: angle.i angpot.i atoms.i bound.i deriv.i energi.i group.i math.i sizes.i usage.i virial.i
+eangle2.o: angle.i angpot.i atoms.i bound.i deriv.i group.i hessn.i math.i sizes.i
+eangle3.o: action.i analyz.i angle.i angpot.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i math.i sizes.i usage.i
+eangle.o: angle.i angpot.i atoms.i bound.i energi.i group.i math.i sizes.i usage.i
+ebond1.o: atoms.i bndpot.i bond.i bound.i deriv.i energi.i group.i sizes.i usage.i virial.i
+ebond2.o: atmlst.i atoms.i bndpot.i bond.i bound.i couple.i group.i hessn.i sizes.i
+ebond3.o: action.i analyz.i atmtyp.i atoms.i bndpot.i bond.i bound.i energi.i group.i inform.i iounit.i sizes.i usage.i
+ebond.o: atoms.i bndpot.i bond.i bound.i energi.i group.i sizes.i usage.i
+ebuck1.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i deriv.i energi.i group.i inter.i iounit.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i virial.i warp.i
+ebuck2.o: atmtyp.i atoms.i bound.i cell.i couple.i group.i hessn.i iounit.i math.i qmmm.i shunt.i sizes.i vdw.i vdwpot.i warp.i
+ebuck3.o: action.i analyz.i atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i inform.i inter.i iounit.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i warp.i
+ebuck.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i iounit.i light.i math.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i warp.i
+echarge1.o: atoms.i bound.i boxes.i cell.i charge.i chgpot.i couple.i cutoff.i deriv.i energi.i ewald.i group.i inter.i light.i math.i molcul.i neigh.i pme.i qmmm.i shunt.i sizes.i usage.i virial.i warp.i
+echarge2.o: atoms.i bound.i cell.i charge.i chgpot.i couple.i cutoff.i ewald.i group.i hessn.i math.i qmmm.i shunt.i sizes.i warp.i
+echarge3.o: action.i analyz.i atmtyp.i atoms.i bound.i boxes.i cell.i charge.i chgpot.i couple.i cutoff.i energi.i ewald.i group.i inform.i inter.i iounit.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i warp.i
+echarge.o: atoms.i bound.i boxes.i cell.i charge.i chgpot.i couple.i cutoff.i energi.i ewald.i group.i iounit.i light.i math.i neigh.i pme.i qmmm.i shunt.i sizes.i usage.i warp.i
+echgdpl1.o: atoms.i bound.i cell.i charge.i chgpot.i couple.i deriv.i dipole.i energi.i group.i inter.i molcul.i qmmm.i shunt.i sizes.i units.i usage.i virial.i
+echgdpl2.o: atoms.i bound.i cell.i charge.i chgpot.i couple.i dipole.i group.i hessn.i qmmm.i shunt.i sizes.i units.i
+echgdpl3.o: action.i analyz.i atmtyp.i atoms.i bound.i cell.i charge.i chgpot.i couple.i dipole.i energi.i group.i inform.i inter.i iounit.i molcul.i qmmm.i shunt.i sizes.i units.i usage.i
+echgdpl.o: atoms.i bound.i cell.i charge.i chgpot.i couple.i dipole.i energi.i group.i qmmm.i shunt.i sizes.i units.i usage.i
+edipole1.o: atoms.i bound.i cell.i chgpot.i deriv.i dipole.i energi.i group.i inter.i molcul.i qmmm.i shunt.i sizes.i units.i usage.i virial.i
+edipole2.o: atoms.i bound.i cell.i chgpot.i dipole.i group.i hessn.i qmmm.i shunt.i sizes.i units.i
+edipole3.o: action.i analyz.i atmtyp.i atoms.i bound.i cell.i chgpot.i dipole.i energi.i group.i inform.i inter.i iounit.i molcul.i qmmm.i shunt.i sizes.i units.i usage.i
+edipole.o: atoms.i bound.i cell.i chgpot.i dipole.i energi.i group.i qmmm.i shunt.i sizes.i units.i usage.i
+egauss1.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i deriv.i energi.i group.i inter.i iounit.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i virial.i warp.i
+egauss2.o: atmtyp.i atoms.i bound.i cell.i couple.i group.i hessn.i qmmm.i shunt.i sizes.i vdw.i vdwpot.i warp.i
+egauss3.o: action.i analyz.i atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i inform.i inter.i iounit.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i warp.i
+egauss.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i light.i math.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i warp.i
+egeom1.o: atmtyp.i atoms.i bound.i deriv.i energi.i group.i inter.i kgeoms.i math.i molcul.i sizes.i usage.i virial.i
+egeom2.o: atmtyp.i atoms.i bound.i deriv.i group.i hessn.i kgeoms.i math.i molcul.i sizes.i
+egeom3.o: action.i analyz.i atmtyp.i atoms.i bound.i energi.i group.i inform.i inter.i iounit.i kgeoms.i math.i molcul.i sizes.i usage.i
+egeom.o: atmtyp.i atoms.i bound.i energi.i group.i kgeoms.i math.i molcul.i sizes.i usage.i
+ehal1.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i deriv.i energi.i group.i inter.i iounit.i light.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i virial.i
+ehal2.o: atmtyp.i atoms.i bound.i cell.i couple.i group.i hessn.i qmmm.i shunt.i sizes.i vdw.i vdwpot.i
+ehal3.o: action.i analyz.i atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i inform.i inter.i iounit.i light.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i
+ehal.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i light.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i
+eimprop1.o: atoms.i bound.i deriv.i energi.i group.i improp.i math.i sizes.i torpot.i usage.i virial.i
+eimprop2.o: atoms.i bound.i group.i hessn.i improp.i math.i sizes.i torpot.i
+eimprop3.o: action.i analyz.i atmtyp.i atoms.i bound.i energi.i group.i improp.i inform.i iounit.i math.i sizes.i torpot.i usage.i
+eimprop.o: atoms.i bound.i energi.i group.i improp.i math.i sizes.i torpot.i usage.i
+eimptor1.o: atoms.i bound.i deriv.i energi.i group.i imptor.i sizes.i torpot.i usage.i virial.i
+eimptor2.o: atoms.i bound.i group.i hessn.i imptor.i sizes.i torpot.i
+eimptor3.o: action.i analyz.i atmtyp.i atoms.i bound.i energi.i group.i imptor.i inform.i iounit.i math.i sizes.i torpot.i usage.i
+eimptor.o: atoms.i bound.i energi.i group.i imptor.i sizes.i torpot.i usage.i
+elecpol.o: atoms.i bound.i cell.i chgpot.i couple.i energi.i group.i mplpot.i mpole.i polar.i polgrp.i polpot.i qmmm.i shunt.i sizes.i units.i usage.i
+elecpot.o: atoms.i bound.i cell.i charge.i chgpot.i couple.i energi.i group.i qmmm.i shunt.i sizes.i units.i
+elj1.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i deriv.i energi.i group.i inter.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i virial.i warp.i
+elj2.o: atmtyp.i atoms.i bound.i cell.i couple.i group.i hessn.i math.i qmmm.i shunt.i sizes.i vdw.i vdwpot.i warp.i
+elj3.o: action.i analyz.i atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i inform.i inter.i iounit.i light.i math.i molcul.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i warp.i
+elj.o: atmtyp.i atoms.i bound.i boxes.i cell.i couple.i cutoff.i energi.i group.i light.i math.i neigh.i qmmm.i shunt.i sizes.i usage.i vdw.i vdwpot.i warp.i
+embed.o: angle.i atoms.i bond.i couple.i disgeo.i files.i inform.i iounit.i keys.i kgeoms.i light.i math.i minima.i output.i refer.i sizes.i tors.i units.i
+emetal1.o: atmtyp.i atoms.i couple.i deriv.i energi.i kchrge.i sizes.i
+emetal2.o:
+emetal3.o: action.i analyz.i atmtyp.i atoms.i energi.i kchrge.i sizes.i
+emetal.o: atmtyp.i atoms.i couple.i energi.i kchrge.i sizes.i
+emm3hb1.o: atmlst.i atmtyp.i atoms.i bond.i bound.i boxes.i cell.i chgpot.i couple.i cutoff.i deriv.i energi.i group.i inter.i iounit.i light.i molcul.i neigh.i shunt.i sizes.i usage.i vdw.i vdwpot.i virial.i
+emm3hb2.o: atmlst.i atmtyp.i atoms.i bond.i bound.i cell.i chgpot.i couple.i group.i hessn.i shunt.i sizes.i vdw.i vdwpot.i
+emm3hb3.o: action.i analyz.i atmlst.i atmtyp.i atoms.i bond.i bound.i boxes.i cell.i chgpot.i couple.i cutoff.i energi.i group.i inform.i inter.i iounit.i light.i molcul.i neigh.i shunt.i sizes.i usage.i vdw.i vdwpot.i
+emm3hb.o: atmlst.i atmtyp.i atoms.i bond.i bound.i boxes.i cell.i chgpot.i couple.i cutoff.i energi.i group.i light.i neigh.i shunt.i sizes.i usage.i vdw.i vdwpot.i
+empole1.o: atoms.i bound.i boxes.i cell.i chgpot.i couple.i cutoff.i deriv.i energi.i ewald.i group.i inter.i math.i molcul.i mplpot.i mpole.i neigh.i pme.i polar.i polgrp.i polpot.i potent.i qmmm.i shunt.i sizes.i usage.i virial.i
+empole2.o: atoms.i bound.i boxes.i chgpot.i couple.i cutoff.i deriv.i group.i hessn.i molcul.i mplpot.i mpole.i polar.i polgrp.i polpot.i potent.i qmmm.i shunt.i sizes.i usage.i
+empole3.o: action.i analyz.i atmtyp.i atoms.i bound.i boxes.i cell.i chgpot.i couple.i cutoff.i energi.i ewald.i group.i inform.i inter.i iounit.i math.i molcul.i mplpot.i mpole.i neigh.i polar.i polgrp.i polpot.i potent.i qmmm.i shunt.i sizes.i usage.i
+empole.o: atoms.i bound.i boxes.i cell.i chgpot.i couple.i cutoff.i energi.i ewald.i group.i math.i mplpot.i mpole.i neigh.i pme.i polar.i polgrp.i polpot.i potent.i qmmm.i shunt.i sizes.i usage.i
+energy.o: bound.i cutoff.i energi.i potent.i rigid.i sizes.i vdwpot.i
+eopbend1.o: angle.i angpot.i atoms.i bound.i deriv.i energi.i group.i math.i opbend.i sizes.i usage.i virial.i
+eopbend2.o: angle.i angpot.i atoms.i bound.i deriv.i group.i hessn.i math.i opbend.i sizes.i
+eopbend3.o: action.i analyz.i angle.i angpot.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i math.i opbend.i sizes.i usage.i
+eopbend.o: angle.i angpot.i atoms.i bound.i energi.i fields.i group.i math.i opbend.i sizes.i usage.i
+eopdist1.o: angpot.i atoms.i bound.i deriv.i energi.i group.i opdist.i sizes.i usage.i virial.i
+eopdist2.o: angpot.i atoms.i bound.i group.i hessn.i opdist.i sizes.i usage.i
+eopdist3.o: action.i analyz.i angpot.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i opdist.i sizes.i usage.i
+eopdist.o: angpot.i atoms.i bound.i energi.i group.i opdist.i sizes.i usage.i
+epitors1.o: atoms.i bound.i deriv.i energi.i group.i pitors.i sizes.i torpot.i usage.i virial.i
+epitors2.o: angle.i atoms.i bound.i deriv.i group.i hessn.i pitors.i sizes.i torpot.i usage.i
+epitors3.o: action.i analyz.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i math.i pitors.i sizes.i torpot.i usage.i
+epitors.o: atoms.i bound.i energi.i group.i pitors.i sizes.i torpot.i usage.i
+erf.o: iounit.i math.i
+erxnfld1.o: atoms.i deriv.i energi.i sizes.i
+erxnfld2.o:
+erxnfld3.o: action.i analyz.i atmtyp.i atoms.i chgpot.i energi.i inform.i iounit.i mpole.i shunt.i sizes.i usage.i
+erxnfld.o: atoms.i chgpot.i energi.i mpole.i rxnfld.i rxnpot.i shunt.i sizes.i usage.i
+esolv1.o: atmtyp.i atoms.i bound.i boxes.i charge.i chgpot.i couple.i cutoff.i deriv.i energi.i gk.i group.i inter.i kvdws.i math.i molcul.i mplpot.i mpole.i npolar.i pb.i polar.i polgrp.i polpot.i potent.i shunt.i sizes.i solute.i usage.i vdw.i virial.i warp.i
+esolv2.o: atoms.i charge.i chgpot.i hessn.i math.i potent.i shunt.i sizes.i solute.i warp.i
+esolv3.o: action.i analyz.i atmtyp.i atoms.i bound.i charge.i chgpot.i couple.i deriv.i energi.i gk.i group.i inform.i inter.i iounit.i kvdws.i math.i molcul.i mpole.i npolar.i pb.i polar.i polgrp.i polpot.i potent.i shunt.i sizes.i solute.i usage.i vdw.i warp.i
+esolv.o: atmtyp.i atoms.i bound.i charge.i chgpot.i couple.i deriv.i energi.i gk.i group.i kvdws.i math.i mpole.i npolar.i pb.i polar.i polgrp.i polpot.i potent.i shunt.i sizes.i solute.i usage.i vdw.i warp.i
+estrbnd1.o: angle.i angpot.i atoms.i bond.i bound.i deriv.i energi.i group.i math.i sizes.i strbnd.i usage.i virial.i
+estrbnd2.o: angle.i angpot.i atoms.i bond.i bound.i group.i hessn.i math.i sizes.i strbnd.i
+estrbnd3.o: action.i analyz.i angle.i angpot.i atmtyp.i atoms.i bond.i bound.i energi.i group.i inform.i iounit.i math.i sizes.i strbnd.i usage.i
+estrbnd.o: angle.i angpot.i atoms.i bond.i bound.i energi.i group.i math.i sizes.i strbnd.i usage.i
+estrtor1.o: atoms.i bond.i bound.i deriv.i energi.i group.i sizes.i strtor.i torpot.i tors.i usage.i virial.i
+estrtor2.o: atoms.i bond.i bound.i group.i hessn.i sizes.i strtor.i torpot.i tors.i
+estrtor3.o: action.i analyz.i atmtyp.i atoms.i bond.i bound.i energi.i group.i inform.i iounit.i math.i sizes.i strtor.i torpot.i tors.i usage.i
+estrtor.o: atoms.i bond.i bound.i energi.i group.i sizes.i strtor.i torpot.i tors.i usage.i
+etors1.o: atoms.i bound.i deriv.i energi.i group.i math.i sizes.i torpot.i tors.i usage.i virial.i warp.i
+etors2.o: atoms.i bound.i group.i hessn.i math.i sizes.i torpot.i tors.i warp.i
+etors3.o: action.i analyz.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i math.i sizes.i torpot.i tors.i usage.i warp.i
+etors.o: atoms.i bound.i energi.i group.i math.i sizes.i torpot.i tors.i usage.i warp.i
+etortor1.o: atoms.i bitor.i bound.i deriv.i energi.i group.i ktrtor.i math.i sizes.i torpot.i tortor.i usage.i virial.i
+etortor2.o: atoms.i bitor.i bound.i group.i hessn.i ktrtor.i math.i sizes.i torpot.i tortor.i units.i
+etortor3.o: action.i analyz.i atoms.i bitor.i bound.i energi.i group.i inform.i iounit.i ktrtor.i math.i sizes.i torpot.i tortor.i usage.i
+etortor.o: atmtyp.i atoms.i bitor.i bound.i couple.i energi.i group.i ktrtor.i math.i sizes.i torpot.i tortor.i usage.i
+eurey1.o: atoms.i bound.i deriv.i energi.i group.i sizes.i urey.i urypot.i usage.i virial.i
+eurey2.o: atoms.i bound.i couple.i group.i hessn.i sizes.i urey.i urypot.i
+eurey3.o: action.i analyz.i atmtyp.i atoms.i bound.i energi.i group.i inform.i iounit.i sizes.i urey.i urypot.i usage.i
+eurey.o: atoms.i bound.i energi.i group.i sizes.i urey.i urypot.i usage.i
+evcorr.o: bound.i boxes.i cutoff.i math.i shunt.i sizes.i vdw.i vdwpot.i
+extra1.o: atoms.i deriv.i energi.i sizes.i
+extra2.o: atoms.i hessn.i sizes.i
+extra3.o: action.i analyz.i atoms.i energi.i sizes.i
+extra.o: energi.i
+fatal.o: iounit.i
+fft3d.o: pme.i sizes.i
+fftpack.o: math.i
+field.o: keys.i potent.i sizes.i
+final.o: inform.i iounit.i sizes.i socket.i solute.i
+flatten.o: atoms.i fields.i inform.i iounit.i keys.i sizes.i warp.i
+freeunit.o: iounit.i
+gda.o: atoms.i files.i iounit.i minima.i potent.i sizes.i vdwpot.i warp.i
+geometry.o: atoms.i math.i sizes.i
+getime.o: chrono.i
+getint.o: inform.i iounit.i output.i
+getkey.o: argue.i files.i iounit.i keys.i sizes.i
+getmol2.o: files.i iounit.i
+getnumb.o: ascii.i
+getpdb.o: iounit.i
+getprm.o: files.i iounit.i keys.i params.i sizes.i
+getref.o: atmtyp.i atoms.i couple.i files.i refer.i sizes.i titles.i
+getstring.o: ascii.i
+gettext.o: ascii.i
+getword.o: ascii.i
+getxyz.o: inform.i iounit.i output.i
+gradient.o: atoms.i bound.i couple.i cutoff.i deriv.i energi.i inform.i inter.i iounit.i potent.i qmmm.i rigid.i sizes.i vdwpot.i virial.i
+gradrgd.o: atoms.i group.i rigid.i sizes.i
+gradrot.o: atoms.i deriv.i domega.i omega.i potent.i rotate.i sizes.i
+groups.o: group.i sizes.i
+grpline.o: atmtyp.i atoms.i group.i rgddyn.i sizes.i
+gyrate.o: atoms.i sizes.i usage.i
+hess4qm.o: atoms.i bound.i couple.i hescut.i hessn.i inform.i iounit.i mpole.i potent.i qmmm.i rigid.i sizes.i usage.i vdw.i vdwpot.i
+hessian.o: atoms.i bound.i couple.i cutoff.i hescut.i hessn.i inform.i iounit.i mpole.i potent.i rigid.i sizes.i usage.i vdw.i vdwpot.i
+hessrgd.o: atoms.i group.i rigid.i sizes.i
+hessrot.o: math.i omega.i sizes.i zcoord.i
+hybrid.o: angle.i atmlst.i atmtyp.i atoms.i bond.i charge.i couple.i dipole.i imptor.i inform.i iounit.i kangs.i katoms.i kbonds.i kchrge.i kdipol.i kitors.i kpolr.i kstbnd.i ksttor.i ktorsn.i kvdws.i math.i mpole.i mutant.i polar.i sizes.i strbnd.i strtor.i tors.i vdw.i vdwpot.i
+image.o: boxes.i cell.i sizes.i
+impose.o: align.i inform.i iounit.i sizes.i
+induce.o: atoms.i bound.i boxes.i cell.i couple.i cutoff.i ewald.i gk.i group.i inform.i iounit.i math.i mpole.i neigh.i pb.i pme.i polar.i polgrp.i polpot.i potent.i qmmm.i shunt.i sizes.i solute.i units.i
+inertia.o: atmtyp.i atoms.i iounit.i math.i sizes.i
+initial.o: align.i argue.i atoms.i bath.i bound.i cell.i files.i group.i inform.i iounit.i keys.i linmin.i minima.i molcul.i mutant.i neigh.i output.i params.i pdb.i precis.i rigid.i scales.i sequen.i sizes.i socket.i warp.i zclose.i
+initprm.o: angpot.i bndpot.i chgpot.i fields.i kanang.i kangs.i katoms.i kbonds.i kchrge.i kdipol.i khbond.i kiprop.i kitors.i kmulti.i kopbnd.i kopdst.i korbs.i kpitor.i kpolr.i kstbnd.i ksttor.i ktorsn.i ktrtor.i kurybr.i kvdwpr.i kvdws.i math.i mplpot.i polpot.i rxnpot.i sizes.i solute.i torpot.i units.i urypot.i vdwpot.i
+initres.o: resdue.i sizes.i
+initrot.o: atoms.i couple.i group.i inform.i iounit.i kgeoms.i math.i omega.i rotate.i sizes.i usage.i zcoord.i
+insert.o: atmtyp.i atoms.i couple.i inform.i iounit.i sizes.i
+intedit.o: atmtyp.i atoms.i files.i iounit.i katoms.i sizes.i zcoord.i
+intxyz.o: files.i iounit.i titles.i
+invbeta.o:
+invert.o: iounit.i
+jacobi.o: iounit.i
+kangang.o: angang.i angle.i atmlst.i atmtyp.i atoms.i couple.i iounit.i kanang.i keys.i potent.i sizes.i
+kangle.o: angle.i angpot.i atmtyp.i atoms.i couple.i inform.i iounit.i kangs.i keys.i potent.i sizes.i usage.i
+katom.o: atmtyp.i atoms.i couple.i inform.i iounit.i katoms.i keys.i sizes.i
+kbond.o: angle.i atmlst.i atmtyp.i atoms.i bond.i couple.i inform.i iounit.i kbonds.i keys.i potent.i sizes.i tors.i usage.i
+kcharge.o: atmtyp.i atoms.i charge.i chgpot.i couple.i inform.i iounit.i kchrge.i keys.i potent.i qmmm.i sizes.i
+kdipole.o: atmlst.i atoms.i bond.i couple.i dipole.i inform.i iounit.i kdipol.i keys.i potent.i sizes.i
+kewald.o: atoms.i bound.i boxes.i cutoff.i ewald.i inform.i iounit.i keys.i math.i pme.i sizes.i
+kgeom.o: atmtyp.i atoms.i bound.i couple.i group.i iounit.i keys.i kgeoms.i molcul.i potent.i sizes.i
+kimprop.o: atmtyp.i atoms.i couple.i improp.i inform.i iounit.i keys.i kiprop.i potent.i qmmm.i sizes.i
+kimptor.o: atmtyp.i atoms.i couple.i imptor.i inform.i iounit.i keys.i kitors.i math.i potent.i qmmm.i sizes.i
+kinetic.o: atmtyp.i atoms.i group.i mdstuf.i moldyn.i rgddyn.i sizes.i units.i usage.i
+kmetal.o:
+kmpole.o: atoms.i couple.i inform.i iounit.i keys.i kmulti.i mpole.i polar.i polgrp.i potent.i sizes.i units.i
+kopbend.o: angle.i angpot.i atmtyp.i atoms.i couple.i inform.i iounit.i keys.i kopbnd.i opbend.i potent.i sizes.i usage.i
+kopdist.o: angle.i angpot.i atmlst.i atmtyp.i atoms.i couple.i inform.i iounit.i keys.i kopdst.i opdist.i potent.i qmmm.i sizes.i
+korbit.o: atmtyp.i atoms.i bond.i inform.i iounit.i keys.i korbs.i orbits.i piorbs.i pistuf.i sizes.i tors.i units.i
+kpitors.o: atmtyp.i atoms.i bond.i couple.i inform.i iounit.i keys.i kpitor.i pitors.i potent.i sizes.i
+kpolar.o: atoms.i couple.i inform.i iounit.i keys.i kpolr.i mpole.i polar.i polgrp.i polpot.i potent.i qmmm.i sizes.i
+ksolv.o: angle.i atmlst.i atmtyp.i atoms.i bath.i bond.i chgpot.i couple.i gk.i inform.i iounit.i keys.i kvdws.i math.i npolar.i pb.i potent.i sizes.i solute.i
+kstrbnd.o: angle.i angpot.i atmlst.i atmtyp.i atoms.i couple.i inform.i iounit.i keys.i kstbnd.i potent.i sizes.i strbnd.i
+kstrtor.o: atmlst.i atmtyp.i atoms.i couple.i inform.i iounit.i keys.i ksttor.i potent.i sizes.i strtor.i tors.i
+ktors.o: atmtyp.i atoms.i couple.i inform.i iounit.i keys.i ktorsn.i math.i potent.i sizes.i tors.i usage.i
+ktortor.o: atmtyp.i atoms.i bitor.i inform.i iounit.i keys.i ktrtor.i potent.i sizes.i tortor.i
+kurey.o: angle.i atmtyp.i atoms.i inform.i iounit.i keys.i kurybr.i potent.i sizes.i urey.i
+kvdw.o: atmtyp.i atoms.i couple.i inform.i iounit.i keys.i khbond.i kvdwpr.i kvdws.i math.i potent.i sizes.i vdw.i vdwpot.i
+lattice.o: boxes.i cell.i inform.i iounit.i math.i sizes.i
+lbfgs.o: inform.i iounit.i keys.i linmin.i math.i minima.i output.i scales.i sizes.i
+lights.o: bound.i boxes.i cell.i iounit.i light.i sizes.i
+makeint.o: atoms.i couple.i inform.i iounit.i math.i sizes.i zclose.i zcoord.i
+makepdb.o: atmtyp.i atoms.i couple.i files.i molcul.i pdb.i resdue.i sequen.i sizes.i
+makeref.o: atmtyp.i atoms.i couple.i files.i refer.i sizes.i titles.i
+makexyz.o: atoms.i sizes.i zcoord.i
+maxwell.o: units.i
+mdinit.o: atmtyp.i atoms.i bath.i bound.i files.i group.i inform.i iounit.i keys.i mdstuf.i molcul.i moldyn.i qmmm.i rgddyn.i rigid.i shake.i sizes.i stodyn.i units.i usage.i
+mdrest.o: atmtyp.i atoms.i bound.i group.i inform.i iounit.i mdstuf.i moldyn.i rgddyn.i sizes.i units.i
+mdsave.o: atmtyp.i atoms.i bound.i boxes.i files.i group.i inform.i iounit.i mdstuf.i moldyn.i mpole.i output.i polar.i potent.i rgddyn.i sizes.i socket.i titles.i units.i
+mdstat.o: atoms.i bath.i bound.i boxes.i cutoff.i inform.i inter.i iounit.i mdstuf.i molcul.i sizes.i units.i usage.i warp.i
+mechanic.o: cutoff.i inform.i iounit.i potent.i vdwpot.i
+merge.o: atmtyp.i atoms.i couple.i iounit.i refer.i sizes.i
+minimize.o: atoms.i files.i inform.i iounit.i keys.i scales.i sizes.i usage.i
+minirot.o: files.i inform.i iounit.i keys.i math.i omega.i scales.i sizes.i zcoord.i
+minrigid.o: files.i group.i inform.i iounit.i keys.i math.i output.i rigid.i sizes.i
+mmpole.o: argue.i atmtyp.i atoms.i bound.i couple.i energi.i files.i group.i inform.i iounit.i mpole.i potent.i qmmm.i scales.i sizes.i units.i usage.i
+molecule.o: atmtyp.i atoms.i couple.i molcul.i qmmm.i sizes.i
+moments.o: atmtyp.i atoms.i charge.i dipole.i moment.i mpole.i polar.i potent.i sizes.i solute.i units.i usage.i
+monte.o: atoms.i files.i inform.i iounit.i omega.i output.i sizes.i units.i usage.i zcoord.i
+mutate.o: atmtyp.i atoms.i iounit.i katoms.i keys.i mutant.i sizes.i
+nblist.o: atoms.i bound.i boxes.i charge.i cutoff.i iounit.i light.i mpole.i neigh.i potent.i sizes.i vdw.i
+newton.o: atoms.i files.i inform.i iounit.i keys.i sizes.i usage.i
+newtrot.o: files.i hescut.i inform.i iounit.i keys.i math.i omega.i sizes.i zcoord.i
+nextarg.o: argue.i
+nexttext.o:
+nspline.o:
+nucleic.o: atoms.i couple.i files.i group.i inform.i iounit.i katoms.i kgeoms.i math.i molcul.i nucleo.i output.i potent.i resdue.i rigid.i sequen.i sizes.i titles.i usage.i
+number.o: inform.i iounit.i
+numeral.o:
+numgrad.o: atoms.i sizes.i
+ocvm.o: inform.i iounit.i keys.i linmin.i math.i minima.i output.i potent.i scales.i sizes.i
+openend.o:
+optimize.o: atoms.i files.i inform.i iounit.i keys.i scales.i sizes.i usage.i
+optirot.o: files.i inform.i iounit.i keys.i math.i omega.i scales.i sizes.i zcoord.i
+optrigid.o: files.i group.i inform.i iounit.i keys.i math.i output.i rigid.i sizes.i
+optsave.o: atoms.i files.i iounit.i math.i omega.i output.i scales.i sizes.i socket.i usage.i zcoord.i
+orbital.o: atmtyp.i atoms.i bond.i couple.i iounit.i keys.i piorbs.i potent.i sizes.i tors.i
+orient.o: atmtyp.i atoms.i group.i math.i rigid.i sizes.i
+orthog.o:
+overlap.o: units.i
+path.o: align.i atmtyp.i atoms.i files.i inform.i iounit.i linmin.i minima.i output.i paths.i sizes.i
+pdbxyz.o: atmtyp.i atoms.i couple.i fields.i files.i inform.i iounit.i katoms.i pdb.i resdue.i sequen.i sizes.i
+piscf.o: atmtyp.i atoms.i bond.i border.i couple.i inform.i iounit.i orbits.i piorbs.i pistuf.i sizes.i tors.i units.i
+pmepol.o: atoms.i boxes.i mpole.i pme.i sizes.i
+pmpb.o:
+polarize.o: atoms.i inform.i iounit.i molcul.i mpole.i polar.i polgrp.i polpot.i potent.i sizes.i units.i
+poledit.o: atmtyp.i atoms.i couple.i dma.i files.i iounit.i keys.i kpolr.i mpole.i polar.i polgrp.i polpot.i potent.i sizes.i units.i
+polymer.o: atoms.i bond.i bound.i boxes.i iounit.i keys.i sizes.i
+potential.o: atmtyp.i atoms.i charge.i chgpot.i dipole.i files.i inform.i iounit.i keys.i math.i minima.i moment.i mpole.i output.i polar.i potent.i potfit.i sizes.i titles.i units.i
+precise.o:
+pressure.o: atmtyp.i atoms.i bath.i bound.i boxes.i group.i math.i mdstuf.i molcul.i sizes.i units.i usage.i virial.i
+prmedit.o: angpot.i bndpot.i iounit.i math.i params.i sizes.i urypot.i vdwpot.i
+prmkey.o: angpot.i bndpot.i chgpot.i fields.i mplpot.i polpot.i potent.i rxnpot.i sizes.i torpot.i urypot.i vdwpot.i
+promo.o: iounit.i
+protein.o: atmtyp.i atoms.i couple.i files.i group.i inform.i iounit.i katoms.i kgeoms.i math.i molcul.i output.i phipsi.i potent.i resdue.i rigid.i sequen.i sizes.i titles.i usage.i
+prtdyn.o: atoms.i boxes.i files.i group.i mdstuf.i moldyn.i rgddyn.i sizes.i titles.i
+prterr.o: files.i output.i
+prtint.o: atmtyp.i atoms.i files.i inform.i sizes.i titles.i zclose.i zcoord.i
+prtmol2.o: atmtyp.i atoms.i bond.i couple.i files.i iounit.i sizes.i titles.i
+prtpdb.o: files.i pdb.i sequen.i sizes.i titles.i
+prtprm.o: angpot.i bndpot.i chgpot.i fields.i kanang.i kangs.i katoms.i kbonds.i kchrge.i kdipol.i khbond.i kiprop.i kitors.i kmulti.i kopbnd.i kopdst.i korbs.i kpitor.i kpolr.i kstbnd.i ksttor.i ktorsn.i ktrtor.i kurybr.i kvdwpr.i kvdws.i mplpot.i polpot.i sizes.i urypot.i vdwpot.i
+prtseq.o: files.i sequen.i sizes.i
+prtxyz.o: atmtyp.i atoms.i couple.i files.i inform.i qmmm.i sizes.i titles.i
+pss.o: atoms.i files.i hescut.i inform.i iounit.i math.i omega.i refer.i sizes.i tree.i warp.i zcoord.i
+pssrigid.o: atoms.i files.i group.i inform.i iounit.i math.i minima.i molcul.i refer.i rigid.i sizes.i warp.i
+pssrot.o: atoms.i files.i inform.i iounit.i math.i minima.i omega.i refer.i sizes.i warp.i zcoord.i
+qmmmsetup.o: atoms.i bath.i charge.i files.i inform.i iounit.i keys.i mdstuf.i qmmm.i sizes.i
+quatfit.o: align.i sizes.i
+radial.o: argue.i atmtyp.i atoms.i bound.i boxes.i cutoff.i files.i inform.i iounit.i math.i molcul.i potent.i sizes.i
+random.o: inform.i iounit.i keys.i math.i sizes.i
+rattle.o: atmtyp.i atoms.i group.i inform.i iounit.i moldyn.i shake.i sizes.i units.i usage.i virial.i
+readdyn.o: atoms.i boxes.i files.i group.i iounit.i mdstuf.i moldyn.i rgddyn.i sizes.i
+readgau.o: ascii.i iounit.i qmstuf.i sizes.i units.i
+readint.o: atmtyp.i atoms.i files.i inform.i iounit.i sizes.i titles.i zclose.i zcoord.i
+readmol2.o: atmtyp.i atoms.i couple.i files.i iounit.i sizes.i titles.i
+readpdb.o: files.i inform.i iounit.i pdb.i resdue.i sequen.i sizes.i titles.i
+readprm.o: fields.i iounit.i kanang.i kangs.i katoms.i kbonds.i kchrge.i kdipol.i khbond.i kiprop.i kitors.i kmulti.i kopbnd.i kopdst.i korbs.i kpitor.i kpolr.i kstbnd.i ksttor.i ktorsn.i ktrtor.i kurybr.i kvdwpr.i kvdws.i params.i sizes.i
+readseq.o: files.i iounit.i resdue.i sequen.i sizes.i
+readxyz2.o: atmtyp.i atoms.i couple.i files.i inform.i iounit.i qmmm.i sizes.i titles.i
+readxyz.o: atmtyp.i atoms.i couple.i files.i inform.i iounit.i qmmm.i sizes.i titles.i
+replica.o: bound.i boxes.i cell.i inform.i iounit.i sizes.i
+rgdstep.o: atmtyp.i atoms.i bound.i group.i iounit.i rgddyn.i sizes.i units.i virial.i
+rings.o: angle.i atoms.i bitor.i bond.i couple.i inform.i iounit.i ring.i sizes.i tors.i
+rmsfit.o: align.i sizes.i
+rotlist.o: atoms.i couple.i iounit.i molcul.i rotate.i sizes.i zclose.i
+rotpole.o: atoms.i mpole.i sizes.i
+runqm.o: argue.i atmtyp.i atoms.i charge.i deriv.i energi.i files.i group.i inform.i iounit.i potent.i qmmm.i sizes.i units.i usage.i
+saddle.o: atoms.i inform.i iounit.i keys.i linmin.i minima.i sizes.i syntrn.i titles.i zcoord.i
+scan.o: atoms.i files.i inform.i iounit.i math.i minima.i omega.i output.i sizes.i zcoord.i
+sdstep.o: atmtyp.i atoms.i bath.i couple.i kvdws.i math.i mdstuf.i moldyn.i shake.i sizes.i stodyn.i units.i usage.i virial.i
+search.o: linmin.i math.i sizes.i
+server.o:
+setime.o: chrono.i
+shakeup.o: angle.i atmlst.i atmtyp.i atoms.i bond.i bound.i couple.i keys.i math.i molcul.i ring.i shake.i sizes.i usage.i
+sigmoid.o:
+sktstuff.o: atmtyp.i atoms.i charge.i couple.i deriv.i fields.i files.i inform.i iounit.i keys.i moldyn.i mpole.i polar.i potent.i sizes.i socket.i
+sniffer.o: atoms.i files.i inform.i iounit.i linmin.i math.i minima.i output.i scales.i sizes.i usage.i
+sort.o:
+spacefill.o: atmtyp.i atoms.i files.i inform.i iounit.i kvdws.i math.i sizes.i usage.i
+spectrum.o: files.i iounit.i math.i units.i
+square.o: inform.i iounit.i keys.i minima.i sizes.i
+suffix.o: ascii.i
+superpose.o: align.i atmtyp.i atoms.i files.i inform.i iounit.i sizes.i titles.i
+surface.o: atoms.i inform.i iounit.i math.i sizes.i usage.i
+surfatom.o: atoms.i iounit.i math.i sizes.i
+switch.o: cutoff.i npolar.i shunt.i sizes.i
+sybylxyz.o: files.i iounit.i titles.i
+temper.o: atmtyp.i atoms.i bath.i group.i mdstuf.i moldyn.i rgddyn.i sizes.i units.i usage.i
+testgrad.o: atoms.i deriv.i energi.i inform.i inter.i iounit.i sizes.i solute.i usage.i
+testhess.o: atoms.i files.i hescut.i inform.i iounit.i sizes.i usage.i
+testpair.o: atoms.i cutoff.i deriv.i energi.i iounit.i light.i neigh.i potent.i sizes.i vdwpot.i
+testrot.o: domega.i energi.i inform.i iounit.i math.i omega.i sizes.i zcoord.i
+timer.o: cutoff.i hescut.i inform.i iounit.i sizes.i
+timerot.o: cutoff.i iounit.i sizes.i
+tkr2qm.o: analyz.i argue.i atmtyp.i atoms.i bath.i bond.i bound.i charge.i couple.i energi.i files.i group.i hescut.i inform.i iounit.i math.i mdstuf.i moldyn.i mpole.i polar.i potent.i qmmm.i scales.i sizes.i units.i usage.i
+tncg.o: hescut.i inform.i iounit.i keys.i linmin.i math.i minima.i output.i piorbs.i potent.i sizes.i
+torphase.o:
+torque.o: atoms.i deriv.i mpole.i sizes.i
+torsions.o: angle.i bond.i couple.i iounit.i qmmm.i sizes.i tors.i
+trimtext.o:
+unitcell.o: bound.i boxes.i iounit.i keys.i sizes.i
+valence.o: angle.i angpot.i atmtyp.i atoms.i bndpot.i bond.i couple.i files.i hescut.i inform.i iounit.i kangs.i kbonds.i keys.i kopbnd.i kstbnd.i ktorsn.i kurybr.i kvdws.i linmin.i math.i minima.i opbend.i output.i polpot.i potent.i qmstuf.i scales.i sizes.i strbnd.i torpot.i tors.i units.i urey.i urypot.i usage.i valfit.i vdwpot.i
+verlet.o: atmtyp.i atoms.i moldyn.i shake.i sizes.i units.i usage.i
+version.o: iounit.i output.i
+vibbig.o: atmtyp.i atoms.i bound.i couple.i cutoff.i files.i hescut.i hessn.i inform.i iounit.i keys.i mpole.i potent.i rigid.i sizes.i units.i usage.i vdw.i vdwpot.i
+vibrate.o: atmtyp.i atoms.i files.i hescut.i iounit.i math.i sizes.i units.i usage.i
+vibrot.o: iounit.i omega.i sizes.i
+volume.o: atoms.i iounit.i math.i sizes.i
+xtalfit.o: atmtyp.i atoms.i bound.i boxes.i charge.i couple.i dipole.i files.i fracs.i iounit.i kvdws.i math.i molcul.i potent.i sizes.i vdw.i xtals.i
+xtalmin.o: atoms.i boxes.i files.i inform.i iounit.i keys.i math.i scales.i sizes.i
+xyzatm.o: atoms.i inform.i iounit.i math.i sizes.i
+xyzedit.o: atmtyp.i atoms.i bond.i bound.i charge.i couple.i cutoff.i fields.i files.i iounit.i math.i molcul.i potent.i qmmm.i refer.i sizes.i titles.i units.i usage.i
+xyzint.o: files.i iounit.i titles.i
+xyzpdb.o: files.i inform.i
+xyzsybyl.o: files.i iounit.i sizes.i titles.i
+zatom.o: atmtyp.i atoms.i fields.i iounit.i katoms.i sizes.i zclose.i zcoord.i
diff -abuN source/mdinit.f source_distrib/mdinit.f
--- source/mdinit.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/mdinit.f	2010-08-26 11:38:23.000000000 +0200
@@ -37,6 +37,9 @@
       include 'stodyn.i'
       include 'units.i'
       include 'usage.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,idyn
       integer size,next
       integer lext,freeunit
@@ -224,7 +227,7 @@
       dynfile = filename(1:leng)//'.dyn'
       call version (dynfile,'old')
       inquire (file=dynfile,exist=exist)
-      if (exist) then
+      if (exist .and. (mmmdmode .eq. 0)) then
          idyn = freeunit ()
          open (unit=idyn,file=dynfile,status='old')
          rewind (unit=idyn)
@@ -294,6 +297,8 @@
             inquire (file=dynfile,exist=exist)
          end if
       end do
+cqmmm 
+      if (mmmdmode .ne. 0) i = 1
       nprior = i - 1
       return
       end
diff -abuN source/mdsave.f source_distrib/mdsave.f
--- source/mdsave.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/mdsave.f	2010-08-26 11:38:22.000000000 +0200
@@ -112,6 +112,7 @@
       end if
       call prtxyz (ixyz)
       close (unit=ixyz)
+      call avgmd(xyzfile)
       write (iout,70)  xyzfile(1:trimtext(xyzfile))
    70 format (' Coordinate File',12x,a)
 c
diff -abuN source/mdstuf.i source_distrib/mdstuf.i
--- source/mdstuf.i	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/mdstuf.i	2010-08-26 11:38:21.000000000 +0200
@@ -17,11 +17,14 @@
 c     frcsave     flag to save force vector components to a file
 c     uindsave    flag to save induced atomic dipoles to a file
 c     integrate   type of molecular dynamics integration algorithm
+c     rmsdchk     MD geometry RMSD converged?
+c     potchk      MD electrostatic potential converged?
 c
 c
       integer nfree
       logical velsave
       logical frcsave
-      logical uindsave
+      logical uindsave,potchk,rmsdchk
       character*10 integrate
-      common /mdstuf/ nfree,velsave,frcsave,uindsave,integrate
+      common /mdstuf/ nfree,velsave,frcsave,uindsave,potchk,
+     &       rmsdchk,integrate
diff -abuN source/mmpole.f source_distrib/mmpole.f
--- source/mmpole.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/mmpole.f	2010-08-26 11:38:26.000000000 +0200
@@ -0,0 +1,331 @@
+cqmmm
+c     It's a hack of the Tinker's empole program.
+c     It remains almost nothing from the original program !
+c     Fabien Archambault (March 2007)
+c
+c     ##############################################################
+c     ##                                                          ##
+c     ##  program MMPole -- tinker's part of a qm/mm calculation  ##
+c     ##                                                          ##
+c     ##############################################################
+c
+c     "MMPole" performs the mm part of a qm/mm calculation, i.e calculates
+c     energy and gradients:
+c       - between mm atoms for electrostatic interactions ;
+c       - between atoms with at least one mm atom for other interactions.
+c     Also returns the electrostatic potential (and derivatives) on 
+c     QM atoms.
+c     This program is built to be called from Molcas6 or Gaussian03,
+c     but could be used - in principle - by any external program,
+c     provided that it is able to write/read the informations stored
+c     in the file 'foo.qmmm'.
+c
+c     The xyz and key files are supposed to be correct at the beginning
+c     of the run.
+c
+      Program MMPole
+      implicit none
+      include 'sizes.i'
+      include 'atmtyp.i'
+      include 'atoms.i'
+      include 'argue.i'
+      include 'energi.i'
+      include 'iounit.i'
+      include 'units.i'
+      include 'usage.i'
+      include 'files.i'
+      include 'group.i'
+      include 'inform.i'
+      include 'potent.i'
+      include 'mpole.i'
+      include 'qmmm.i'
+      include 'scales.i'
+      include 'couple.i'
+      include 'bound.i'
+      integer imin,freeunit,next,i,j,kk,iy,k,l
+      integer ii,ic,imm
+      character*60 minfile
+      character*120 title,keyword,record,string
+      real*8 xtmp,ytmp,ztmp,qtmp,muxtmp,muytmp,muztmp
+      real*8 chgtmp(maxy),derivs(3,maxatm)
+      real*8 minimum,energy,atchmm
+      real*8 epf,epg(3),eph(6)
+      logical found,exist
+c
+c     Initialization
+c
+      call initial
+      call getxyz
+      call mechanic
+c
+c     Some checkings
+c
+      do i = 1, n
+         if (qmmm(i) .eq. 0 .and. atinqm(i) .ne. 0 .and. use_mpole) then
+            write (iout,*) 'MMPOLE -- cannot include a multipolar MM ',
+     &        'atom in the QM input'
+         end if
+      end do
+c
+c     Reads coordinates coming from the QM code.
+c     Reads point charges and dipoles.
+c     Must be in a file named foo.qmmm
+c
+      imin = freeunit()
+      minfile = filename(1:leng)//'.qmmm'
+      inquire (file=minfile,exist=found)
+      if (.not.found) goto 26
+      open (unit=imin,file=minfile,status='old')
+      rewind (unit=imin)
+      read (imin,10,end=23,err=24) title
+   10 format(a120)
+      next = 1
+      call gettext (title,keyword,next)
+      call upcase(keyword)
+      if (keyword(1:10) .eq. 'GAUSSIAN03' .or.
+     &    keyword(1:6)  .eq. 'MOLCAS') then
+c Reading the coordinates
+         do j = 1, nbinqm
+            xtmp = 1.0d10
+            ytmp = 1.0d10
+            ztmp = 1.0d10
+            read (imin,11,end=23,err=24) xtmp, ytmp, ztmp
+   11       format(3f15.8)
+            i = 0
+   12       i = i + 1
+            if (i .lt. n .and. atinqm(i) .ne. j) goto 12
+            if (atinqm(i) .eq. j) then
+               x(i) = xtmp
+               y(i) = ytmp
+               z(i) = ztmp
+            else
+               write (iout,13) j
+   13          format(' MMPOLE -- ',i3,'th QM atom has no Tinker ',
+     &                ' equivalent')
+               call fatal
+               if (verbose) write (iout,14) i,x(i),y(i),z(i)
+   14                       format(i4,3F15.6)
+            end if
+         enddo
+c /Reading coordinates
+c Reading multipoles
+         read (imin,15,end=23,err=24) record
+   15    format(a120)
+         next = 1
+         call gettext (record,keyword,next)
+         call upcase(keyword)
+         if (keyword(1:10) .eq. 'MULTIPOLES') then
+   16       read (imin,15,end=23,err=24) record
+            qtmp = 0.0d0
+            muxtmp = 0.0d0
+            muytmp = 0.0d0
+            muztmp = 0.0d0
+            next = 1
+            read (record,'(i6,4f15.8)') j,qtmp,muxtmp,muytmp,muztmp
+            i = 0
+   17       i = i + 1
+            if (i .lt. n .and. atinqm(i) .ne. j) goto 17
+c Case 1: this is a QM atom, its MM charge & dipole must be updated
+            if (atinqm(i) .eq. j .and. qmmm(i).ne.0) then
+               do k = 1, npole
+                  kk = ipole(k)
+                  if (i .eq. kk) then
+                     if (qmmm(i) .eq. 3) then
+                        iy = iy + 1
+                        chgtmp(iy) = pole(1,k)
+                     end if
+                     pole(1,k) = qtmp
+                     pole(2,k) = muxtmp
+                     pole(3,k) = muytmp
+                     pole(4,k) = muztmp
+                     do l = 5, maxpole
+                        pole(l,k) = 0.0d0
+                     enddo
+                     if (verbose) write (iout,18) i,pole(1,k),pole(2,k)
+     &                                            ,pole(3,k),pole(4,k)
+   18                format(' New QM point charge value for atom ',i4,
+     &                      ' = ',f15.8,/,'    New Dipole is : ',3f15.8)
+                  end if
+               end do
+c Case 2: this is a MM atom, its MM charge & dipole does not change
+            else if (atinqm(i) .eq. j .and. qmmm(i) .eq. 0) then
+               if (verbose) write (iout,19) i
+   19          format(i4,' is a MM atom, its charge & dipoles ',
+     &                   'components remain the same.')
+c Case 3: bug in the input
+            else
+               write (iout,20) j
+   20          format(' TKR2QM -- ',i3,'th QM atom has no Tinker ',
+     &                ' equivalent or is defined like a MM atom')
+               call fatal
+            end if
+            goto 16
+c /Reading multipoles
+c Error lines
+         else
+            write (iout,21) keyword(1:10)
+   21       format(/,' Error when reading ',a10,/,
+     &               ' Must be MULTIPOLES !',/)
+            call fatal
+      end if
+      else
+         write (iout,22) keyword(1:10)
+   22    format(/,' Error when reading ',a10,/,
+     &            ' Must be GAUSSIAN03 or MOLCAS !',/)
+         call fatal
+      endif
+   23 close (unit=imin)
+      goto 28
+   24 write (iout,25) minfile,string
+   25 format(/,' Error when reading ',a60,/,' Last string was: ',/,a120)
+      call fatal
+   26 write (iout,27) minfile
+   27 format(/,' MMPole -- File not found: ',a60)
+   28 continue
+c /Error lines
+c
+c     Compute the MM component of the QM/MM energy (excluding
+c     electrostatic interactions).
+c
+c     WARNING : also some MM/MM interactions must be discarded
+c     if the ESPF method is used !!!
+c
+      e4qmmm = 0
+      do i = 1, n
+         use(i) = use(i).or.atinqm(i).ne.0
+      end do
+c      iy = 0
+c      do i = 1, npole
+c         k = ipole(i)
+c         if (qmmm(k) .eq. 3) then
+c            iy = iy + 1
+c            pole(1,i) = chgtmp(iy)
+c         end if
+c      end do
+c
+c     Components of MM energy
+c
+      if (debug) then
+         write (iout,30)
+   30    format (/,' Analysis before energy')
+         call analysis(minimum)
+      end if
+c
+c     MM energy and gradients
+c
+      call gradient (energy,derivs)
+      if (verbose) then
+         write (iout,31) energy
+   31    format(/,' Full MM part of the QM/MM energy: ',2x,f20.8)
+         write(iout,'(/)')
+      end if
+      if (debug) then
+         do imm = 1, n
+            write(iout,32) imm,derivs(1,imm),derivs(2,imm),derivs(3,imm)
+   32       format(' Gradient on atom ',i5,' = ',3f20.8)
+         end do
+      endif
+      write(iout,'(/,A)') ' MM energy components passed:'
+      if(eb  .ne.0.0d0) write(iout,39) ' eb   = ',eb  /hartree,eb
+      if(ea  .ne.0.0d0) write(iout,39) ' ea   = ',ea  /hartree,ea  
+      if(eba .ne.0.0d0) write(iout,39) ' eba  = ',eba /hartree,eba 
+      if(eub .ne.0.0d0) write(iout,39) ' eub  = ',eub /hartree,eub 
+      if(eaa .ne.0.0d0) write(iout,39) ' eaa  = ',eaa /hartree,eaa 
+      if(eopb.ne.0.0d0) write(iout,39) ' eopb = ',eopb/hartree,eopb
+      if(eopd.ne.0.0d0) write(iout,39) ' eopd = ',eopd/hartree,eopd
+      if(eid .ne.0.0d0) write(iout,39) ' eid  = ',eid /hartree,eid 
+      if(eit .ne.0.0d0) write(iout,39) ' eit  = ',eit /hartree,eit 
+      if(et  .ne.0.0d0) write(iout,39) ' et   = ',et  /hartree,et  
+      if(ebt .ne.0.0d0) write(iout,39) ' ebt  = ',ebt /hartree,ebt 
+      if(ett .ne.0.0d0) write(iout,39) ' ett  = ',ett /hartree,ett 
+      if(ev  .ne.0.0d0) write(iout,39) ' ev   = ',ev  /hartree,ev  
+      if(ec  .ne.0.0d0) write(iout,39) ' ec   = ',ec  /hartree,ec  
+      if(ecd .ne.0.0d0) write(iout,39) ' ecd  = ',ecd /hartree,ecd 
+      if(ed  .ne.0.0d0) write(iout,39) ' ed   = ',ed  /hartree,ed  
+      if(em  .ne.0.0d0) write(iout,39) ' em   = ',em  /hartree,em  
+      if(ep  .ne.0.0d0) write(iout,39) ' ep   = ',ep  /hartree,ep  
+      if(er  .ne.0.0d0) write(iout,39) ' er   = ',er  /hartree,er  
+      if(es  .ne.0.0d0) write(iout,39) ' es   = ',es  /hartree,es  
+      if(elf .ne.0.0d0) write(iout,39) ' elf  = ',elf /hartree,elf 
+      if(eg  .ne.0.0d0) write(iout,39) ' eg   = ',eg  /hartree,eg  
+      if(ex  .ne.0.0d0) write(iout,39) ' ex   = ',ex  /hartree,ex  
+   39 format(A,F15.8,' ua = ',F15.8,' kcal/mol')
+c
+c     Compute the electrostatic potential (and derivatives)
+c     on the QM atoms.
+c     Output the results in foo.qmmm
+c     All data are *not* converted to atomic units
+c
+      imin = freeunit ()
+      minfile = filename(1:leng)//'.qmmm'
+      open (unit=imin,file=minfile,status='unknown')
+      rewind (unit=imin)
+c
+c     Writes the energy, the coordinates, the forces and the partial charges.
+c
+      write (imin,'(A7)') 'TKPolar'
+      write (imin,42) energy
+   42 format ('TKEnergy    ',f20.8)
+      iy = 0
+      j = 0
+      do imm = 1, n
+         i = atinqm(imm)
+         if (i.ne.0) then
+            write (imin,43) i,x(imm),y(imm),z(imm)
+   43       format ('TKCoords    ',i5,3f20.8)
+            write (imin,44) i,derivs(1,imm),derivs(2,imm),derivs(3,imm)
+   44       format ('TKGradient  ',i5,3f20.8)
+            atchmm = 0.0d0
+            do ii = 1, npole
+               ic = ipole(ii)
+               if (imm.eq.ic .and. qmmm(imm) .eq. 3) then
+                  iy = iy + 1
+                  atchmm = chgtmp(iy)
+               end if
+               if (.not. use_mpole) atchmm = 0.0d0
+            end do
+            write (imin,45) i,atchmm
+   45       format ('TKActPChg   ',i5,f20.8)
+            call elecpol(imm,epf,epg,eph)
+            write(imin,46) i,epf,epg(1),epg(2),epg(3)
+   46       format ('TKESPF1     ',i5,4f20.8)
+            write(imin,47) i,eph(1),eph(2),eph(3)
+   47       format ('TKESPF21    ',i5,3f20.8)
+            write(imin,48) i,eph(4),eph(5),eph(6)
+   48       format ('TKESPF22    ',i5,3f20.8)
+            if (verbose) then
+               write(iout,'(/,A,I5)') ' Ext. Pot. on Tinker atom ',imm
+               write(iout,40) ' V= ',epf   
+               write(iout,41) ' X= ',epg(1),
+     &                        ' Y= ',epg(2),
+     &                        ' Z= ',epg(3)
+               write(iout,41) ' XX=',eph(1),
+     &                        ' XY=',eph(2),
+     &                        ' XZ=',eph(3)
+               write(iout,41) ' YY=',eph(4),
+     &                        ' YZ=',eph(5),
+     &                        ' ZZ=',eph(6)
+   40          format(A,F10.5)
+   41          format(3(A,F10.5))
+            end if
+            if (qmmm(imm) .eq. 1) then
+               j = j + 1
+               if (lahg(j) .le. 0.0d0) then
+                 lahg(j) = (rcov(atomic(i12(2,i)))+rcov(atomic(i)))/
+     &                   (rcov(atomic(i12(2,i)))+rcov(atomic(i12(1,i))))
+               end if
+               write (imin,49) i,(atinqm(i12(k,imm)),k=1,2),lahg(j)
+  49           format('TKLAH       ',3i5,f6.3)
+            end if
+         end if
+      end do
+      write(imin,'(A5)') 'TKEnd'
+      close (unit=imin)
+c      
+c
+c     perform any final tasks before program exit
+c
+      write(iout,9999)
+9999  format (/,' End of this Tinker run',//)
+      call final
+      end
diff -abuN source/molecule.f source_distrib/molecule.f
--- source/molecule.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/molecule.f	2010-08-26 11:38:21.000000000 +0200
@@ -23,6 +23,7 @@
       include 'atoms.i'
       include 'couple.i'
       include 'molcul.i'
+      include 'qmmm.i'
       integer i,j,k
       integer mi,mj,mk
       integer iattach
@@ -74,6 +75,15 @@
          end do
       end do
 c
+c     QM/MM link atom case
+c
+      do i = 1, n
+         if (qmmm(i) .eq. 1) then
+            molcule(i) = molcule(i12(2,i))
+            nmol = nmol - 1
+         end if
+      end do
+c
 c     pack atoms of each molecule into a contiguous indexed list
 c
       do i = 1, n
diff -abuN source/pmpb.c source_distrib/pmpb.c
--- source/pmpb.c	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/pmpb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1123 +0,0 @@
-
-/*
- * Note: The "routines.h" header file includes apbscfg.h, which
- * defines WITH_TINKER. And WITH_TINKER turns on function prototypes
- * in the headers included within "apbs.h". Therefore, "routines.h"
- * needs to be listed first to avoid implicit function definitons.
- */
-
-#include "apbs/routines.h"
-#include "apbs/apbs.h"
-
-/*
- * Note: Use the -Qlowercase flag to deal with Intel
- * Fortran Compiler name mangling on Windows.
- *
- * Underscores are used by default on Linux and MacOSX,
- * but not on Windows.
- *
- * We define aliases below to allow TINKER's Fortran code to
- * call the C routines in this file when linking on Windows.
- */
-
-#ifdef _WIN32
-#define apbsinitial_ apbsinitial
-#define apbsempole_ apbsempole
-#define apbsinduce_ apbsinduce
-#define apbsnlinduce_ apbsnlinduce
-#define pbdirectpolforce_ pbdirectpolforce
-#define pbmutualpolforce_ pbmutualpolforce
-#define apbsfinal_ apbsfinal
-#endif
-
-/***********************************************************************
-  Below are some global variables that are saved between APBS calls.
-  There may be a better way to do this, although passing pointers
-  into FORTRAN should be avoided.
-***********************************************************************/
-
-// TINKER MAXATM paramter
-#define maxatm 20000
-
-// TINKER and APBS both define maxion to be 10
-#define maxion 10
-
-// APBS configuration objects
-Vmem *mem = VNULL;
-Vcom *com = VNULL;
-Vio *sock = VNULL;
-NOsh *nosh = VNULL;
-
-// atom list
-Valist *alist[NOSH_MAXMOL];
-
-// potential solutions saved for polarization force calculation
-Vgrid *permU[2];
-Vgrid *indU[2];
-Vgrid *nlIndU[2];
-
-// kappa and dielectric Vgrids (for homogeneous and solvated states)
-Vgrid *dielXMap[NOSH_MAXMOL];
-Vgrid *dielYMap[NOSH_MAXMOL];
-Vgrid *dielZMap[NOSH_MAXMOL];
-Vgrid *kappaMap[NOSH_MAXMOL];
-Vgrid *chargeMap[NOSH_MAXMOL];
-double realCenter[3];
-
-/***********************************************************************
-  apbsinitial is called from TINKER to:
-
-  (1) Initialize APBS Vcom, Vmem and NOsh objects
-  (2) Create a "virtual" APBS input file and parse it
-***********************************************************************/
-
-void apbsinitial_(int dime[3], double grid[3], double gcent[3],
-                  double cgrid[3], double cgcent[3],
-                  double fgrid[3], double fgcent[3],
-                  double *pdie, double *sdie,
-                  double *srad, double *swin,
-                  double *sdens, double *kelvin,
-                  int *ionn, double ionc[maxion],
-                  int ionq[maxion], double ionr[maxion],
-                  char *pbtypef, int *pbtypelen,
-                  char *pbsolnf, int *pbsolnlen,
-                  char *bcflf, int *bcfllen,
-                  char *chgmf, int *chgmlen,
-                  char *srfmf, int *srfmlen,
-                  int fortranAppendedPbtypeLen,
-                  int fortranAppendedPbsolnLen,
-                  int fortranAppendedBfclLen,
-                  int fortranAppendedChgmLen,
-                  int fortranAppendedSrfmLen) {
-
-    /* All character strings passed from FORTRAN result in an integer
-       appended to the list of arguments, each equal to the static
-       length specified in the TINKER common block 'pb.i' (20).
-
-       Further below the FORTRAN strings will be converted into
-       null terminated C-strings.
-    */
-    char pbtype[21]; // lpbe
-    char pbsoln[21]; // mg-manual or mg-auto
-    char bcfl[21];   // zero, sdh, mdh
-    char chgm[21];   // spl4
-    char srfm[21];   // mol, smol, spl2
-
-    /* Bogus argc and argv variables used for Vcom constructor. */
-    int argc = 0;
-    char **argv;
-
-    /* CPU info */
-    int rank, size;
-
-    /* APBS "input file" is a character buffer */
-    char  buff[4096];
-    char  tmp[1024];
-
-    /* Loop index */
-    int i;
-
-    /* Start the timer - although keep in mind it is not stopped until
-       apbsfinal is called.  */
-    Vnm_tstart(APBS_TIMER_WALL_CLOCK, "APBS WALL CLOCK");
-
-    /* Convert FORTRAN strings to null-terminated C-String */
-    strncpy(pbtype, pbtypef, *pbtypelen);
-    strncpy(pbsoln, pbsolnf, *pbsolnlen);
-    strncpy(bcfl, bcflf, *bcfllen);
-    strncpy(chgm, chgmf, *chgmlen);
-    strncpy(srfm, srfmf, *srfmlen);
-    pbtype[*pbtypelen] = '\0';
-    pbsoln[*pbsolnlen] = '\0';
-    bcfl[*bcfllen] = '\0';
-    chgm[*chgmlen] = '\0';
-    srfm[*srfmlen] = '\0';
-
-    /* Rather than require an APBS input file, a character buffer is
-       loaded with two ELEC statements:
-
-       (1) The homogeneous calculation.
-       (2) The solvated calculation.
-
-       Many options for partial charge systems are not yet supported
-       for AMOEBA (or are not appropriate). The subset of ELEC options
-       that can be modified are configured using TINKER keywords.
-
-       Initialization of the "nosh" input data structure then proceeds
-       using the buffer data. If the syntax of the ELEC statement changes,
-       then corresponding changes will be needed to be made below.
-     */
-
-    /* Homogeneous */
-    strcpy(buff,"ELEC NAME HOMOGENEOUS\n");
-    sprintf(tmp,"\t%s\n",pbsoln);
-    strcat(buff,tmp);
-    sprintf(tmp,"\t%s\n",pbtype);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tDIME\t%3i %3i %3i\n",dime[0],dime[1],dime[2]);
-    strcat(buff,tmp);
-    // MG-AUTO
-    if (strcmp(pbsoln,"MG-AUTO") == 0) {
-       sprintf(tmp,"\tCGLEN  %10.6f %10.6f %10.6f\n",
-                      dime[0]*cgrid[0], dime[1]*cgrid[1], dime[2]*cgrid[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tCGCENT %10.6f %10.6f %10.6f\n",
-                      cgcent[0], cgcent[1],cgcent[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tFGLEN  %10.6f %10.6f %10.6f\n",
-                      dime[0]*fgrid[0], dime[1]*fgrid[1], dime[2]*fgrid[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tFGCENT %10.6f %10.6f %10.6f\n",
-                      fgcent[0], fgcent[1], fgcent[2]);
-       strcat(buff,tmp);
-    } else { // MG-MANUAL
-       sprintf(tmp,"\tGLEN  %10.6f %10.6f %10.6f\n",
-                      dime[0]*grid[0], dime[1]*grid[1], dime[2]*grid[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tGCENT %10.6f %10.6f %10.6f\n",
-                      gcent[0], gcent[1], gcent[2]);
-       strcat(buff,tmp);
-    }
-    strcat(buff,"\tMOL\t1\n");
-    sprintf(tmp,"\tBCFL\t%s\n", bcfl);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tPDIE  %10.6f\n", *pdie);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSDIE  %10.6f\n", *pdie);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tCHGM\t%s\n", chgm);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSRFM\t%s\n", srfm);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSRAD  %10.6f\n", *srad);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSWIN  %10.6f\n", *swin);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSDENS %10.6f\n", *sdens);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tTEMP  %10.6f\n", *kelvin);
-    strcat(buff,tmp);
-    strcat(buff,"END\n\n");
-
-    /* Solvated */
-    strcat(buff,"ELEC NAME SOLVATED\n");
-    sprintf(tmp,"\t%s\n",pbsoln);
-    strcat(buff,tmp);
-    sprintf(tmp,"\t%s\n",pbtype);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tDIME\t%3i %3i %3i\n",dime[0],dime[1],dime[2]);
-    strcat(buff,tmp);
-    // MG-AUTO
-    if (strcmp(pbsoln,"MG-AUTO") == 0) {
-       sprintf(tmp,"\tCGLEN  %10.6f %10.6f %10.6f\n",
-                      dime[0]*cgrid[0], dime[1]*cgrid[1], dime[2]*cgrid[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tCGCENT %10.6f %10.6f %10.6f\n",
-                      cgcent[0], cgcent[1], cgcent[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tFGLEN  %10.6f %10.6f %10.6f\n",
-                      dime[0]*fgrid[0], dime[1]*fgrid[1], dime[2]*fgrid[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tFGCENT %10.6f %10.6f %10.6f\n",
-                      fgcent[0], fgcent[1], fgcent[2]);
-       strcat(buff,tmp);
-    } else { // MG-MANUAL
-       sprintf(tmp,"\tGLEN  %10.6f %10.6f %10.6f\n",
-                      dime[0]*grid[0], dime[1]*grid[1], dime[2]*grid[2]);
-       strcat(buff,tmp);
-       sprintf(tmp,"\tGCENT %10.6f %10.6f %10.6f\n",
-                      gcent[0], gcent[1], gcent[2]);
-       strcat(buff,tmp);
-    }
-    strcat(buff,"\tMOL\t1\n");
-    sprintf(tmp,"\tBCFL\t%s\n", bcfl);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tPDIE  %10.6f\n", *pdie);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSDIE  %10.6f\n", *sdie);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tCHGM\t%s\n", chgm);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSRFM\t%s\n", srfm);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSRAD  %10.6f\n", *srad);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSWIN  %10.6f\n", *swin);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tSDENS %10.6f\n", *sdens);
-    strcat(buff,tmp);
-    sprintf(tmp,"\tTEMP  %10.6f\n", *kelvin);
-    strcat(buff,tmp);
-    for (i=0; i < *ionn; i++) {
-       sprintf(tmp,"\tION\t%2i %10.6f %10.6f\n", ionq[i], ionc[i], ionr[i]);
-       strcat(buff,tmp);
-    }
-    strcat(buff,"END\n");
-    strcat(buff,"\nQUIT\n");
-
-    /* Misc. initializations */
-    for (i=0; i<NOSH_MAXMOL; i++) {
-       alist[i] = VNULL;
-       dielXMap[i] = VNULL;
-       dielYMap[i] = VNULL;
-       dielZMap[i] = VNULL;
-       kappaMap[i] = VNULL;
-       chargeMap[i] = VNULL;
-    }
-    for (i=0; i<2; i++) {
-       permU[i] = VNULL;
-       indU[i] = VNULL;
-       nlIndU[i] = VNULL;
-    }
-
-    /* Initialization of Vcom, Vmem, and Nosh (via Vio). */
-    VASSERT(Vcom_init(&argc, &argv));
-    com = Vcom_ctor(1);
-    rank = Vcom_rank(com);
-    size = Vcom_size(com);
-    startVio();
-    Vnm_setIoTag(rank, size);
-    mem = Vmem_ctor("MAIN");
-
-    /* Print (to io.mc) and then parse the input buffer. */
-    Vnm_tprint(0, "\n********* TINKER generated input buffer *********\n\n");
-    Vnm_tprint(0, "%s", buff);
-    Vnm_tprint(0, "\n*************************************************\n\n");
-    nosh = NOsh_ctor(rank, size);
-    sock = Vio_ctor("BUFF", "ASC", VNULL, "BUFFER", "r");
-    Vio_bufTake(sock, buff, strlen(buff));
-    if (!NOsh_parseInput(nosh, sock)) {
-       Vnm_tprint( 2, "Error while parsing input file.\n");
-       return;
-    }
-    /* Release the buffer and kill Vio */
-    Vio_bufGive(sock);
-    Vio_dtor(&sock);
-}
-
-/***********************************************************************
-  apbsempole is called from TINKER to:
-
-  (1) Solve the PBE using permanent multipoles as the source term
-  (2) Save the solution potential for polarization force calculation
-  (3) Return permanent electrostatic solvation values for: energy
-      field, forces and torques
-***********************************************************************/
-
-void apbsempole_(int *natom, double x[maxatm][3],
-                 double rad[maxatm], double rpole[maxatm][13],
-                 double *total,
-                 double energy[maxatm], double fld[maxatm][3],
-                 double rff[maxatm][3], double rft[maxatm][3]) {
-
-    /* Misc. pointers to APBS data structures */
-    Vpmg  *pmg[NOSH_MAXCALC];
-    Vpmgp *pmgp[NOSH_MAXCALC];
-    Vpbe  *pbe[NOSH_MAXCALC];
-    MGparm *mgparm = VNULL;
-    PBEparm *pbeparm = VNULL;
-    Vatom *atom = VNULL;
-
-    /* Vgrid configuration for the kappa and dielectric maps */
-    double nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin;
-    double *data;
-    double zkappa2, epsp, epsw;
-
-    /* Loop indeces */
-    int i,j;
-
-    /* Observables and unit conversion */
-    double sign, force[3], torque[3], field[3];
-    double kT,electric,debye;
-    double charge, dipole[3], quad[9];
-    debye = 4.8033324;
-
-    for (i=0; i<NOSH_MAXCALC; i++) {
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-    }
-
-    /* Kill the saved potential Vgrids */
-    for (i=0; i<2; i++){
-        if (permU[i] != VNULL) Vgrid_dtor(&permU[i]);
-        if (indU[i] != VNULL) Vgrid_dtor(&indU[i]);
-        if (nlIndU[i] != VNULL) Vgrid_dtor(&nlIndU[i]);
-    }
-    /* Kill the old atom list */
-    if (alist[0] != VNULL) {
-       Valist_dtor(&alist[0]);
-    }
-
-    /* Create a new atom list (mol == 1) */
-    if (alist[0] == VNULL) {
-       alist[0] = Valist_ctor();
-       alist[0]->atoms = Vmem_malloc(alist[0]->vmem, *natom, (sizeof(Vatom)));
-       alist[0]->number = *natom;
-    }
-
-    /* Read TINKER input data into Vatom instances. */
-    for (i=0; i < alist[0]->number; i++){
-       atom = Valist_getAtom(alist[0],i);
-       Vatom_setAtomID(atom, i);
-       Vatom_setPosition(atom, x[i]);
-       Vatom_setRadius(atom, rad[i]);
-       charge = rpole[i][0];
-       Vatom_setCharge(atom, charge);
-       dipole[0] = rpole[i][1];
-       dipole[1] = rpole[i][2];
-       dipole[2] = rpole[i][3];
-       Vatom_setDipole(atom, dipole);
-       quad[0] = rpole[i][4];
-       quad[1] = rpole[i][5];
-       quad[2] = rpole[i][6];
-       quad[3] = rpole[i][7];
-       quad[4] = rpole[i][8];
-       quad[5] = rpole[i][9];
-       quad[6] = rpole[i][10];
-       quad[7] = rpole[i][11];
-       quad[8] = rpole[i][12];
-       Vatom_setQuadrupole(atom, quad);
-       /* Useful check
-       printf(" %i %f (%f,%f,%f)\n",i,rad[i], x[i][0], x[i][1], x[i][2]);
-       printf(" %f\n %f,%f,%f\n", charge, dipole[0], dipole[1], dipole[2]);
-       printf(" %f\n", quad[0]);
-       printf(" %f %f\n", quad[3], quad[4]);
-       printf(" %f %f %f\n", quad[6], quad[7], quad[8]); */
-       energy[i] = 0.0;
-       for (j=0;j<3;j++){
-          fld[i][j] = 0.0;
-          rff[i][j] = 0.0;
-          rft[i][j] = 0.0;
-       }
-    }
-
-    nosh->nmol = 1;
-    Valist_getStatistics(alist[0]);
-
-    /* Only call the setupCalc routine once, so that we can
-       reuse this nosh object */
-
-    if (nosh->ncalc < 2) {
-       if (NOsh_setupElecCalc(nosh, alist) != 1) {
-          printf("Error setting up calculations\n");
-          exit(-1);
-       }
-    }
-
-    /* Solve the LPBE for the homogeneous and then solvated states */
-    for (i=0; i<2; i++) {
-
-       /* Useful local variables */
-       mgparm = nosh->calc[i]->mgparm;
-       pbeparm = nosh->calc[i]->pbeparm;
-
-       /* Just to be robust */
-       if (!MGparm_check(mgparm)){
-          printf("MGparm Check failed\n");
-          printMGPARM(mgparm, realCenter);
-          exit(-1);
-       }
-       if (!PBEparm_check(pbeparm)){
-          printf("PBEparm Check failed\n");
-          printPBEPARM(pbeparm);
-          exit(-1);
-       }
-
-       /* Set up the problem */
-       mgparm->chgs = VCM_PERMANENT;
-       if (!initMG(i, nosh, mgparm, pbeparm, realCenter, pbe,
-                   alist, dielXMap, dielYMap, dielZMap,
-                   kappaMap, chargeMap, pmgp, pmg)) {
-              Vnm_tprint( 2, "Error setting up MG calculation!\n");
-              return;
-       }
-
-       /* Solve the PDE */
-       if (solveMG(nosh, pmg[i], mgparm->type) != 1) {
-           Vnm_tprint(2, "Error solving PDE!\n");
-           return;
-       }
-
-       /* Set partition information for observables and I/O */
-       /* Note - parallel operation has NOT been tested. */
-       if (setPartMG(nosh, mgparm, pmg[i]) != 1) {
-           Vnm_tprint(2, "Error setting partition info!\n");
-           return;
-       }
-
-       nx = pmg[i]->pmgp->nx;
-       ny = pmg[i]->pmgp->ny;
-       nz = pmg[i]->pmgp->nz;
-       hx = pmg[i]->pmgp->hx;
-       hy = pmg[i]->pmgp->hy;
-       hzed = pmg[i]->pmgp->hzed;
-       xmin = pmg[i]->pmgp->xmin;
-       ymin = pmg[i]->pmgp->ymin;
-       zmin = pmg[i]->pmgp->zmin;
-
-       /* Save dielectric/kappa maps into Vgrids, then change the nosh
-        * data structure to think it read these maps in from a file.
-        * The goal is to save setup time during convergence of the
-        * induced dipoles. This is under consideration...
-        * */
-       /*
-       // X (shifted)
-       data = Vmem_malloc(mem, nx*ny*nz, sizeof(double));
-       Vpmg_fillArray(pmg[i], data, VDT_DIELX, 0.0, pbeparm->pbetype);
-       dielXMap[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,
-                                xmin + 0.5*hx,ymin,zmin,data);
-       dielXMap[i]->readdata = 1;
-       // Y (shifted)
-       data = Vmem_malloc(mem, nx*ny*nz, sizeof(double));
-       Vpmg_fillArray(pmg[i], data, VDT_DIELY, 0.0, pbeparm->pbetype);
-       dielYMap[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,
-                                      xmin,ymin + 0.5*hy,zmin,data);
-       dielYMap[i]->readdata = 1;
-       // Z (shifted)
-       data = Vmem_malloc(mem, nx*ny*nz, sizeof(double));
-       Vpmg_fillArray(pmg[i], data, VDT_DIELZ, 0.0, pbeparm->pbetype);
-       dielZMap[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,
-                                      xmin,ymin,zmin + 0.5*hzed,data);
-       dielZMap[i]->readdata = 1;
-       // Kappa
-       data = Vmem_malloc(mem, nx*ny*nz, sizeof(double));
-       Vpmg_fillArray(pmg[i], data, VDT_KAPPA, 0.0, pbeparm->pbetype);
-       kappaMap[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin,data);
-       kappaMap[i]->readdata = 1;
-
-       // Update the pbeparam structure, since we now have
-       // dielectric and kappap maps
-       pbeparm->useDielMap = 1;
-       pbeparm->dielMapID = i + 1;
-       pbeparm->useKappaMap = 1;
-       pbeparm->kappaMapID = i + 1;
-
-       */
-
-       data = Vmem_malloc(mem, nx*ny*nz, sizeof(double));
-       Vpmg_fillArray(pmg[i], data, VDT_POT, 0.0, pbeparm->pbetype);
-       permU[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin,data);
-       permU[i]->readdata = 1;
-       // set readdata flag to have the dtor to free data
-
-       if (i == 0){
-          sign = -1.0;
-       } else {
-          sign = 1.0;
-       }
-
-       /* Calculate observables */
-       for (j=0; j < alist[0]->number; j++){
-         energy[j] += sign * Vpmg_qfPermanentMultipoleEnergy(pmg[i], j);
-         Vpmg_fieldSpline4(pmg[i], j, field);
-         fld[j][0] += sign * field[0];
-         fld[j][1] += sign * field[1];
-         fld[j][2] += sign * field[2];
-       }
-
-       if (!pmg[i]->pmgp->nonlin &&
-          (pmg[i]->surfMeth == VSM_SPLINE ||
-           pmg[i]->surfMeth == VSM_SPLINE3 ||
-           pmg[i]->surfMeth == VSM_SPLINE4)) {
-          for (j=0; j < alist[0]->number; j++){
-            Vpmg_qfPermanentMultipoleForce(pmg[i], j, force, torque);
-            rff[j][0] += sign * force[0];
-            rff[j][1] += sign * force[1];
-            rff[j][2] += sign * force[2];
-            rft[j][0] += sign * torque[0];
-            rft[j][1] += sign * torque[1];
-            rft[j][2] += sign * torque[2];
-          }
-          kT = Vunit_kb * (1e-3) * Vunit_Na * 298.15 * 1.0/4.184;
-          epsp = Vpbe_getSoluteDiel(pmg[i]->pbe);
-          epsw = Vpbe_getSolventDiel(pmg[i]->pbe);
-          if (VABS(epsp-epsw) > VPMGSMALL) {
-             for (j=0; j < alist[0]->number; j++){
-                Vpmg_dbPermanentMultipoleForce(pmg[i], j, force);
-                rff[j][0] += sign * force[0];
-                rff[j][1] += sign * force[1];
-                rff[j][2] += sign * force[2];
-             }
-          }
-          zkappa2 = Vpbe_getZkappa2(pmg[i]->pbe);
-          if (zkappa2 > VPMGSMALL) {
-             for (j=0; j < alist[0]->number; j++) {
-                Vpmg_ibPermanentMultipoleForce(pmg[i], j, force);
-                rff[j][0] += sign * force[0];
-                rff[j][1] += sign * force[1];
-                rff[j][2] += sign * force[2];
-             }
-          }
-       }
-    }
-
-    //nosh->ndiel = 2;
-    //nosh->nkappa = 2;
-    /*
-    printf("Energy (multipole) %f Kcal/mol\n", *energy);
-    printf("Energy (volume)    %f Kcal/mol\n", evol * 0.5 * kT);
-    */
-
-    // Convert results into kcal/mol units
-    kT = Vunit_kb * (1e-3) * Vunit_Na * 298.15 * 1.0/4.184;
-    // Electric converts from electron**2/Angstrom to Kcal/mol
-    electric = 332.05382;
-    *total = 0.0;
-    for (i=0; i<alist[0]->number; i++){
-       /* starting with the field in KT/e/Ang^2 multiply by Kcal/mol/KT
-          the field is then divided by "electric" to convert to e/Ang^2 */
-       energy[i] *= 0.5 * kT;
-       *total += energy[i];
-       fld[i][0] *= kT / electric;
-       fld[i][1] *= kT / electric;
-       fld[i][2] *= kT / electric;
-       rff[i][0] *= kT;
-       rff[i][1] *= kT;
-       rff[i][2] *= kT;
-       rft[i][0] *= kT;
-       rft[i][1] *= kT;
-       rft[i][2] *= kT;
-    }
-
-    killMG(nosh, pbe, pmgp, pmg);
-}
-
-/***********************************************************************
-  apbsinduce is called from TINKER during SCRF convergence to:
-
-  (1) Solve the PBE given induced dipoles as the source term
-  (2) Save the solution potential for later polarization force calc
-  (3) Return the induced reaction field to TINKER
-***********************************************************************/
-
-void apbsinduce_(double uind[maxatm][3], double fld[maxatm][3]){
-
-    Vpmg  *pmg[NOSH_MAXCALC];
-    Vpmgp *pmgp[NOSH_MAXCALC];
-    Vpbe  *pbe[NOSH_MAXCALC];
-    MGparm *mgparm = VNULL;
-    PBEparm *pbeparm = VNULL;
-    Vatom *atom = VNULL;
-
-    /* Observables and unit conversion */
-    double field[3];
-    double sign,kT,electric;
-
-    /* Potential Vgrid construction */
-    double nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin;
-    double *data;
-
-    /* Loop variables */
-    int i,j;
-
-    VASSERT(nosh != VNULL);
-    for (i=0; i<NOSH_MAXCALC; i++) {
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-    }
-
-    /* Read TINKER input data into Vatom instances. */
-    for (i=0; i < alist[0]->number; i++){
-       atom = Valist_getAtom(alist[0],i);
-       Vatom_setInducedDipole(atom, uind[i]);
-       for (j=0;j<3;j++){
-           fld[i][j] = 0.0;
-       }
-    }
-
-    /* Solve the LPBE for the homogeneous system, then solvated. */
-    for (i=0; i<2; i++) {
-
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-
-       /* Useful local variables */
-       mgparm = nosh->calc[i]->mgparm;
-       pbeparm = nosh->calc[i]->pbeparm;
-
-       if (!MGparm_check(mgparm)){
-          printf("MGparm Check failed\n");
-          exit(-1);
-       }
-       if (!PBEparm_check(pbeparm)){
-          printf("PBEparm Check failed\n");
-          exit(-1);
-       }
-
-       /* Set up problem */
-       mgparm->chgs = VCM_INDUCED;
-       if (!initMG(i, nosh, mgparm, pbeparm, realCenter, pbe,
-                   alist, dielXMap, dielYMap, dielZMap,
-                   kappaMap, chargeMap, pmgp, pmg)) {
-           Vnm_tprint( 2, "Error setting up MG calculation!\n");
-           return;
-       }
-
-       /* Solve the PDE */
-       if (solveMG(nosh, pmg[i], mgparm->type) != 1) {
-           Vnm_tprint(2, "Error solving PDE!\n");
-           return;
-       }
-
-       /* Set partition information for observables and I/O */
-       if (setPartMG(nosh, mgparm, pmg[i]) != 1) {
-           Vnm_tprint(2, "Error setting partition info!\n");
-           return;
-       }
-
-       /* Save the potential due to local induced dipoles */
-       nx = pmg[i]->pmgp->nx;
-       ny = pmg[i]->pmgp->ny;
-       nz = pmg[i]->pmgp->nz;
-       hx = pmg[i]->pmgp->hx;
-       hy = pmg[i]->pmgp->hy;
-       hzed = pmg[i]->pmgp->hzed;
-       xmin = pmg[i]->pmgp->xmin;
-       ymin = pmg[i]->pmgp->ymin;
-       zmin = pmg[i]->pmgp->zmin;
-
-       if (indU[i] == VNULL) {
-          data = Vmem_malloc(mem, nx*ny*nz, sizeof(double));
-          Vpmg_fillArray(pmg[i], data, VDT_POT, 0.0, pbeparm->pbetype);
-          indU[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin,data);
-          indU[i]->readdata = 1;
-          // set readdata flag to have the dtor to free data
-       } else {
-          data = indU[i]->data;
-          Vpmg_fillArray(pmg[i], data, VDT_POT, 0.0, pbeparm->pbetype);
-       }
-
-       if (i == 0){
-          sign = -1.0;
-       } else {
-          sign = 1.0;
-       }
-
-       for (j=0; j < alist[0]->number; j++){
-          Vpmg_fieldSpline4(pmg[i], j, field);
-          fld[j][0] += sign * field[0];
-          fld[j][1] += sign * field[1];
-          fld[j][2] += sign * field[2];
-       }
-    }
-
-    /* load results into the return arrays in electron**2/Ang
-    /* kT in kcal/mol */
-    kT = Vunit_kb * (1e-3) * Vunit_Na * 298.15 / 4.184;
-    // electric: conversion from electron**2/Ang to Kcal/mol
-    electric = 332.05382;
-    for (i=0; i<alist[0]->number; i++){
-       // starting with the field in KT/e/Ang^2 multiply by Kcal/mol/KT
-       // (conversion to e/Ang^2, which are TINKER field units)
-       fld[i][0] *= kT / electric;
-       fld[i][1] *= kT / electric;
-       fld[i][2] *= kT / electric;
-    }
-
-    killMG(nosh, pbe, pmgp, pmg);
-}
-
-/***********************************************************************
-  apbsnlinduce is called from TINKER during SCRF convergence to:
-
-  (1) Solve the PBE given non-local induced dipoles as the source term
-  (2) Save the solution potential for later polarization force calc
-  (3) Return the nonlocal induced dipole reaction field to TINKER
-************************************************************************/
-
-void apbsnlinduce_(double uinp[maxatm][3], double fld[maxatm][3]){
-
-    /* Misc. pointers to APBS data structures */
-    Vpmg  *pmg[NOSH_MAXCALC];
-    Vpmgp *pmgp[NOSH_MAXCALC];
-    Vpbe  *pbe[NOSH_MAXCALC];
-    MGparm *mgparm = VNULL;
-    PBEparm *pbeparm = VNULL;
-    Vatom *atom = VNULL;
-
-    /* Observables and unit conversion */
-    double field[3];
-    double sign,kT,electric;
-    /* Potential Vgrid construction */
-    double nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin;
-    double *data;
-    /* Loop variables */
-    int i,j;
-
-    VASSERT(nosh != VNULL);
-    for (i=0; i<NOSH_MAXCALC; i++) {
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-    }
-
-    /* Read TINKER induce input data into Vatom instances. */
-    for (i=0; i < alist[0]->number; i++){
-       atom = Valist_getAtom(alist[0],i);
-       Vatom_setNLInducedDipole(atom, uinp[i]);
-       for (j=0;j<3;j++){
-           fld[i][j] = 0.0;
-       }
-    }
-
-    /* Solve the LPBE for the homogeneous system, then solvated. */
-    for (i=0; i<2; i++) {
-
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-
-       /* Useful local variables */
-       mgparm = nosh->calc[i]->mgparm;
-       pbeparm = nosh->calc[i]->pbeparm;
-
-       if (!MGparm_check(mgparm)){
-          printf("MGparm Check failed\n");
-          exit(-1);
-       }
-       if (!PBEparm_check(pbeparm)){
-          printf("PBEparm Check failed\n");
-          exit(-1);
-       }
-
-       /* Set up problem */
-       mgparm->chgs = VCM_NLINDUCED;
-       if (!initMG(i, nosh, mgparm, pbeparm, realCenter, pbe,
-                   alist, dielXMap, dielYMap, dielZMap,
-                   kappaMap, chargeMap, pmgp, pmg)) {
-           Vnm_tprint( 2, "Error setting up MG calculation!\n");
-           return;
-       }
-
-       /* Solve the PDE */
-       if (solveMG(nosh, pmg[i], mgparm->type) != 1) {
-           Vnm_tprint(2, "Error solving PDE!\n");
-           return;
-       }
-
-       /* Set partition information for observables and I/O */
-       if (setPartMG(nosh, mgparm, pmg[i]) != 1) {
-           Vnm_tprint(2, "Error setting partition info!\n");
-           return;
-       }
-
-       /* Save the potential due to non-local induced dipoles */
-       nx = pmg[i]->pmgp->nx;
-       ny = pmg[i]->pmgp->ny;
-       nz = pmg[i]->pmgp->nz;
-       hx = pmg[i]->pmgp->hx;
-       hy = pmg[i]->pmgp->hy;
-       hzed = pmg[i]->pmgp->hzed;
-       xmin = pmg[i]->pmgp->xmin;
-       ymin = pmg[i]->pmgp->ymin;
-       zmin = pmg[i]->pmgp->zmin;
-
-       if (nlIndU[i] == VNULL) {
-          data = Vmem_malloc(VNULL, nx*ny*nz, sizeof(double));
-          Vpmg_fillArray(pmg[i], data, VDT_POT, 0.0, pbeparm->pbetype);
-          nlIndU[i] = Vgrid_ctor(nx,ny,nz,hx,hy,hzed,xmin,ymin,zmin,data);
-          nlIndU[i]->readdata = 1; // set readata flag to have the dtor free data
-       } else {
-          data = nlIndU[i]->data;
-          Vpmg_fillArray(pmg[i], data, VDT_POT, 0.0, pbeparm->pbetype);
-       }
-
-       if (i == 0){
-          sign = -1.0;
-       } else {
-          sign = 1.0;
-       }
-
-       for (j=0; j < alist[0]->number; j++){
-          Vpmg_fieldSpline4(pmg[i], j, field);
-          fld[j][0] += sign * field[0];
-          fld[j][1] += sign * field[1];
-          fld[j][2] += sign * field[2];
-       }
-    }
-
-    /* load results into the return arrays in electron**2/Angstrom
-    /* kT in kcal/mol */
-    kT = Vunit_kb * (1e-3) * Vunit_Na * 298.15 / 4.184;
-    // electric: conversion from electron**2/Angstrom to Kcal/mol
-    electric = 332.063709;
-    for (i=0; i<alist[0]->number; i++){
-       fld[i][0] *= kT / electric;
-       fld[i][1] *= kT / electric;
-       fld[i][2] *= kT / electric;
-    }
-
-    killMG(nosh, pbe, pmgp, pmg);
-}
-
-/***********************************************************************
-  pbdirectpolarizationforce is called from TINKER to:
-
-  (1) compute direct polarization forces and torques using
-      saved potentials
-***********************************************************************/
-
-void pbdirectpolforce_(double uind[maxatm][3], double uinp[maxatm][3],
-                       double rff[maxatm][3], double rft[maxatm][3]) {
-
-    Vpmg  *pmg[NOSH_MAXCALC];
-    Vpmgp *pmgp[NOSH_MAXCALC];
-    Vpbe  *pbe[NOSH_MAXCALC];
-    MGparm *mgparm = VNULL;
-    PBEparm *pbeparm = VNULL;
-    Vatom *atom = VNULL;
-    double kT, force[3], torque[3];
-    double sign, zkappa2, epsp, epsw;
-    int i,j;
-
-    for (i=0; i<NOSH_MAXCALC; i++) {
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-    }
-
-    // Read the converged induced dipole data into APBS Vatom structures.
-    for (i=0; i < alist[0]->number; i++){
-       atom = Valist_getAtom(alist[0],i);
-       Vatom_setInducedDipole(atom, uind[i]);
-       Vatom_setNLInducedDipole(atom, uinp[i]);
-       for (j=0;j<3;j++){
-          rff[i][j] = 0.0;
-          rft[i][j] = 0.0;
-       }
-    }
-
-    for (i=0; i<2; i++) {
-
-       VASSERT(permU[i] != VNULL);
-       VASSERT(indU[i] != VNULL);
-       VASSERT(nlIndU[i] != VNULL);
-
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-
-       /* Useful local variables */
-       mgparm = nosh->calc[i]->mgparm;
-       pbeparm = nosh->calc[i]->pbeparm;
-
-       /* Set up problem */
-       if (!initMG(i, nosh, mgparm, pbeparm, realCenter, pbe,
-                   alist, dielXMap, dielYMap, dielZMap,
-                   kappaMap, chargeMap, pmgp, pmg)) {
-           Vnm_tprint( 2, "Error setting up MG calculation!\n");
-           return;
-       }
-
-       if (i == 0) {
-         sign = -1.0;
-       } else {
-         sign = 1.0;
-       }
-
-       // Q-Phi Force & Torque
-       if (!pmg[i]->pmgp->nonlin &&
-          (pmg[i]->surfMeth == VSM_SPLINE ||
-           pmg[i]->surfMeth == VSM_SPLINE3 ||
-           pmg[i]->surfMeth == VSM_SPLINE4)) {
-          for (j=0; j < alist[0]->number; j++){
-             Vpmg_qfDirectPolForce(pmg[i], permU[i], indU[i], j, force, torque);
-             rff[j][0] += sign * force[0];
-             rff[j][1] += sign * force[1];
-             rff[j][2] += sign * force[2];
-             rft[j][0] += sign * torque[0];
-             rft[j][1] += sign * torque[1];
-             rft[j][2] += sign * torque[2];
-             Vpmg_qfNLDirectPolForce(pmg[i], permU[i],
-                                     nlIndU[i], j,force,torque);
-             rff[j][0] += sign * force[0];
-             rff[j][1] += sign * force[1];
-             rff[j][2] += sign * force[2];
-             rft[j][0] += sign * torque[0];
-             rft[j][1] += sign * torque[1];
-             rft[j][2] += sign * torque[2];
-           }
-           // Dieletric Boundary Force
-           epsp = Vpbe_getSoluteDiel(pmg[i]->pbe);
-           epsw = Vpbe_getSolventDiel(pmg[i]->pbe);
-           if (VABS(epsp-epsw) > VPMGSMALL) {
-              for (j=0; j < alist[0]->number; j++){
-                 Vpmg_dbDirectPolForce(pmg[i], permU[i], indU[i], j, force);
-                 rff[j][0] += sign * force[0];
-                 rff[j][1] += sign * force[1];
-                 rff[j][2] += sign * force[2];
-                 Vpmg_dbNLDirectPolForce(pmg[i], permU[i], nlIndU[i], j, force);
-                 rff[j][0] += sign * force[0];
-                 rff[j][1] += sign * force[1];
-                 rff[j][2] += sign * force[2];
-              }
-           }
-           // Ionic Boundary Force
-           zkappa2 = Vpbe_getZkappa2(pmg[i]->pbe);
-           if (zkappa2 > VPMGSMALL) {
-               for (j=0; j < alist[0]->number; j++){
-                  Vpmg_ibDirectPolForce(pmg[i], permU[i], indU[i], j, force);
-                  rff[j][0] += sign * force[0];
-                  rff[j][1] += sign * force[1];
-                  rff[j][2] += sign * force[2];
-                  Vpmg_ibNLDirectPolForce(pmg[i], permU[i],
-                                          nlIndU[i], j, force);
-                  rff[j][0] += sign * force[0];
-                  rff[j][1] += sign * force[1];
-                  rff[j][2] += sign * force[2];
-               }
-           }
-       }
-    }
-
-    // kT in kcal/mol
-    kT = Vunit_kb * (1e-3) * Vunit_Na * 298.15 / 4.184;
-    for (i=0; i<alist[0]->number; i++){
-       rff[i][0] *= kT;
-       rff[i][1] *= kT;
-       rff[i][2] *= kT;
-       rft[i][0] *= kT;
-       rft[i][1] *= kT;
-       rft[i][2] *= kT;
-    }
-
-    killMG(nosh, pbe, pmgp, pmg);
-}
-
-/***********************************************************************
-  pbmutualpolarizationforce is called from TINKER to:
-
-  (1) compute mutual polarization forces using saved potentials
-***********************************************************************/
-
-void pbmutualpolforce_(double uind[maxatm][3], double uinp[maxatm][3],
-                       double rff[maxatm][3]) {
-
-    Vpmg  *pmg[NOSH_MAXCALC];
-    Vpmgp *pmgp[NOSH_MAXCALC];
-    Vpbe  *pbe[NOSH_MAXCALC];
-    MGparm *mgparm = VNULL;
-    PBEparm *pbeparm = VNULL;
-    Vatom *atom = VNULL;
-    double kT, force[3];
-    double sign, zkappa2, epsp, epsw;
-    int i,j;
-
-    for (i=0; i<NOSH_MAXCALC; i++) {
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-    }
-
-    // Read the converged dipole data into APBS Vatom structures.
-    for (i=0; i < alist[0]->number; i++){
-       atom = Valist_getAtom(alist[0],i);
-       Vatom_setInducedDipole(atom, uind[i]);
-       Vatom_setNLInducedDipole(atom, uinp[i]);
-       for (j=0;j<3;j++){
-          rff[i][j] = 0.0;
-       }
-    }
-
-    for (i=0; i<2; i++) {
-
-       VASSERT(indU[i] != VNULL);
-       VASSERT(nlIndU[i] != VNULL);
-
-       pmg[i] = VNULL;
-       pmgp[i] = VNULL;
-       pbe[i] = VNULL;
-
-       /* Useful local variables */
-       mgparm = nosh->calc[i]->mgparm;
-       pbeparm = nosh->calc[i]->pbeparm;
-
-       /* Set up problem */
-       if (!initMG(i, nosh, mgparm, pbeparm, realCenter, pbe,
-                   alist, dielXMap, dielYMap, dielZMap,
-                   kappaMap, chargeMap, pmgp, pmg)) {
-           Vnm_tprint( 2, "Error setting up MG calculation!\n");
-           return;
-       }
-
-       if (i == 0) {
-         sign = -1.0;
-       } else {
-         sign = 1.0;
-       }
-
-       for (j=0; j < alist[0]->number; j++){
-          Vpmg_qfMutualPolForce(pmg[i], indU[i], nlIndU[i], j, force);
-          rff[j][0] += sign * force[0];
-          rff[j][1] += sign * force[1];
-          rff[j][2] += sign * force[2];
-       }
-       epsp = Vpbe_getSoluteDiel(pmg[i]->pbe);
-       epsw = Vpbe_getSolventDiel(pmg[i]->pbe);
-       if (VABS(epsp-epsw) > VPMGSMALL) {
-          for (j=0; j < alist[0]->number; j++){
-             Vpmg_dbMutualPolForce(pmg[i], indU[i], nlIndU[i], j, force);
-             rff[j][0] += sign * force[0];
-             rff[j][1] += sign * force[1];
-             rff[j][2] += sign * force[2];
-          }
-       }
-       zkappa2 = Vpbe_getZkappa2(pmg[i]->pbe);
-       if (zkappa2 > VPMGSMALL) {
-          for (j=0; j < alist[0]->number; j++){
-             Vpmg_ibMutualPolForce(pmg[i], indU[i], nlIndU[i], j, force);
-             rff[j][0] += sign * force[0];
-             rff[j][1] += sign * force[1];
-             rff[j][2] += sign * force[2];
-          }
-       }
-    }
-
-    // kT in kcal/mol.
-    kT = Vunit_kb * (1e-3) * Vunit_Na * 298.15 / 4.184;
-    for (i=0; i<alist[0]->number; i++){
-       rff[i][0] *= kT;
-       rff[i][1] *= kT;
-       rff[i][2] *= kT;
-    }
-
-    killMG(nosh, pbe, pmgp, pmg);
-}
-
-void apbsfinal_() {
-    unsigned long int bytesTotal, highWater;
-    int i;
-
-    VASSERT(nosh != VNULL);
-
-     /* Kill the saved potential Vgrids */
-    for (i=0; i<2; i++){
-      Vgrid_dtor(&permU[i]);
-      Vgrid_dtor(&indU[i]);
-      Vgrid_dtor(&nlIndU[i]);
-    }
-
-    Valist_dtor(&alist[0]);
-    /* Saving the kappa and dielectric maps is under consideration.
-    killKappaMaps(nosh, kappaMap);
-    killDielMaps(nosh, dielXMap, dielYMap, dielZMap);
-    */
-    NOsh_dtor(&nosh);
-
-    /* Clean up MALOC structures */
-    bytesTotal = Vmem_bytesTotal();
-    highWater = Vmem_highWaterTotal();
-
-    /*
-    printf(" Final APBS memory usage: %4.3f MB total, %4.3f MB high water\n\n",
-     (double)(bytesTotal)/(1024.*1024.),(double)(highWater)/(1024.*1024.));
-    */
-
-    Vmem_dtor(&mem);
-    Vnm_tstop(APBS_TIMER_WALL_CLOCK, "APBS WALL CLOCK");
-    Vcom_finalize();
-    Vcom_dtor(&com);
-}
diff -abuN source/promo.f source_distrib/promo.f
--- source/promo.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/promo.f	2011-05-12 14:28:52.000000000 +0200
@@ -38,5 +38,13 @@
      &        /,' ##',74x,'##',
      &        /,' ',78('#'),
      &        /,' ',78('#'),/)
+c
+c QM/MM promo
+c
+      write (iout,20)
+   20 format (/,' ##',21x,'QM/MM modifications: May 2011',21x,'##',
+     &        /,' ##',18x,'Nicolas Ferre, Universite de Provence',19x,
+     &        '##',/,' ##',18x,'Federico Melaccio, Universita di Siena',
+     &        18x,'##',/)
       return
       end
diff -abuN source/prtxyz.f source_distrib/prtxyz.f
--- source/prtxyz.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/prtxyz.f	2010-08-26 11:38:23.000000000 +0200
@@ -25,6 +25,9 @@
       include 'files.i'
       include 'inform.i'
       include 'titles.i'
+cqmmm 
+      include 'qmmm.i'
+cqmmm
       integer i,k,ixyz
       logical opened
       character*120 xyzfile
@@ -53,21 +56,36 @@
 c
       if (digits .le. 6) then
          do i = 1, n
-            write (ixyz,30)  i,name(i),x(i),y(i),z(i),type(i),
-     &                       (i12(k,i),k=1,n12(i))
+cqmmm            write (ixyz,30)  i,name(i),x(i),y(i),z(i),type(i),
+c     &                       (i12(k,i),k=1,n12(i))
+            if(qmmm(i).eq.1) n12(i) = 2
+            write (ixyz,30)  i,name(i),x(i),y(i),z(i),
+     &                       type(i),(i12(k,i),k=1,n12(i))
+c     &                       type(i)+qmmm(i)*10000,(i12(k,i),k=1,n12(i))
    30       format (i6,2x,a3,3f12.6,9i6)
+            if(qmmm(i).eq.1) n12(i) = 0
          end do
       else if (digits .le. 8) then
          do i = 1, n
-            write (ixyz,40)  i,name(i),x(i),y(i),z(i),type(i),
-     &                       (i12(k,i),k=1,n12(i))
+cqmmm            write (ixyz,40)  i,name(i),x(i),y(i),z(i),type(i),
+c     &                       (i12(k,i),k=1,n12(i))
+            if(qmmm(i).eq.1) n12(i) = 2
+            write (ixyz,40)  i,name(i),x(i),y(i),z(i),
+     &                       type(i),(i12(k,i),k=1,n12(i))
+c     &                       type(i)+qmmm(i)*10000,(i12(k,i),k=1,n12(i))
    40       format (i6,2x,a3,3f14.8,9i6)
+            if(qmmm(i).eq.1) n12(i) = 0
          end do
       else
          do i = 1, n
-            write (ixyz,50)  i,name(i),x(i),y(i),z(i),type(i),
-     &                       (i12(k,i),k=1,n12(i))
+cqmmm            write (ixyz,50)  i,name(i),x(i),y(i),z(i),type(i),
+c     &                       (i12(k,i),k=1,n12(i))
+             if(qmmm(i).eq.1) n12(i) = 2
+            write (ixyz,50)  i,name(i),x(i),y(i),z(i),
+     &                       type(i),(i12(k,i),k=1,n12(i))
+c     &                       type(i)+qmmm(i)*10000,(i12(k,i),k=1,n12(i))
    50       format (i6,2x,a3,3f16.10,9i6)
+            if(qmmm(i).eq.1) n12(i) = 0
          end do
       end if
       if (.not. opened)  close (unit=ixyz)
diff -abuN source/qmmm.i source_distrib/qmmm.i
--- source/qmmm.i	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/qmmm.i	2010-08-26 11:38:25.000000000 +0200
@@ -0,0 +1,113 @@
+c     ###############################################################
+c     ##                                                           ##
+c     ##  qmmm .i  --  QM/MM stuff for coupling of tinker with QM  ##
+c     ##                                                           ##
+c     ###############################################################
+c
+c     maxqmmm   the maximum number of atoms also defined in the qm program
+c     maxy      the maximum number of QM/MM frontier bonds
+c
+c     common /itkqmmm/:
+c     qmmm          QM or MM atom ? for each atom in the system:
+c                     MM          ->  0
+c                     Link atom   ->  1
+c                     QM          ->  2
+c                     Y(LSCF/MM)  ->  3
+c     e4qmmm         count or not some QM/MM electrostatic interactions
+c                     -1  ->  none, aka mechanical embedding
+c                      0  ->  none but will be computed elsewhere
+c                      3  ->  includes the QM/MM ones (microiteration or MD cases)
+c     nbinqm         the number of atoms defined also in the qm program
+c     atinqm         the mapping array between the qm program and tinker
+c     nybond         the number of QM/MM SLBO frontiers
+c     iybond         the array containing the frontier atom numbers
+c     qmcode         selection of the QM program
+c                      Molcas    ->  0 or 1
+c                      Gaussian  ->  2
+c     casroot        the casscf root which energy is scaled
+c     micromode      MM microiterations mode: Full or On(ly)
+c     mmmdmode       MM MD mode: Full or On(ly)
+c     mdnequi        number of MD steps for equilibration
+c     mdnprod        number of MD steps for production
+c     nsnap          number of dumped MD snapshots
+c
+c     common /ltkqmmm/:
+c     doespf         ESPF calculation ?
+c     domicro        MM microiterations ?
+c     dorunmd        Molecular Dynamics ?
+c     doqmmmdyn      QM/MM molecular dynamics run ?
+c     doqmmmhessian  QM/MM hessian contribution ?
+c     domdhess       Hessian MD averaging ?
+c
+c     common /ctkqmmm/:
+c     qmline         the command line needed to run the qm job
+c     ensemble       MD statistical ensemble for periodic systems
+c
+c     common /rtkqmmm/:
+c     lahg           the array containing the scaling factors of each frontier
+c     qmmmscale      scale factor for qm/mm interactions
+c     casmme         the saved MM energy when the caspt2 starts
+c     qybond         the array containing the MM partial charge of Y atoms
+c     dt             MD time step in ps
+c     dtdump         MD dump time in ps
+c     x,y e zavg     MD run coordinate averages
+c     epavg          MD average electostatic potential 
+c     epgavg         MD average components of elec potential 1st derivative
+c     ephavg         MD average components of elec potential 2nd derivative
+c     avgen          MD average total energy
+c     avgderiv	     MD average components of total energy 1st derivative
+c     rmsd           MD RMSD respect to the first structure
+c     eprmsd         MD RMSD of elec potential respect to previous structure
+c     epgrmsd        MD RMSD of 1st derivative of elec potential
+c     xpre ecc.      MD 1st structure coordinates
+c     nstrut         number of MD snaps used for average
+c
+c
+      integer maxqmmm,maxy,qmmm,e4qmmm,nbinqm,atinqm,nybond,
+     & iybond,micromode,mmmdmode,qmcode,casroot,nsnap,mdnequi,mdnprod
+      parameter(maxqmmm=1000)
+      parameter(maxy=100)
+      logical doespf,doqmmmdyn,doqmmmhessian,domdhess
+      character*120 qmline
+      character*3 ensemble
+      real*8 lahg,qmmmscale,casmme,qybond,dt,dtdump,
+     & xavg,yavg,zavg,rmsd,xpre,ypre,zpre,epgrmsd,
+     & nstrut
+      real*8 epavg,epgavg,ephavg,avgen,avgderiv,eprmsd
+      real*8 rcov(0:104)
+      save rcov
+      data rcov/0.0d0,
+     $  0.354D0,0.849D0,
+     $  1.336D0,1.010D0,0.838D0,0.757D0,0.700D0,0.658D0,0.668D0,0.920D0,
+     $  1.539D0,1.421D0,1.244D0,1.117D0,1.101D0,1.064D0,1.044D0,1.032D0,
+     $  1.953D0,1.761D0,
+     $  1.513D0,1.412D0,1.402D0,1.345D0,1.382D0,
+     $  1.270D0,1.241D0,1.164D0,1.302D0,1.193D0,
+     $                  1.260D0,1.197D0,1.211D0,1.190D0,1.192D0,1.147D0,
+     $  2.260D0,2.052D0,
+     $  1.698D0,1.564D0,1.473D0,1.467D0,1.322D0,
+     $  1.478D0,1.332D0,1.338D0,1.386D0,1.403D0,
+     $                  1.459D0,1.398D0,1.407D0,1.386D0,1.382D0,1.267D0,
+     $  2.570D0,2.277D0,
+     $  1.943D0,1.841D0,1.823D0,1.816D0,1.801D0,1.780D0,1.771D0,
+     $  1.735D0,1.732D0,1.710D0,1.696D0,1.673D0,1.660D0,1.637D0,
+     $  1.671D0,1.611D0,1.511D0,1.392D0,1.372D0,
+     $  1.372D0,1.371D0,1.364D0,1.262D0,1.340D0,
+     $                  1.518D0,1.459D0,1.512D0,1.500D0,1.545D0,1.420D0,
+     $  2.880D0,2.512D0,1.983D0,1.721D0,1.711D0,1.684D0,1.666D0,
+     $  1.657D0,1.660D0,1.801D0,1.761D0,1.750D0,1.724D0,1.712D0,
+     $  1.689D0,1.679D0,1.698D0,
+     $  1.850D0/
+
+      common /itkqmmm/ qmmm(maxatm),e4qmmm,nbinqm,atinqm(maxatm),
+     &                 nybond,iybond(2,maxy),qmcode,casroot,micromode,
+     &                 mmmdmode,nsnap,mdnequi,mdnprod
+      common /ltkqmmm/ doespf,doqmmmdyn,doqmmmhessian,domdhess
+      common /ctkqmmm/ qmline,ensemble
+      common /rtkqmmm/ lahg(maxy),qmmmscale,casmme,qybond(maxy),dt,
+     &                 dtdump,xavg(maxatm),yavg(maxatm),zavg(maxatm),
+     &                 epavg(maxqmmm),epgavg(3,maxqmmm),avgen(23),
+     &                 ephavg(6,maxqmmm),avgderiv(3,maxatm),rmsd,
+     &                 xpre(maxatm),ypre(maxatm),zpre(maxatm),
+     &                 eprmsd,epgrmsd(3),nstrut
+
diff -abuN source/qmmmsetup.f source_distrib/qmmmsetup.f
--- source/qmmmsetup.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/qmmmsetup.f	2010-08-26 11:38:22.000000000 +0200
@@ -0,0 +1,244 @@
+      subroutine qmmmsetup
+      implicit none
+c
+c     From its name ... setup the QM/MM run
+c     Basically read the key file and check the informations
+c     Also update the coordinates coming from the QM code
+c
+      include 'sizes.i'
+      include 'atoms.i'
+      include 'bath.i'
+      include 'charge.i'
+      include 'files.i'
+      include 'inform.i'
+      include 'iounit.i'
+      include 'keys.i'
+      include 'mdstuf.i'
+      include 'qmmm.i'
+c
+      integer next,i,j,k,ii,jj,kk,icurr,imin,freeunit,ioff
+      integer nqmmmtmp
+      integer iqmmmtmp(maxqmmm)
+      logical found,exist
+      real*8 xtmp,ytmp,ztmp,qtmp,gtmp
+      character*20 keyword
+      character*60 minfile
+      character*120 record
+      character*120 string
+      character*2 qmmmcode
+
+c
+c     Look for the QMMM keywords in the key file
+c
+      nbinqm = 0
+      nybond = 0
+      micromode = 0
+      mmmdmode = 0
+      if (n .eq. 0) return
+      do i = 1, n
+         atinqm(i) = 0
+      end do
+      do i = 1, maxy
+         lahg(i) = -1.0d0
+         qybond(i) = 0.0d0
+      end do
+      e4qmmm = 0
+      doespf = .false.
+      found = .false.
+      doqmmmdyn = .false.
+      doqmmmhessian = .false.
+      qmcode = 0
+      qmline = 'NOTHING'
+      qmmmscale = 1.0d0
+      casroot = 0
+      casmme = 0.0d0
+      nqmmmtmp = 0
+      mdnequi = 0
+      mdnprod = 0
+      dt = 1.0d-3
+      dtdump = 1.0d-1
+      domdhess = .false.
+      kelvin = 298.0d0
+      atmsph = 1.0d0
+      ensemble = 'NVE'
+      isothermal = .false.
+      isobaric = .false.
+      do j = 1, nkey
+         next = 1
+         record = keyline(j)
+         call gettext (record,keyword,next)
+         call upcase (keyword)
+         string = record(next:120)
+         do i = 1, maxqmmm
+            iqmmmtmp(i) = 0
+         end do
+c
+c     QMMM keyword followed by 2 integers
+c         - NbInQM: the number of atoms defined in the QM code
+c         - NYBond: the number of SLBOs in the LSCF/MM computation
+c
+         if (keyword(1:5) .eq. 'QMMM ') then
+            found = .true.
+            read(string,*,err=1,end=1) nbinqm,nybond
+1           write (iout,2)
+2           format(/,' This is a QM/MM calculation')
+            if (nbinqm.le.0.or.nbinqm.gt.n.or.nbinqm.gt.maxqmmm) then
+               write (iout,3) nbinqm
+3              format (/,' QMMMSETUP -- Wrong NbInQM value ',i2)
+               call fatal
+            end if
+            if (nybond.lt.0.or.nybond.gt.n.or.nybond.gt.maxqmmm) then
+               write (iout,4) nybond
+4              format (/,' QMMMSETUP -- Wrong NYBond value ',i2)
+               call fatal
+            end if
+         else if (keyword(1:3) .eq. 'QM '
+     &       .or. keyword(1:3) .eq. 'MM '
+     &       .or. keyword(1:3) .eq. 'LA '
+     &       .or. keyword(1:3) .eq. 'YA ') then
+            qmmmcode = keyword(1:2)
+            read(string,*,err=5,end=5) (iqmmmtmp(i),i=1,maxqmmm)
+5           i = 0
+6           i = i + 1
+            k = iqmmmtmp(i)
+            if (k .eq. 0) goto 8
+            if (k .gt. n) then
+               write (iout,7) k
+7              format (/,' QMMMSETUP -- Wrong QM/MM/LA/YA value ',i2)
+               call fatal
+            else if (k .gt. 0) then
+               if (qmmmcode(1:2) .eq. 'MM') then
+                  qmmm(k) = 0
+               else if (qmmmcode(1:2) .eq. 'LA') then
+                  qmmm(k) = 1
+               else if (qmmmcode(1:2) .eq. 'QM') then
+                  qmmm(k) = 2
+               else
+                  qmmm(k) = 3
+               end if
+               nqmmmtmp = nqmmmtmp + 1
+               atinqm(k) = nqmmmtmp
+            else
+               kk = iqmmmtmp(i+1)
+               if (kk.le.0 .or. kk.lt.k) then
+                  write (iout,7) kk
+                  call fatal
+               end if
+               do ii = -k, kk
+                  nqmmmtmp = nqmmmtmp + 1
+                  atinqm(ii) = nqmmmtmp
+                  if (qmmmcode(1:2) .eq. 'MM') then
+                     qmmm(ii) = 0
+                  else if (qmmmcode(1:2) .eq. 'LA') then
+                     qmmm(ii) = 1
+                  else if (qmmmcode(1:2) .eq. 'QM') then
+                     qmmm(ii) = 2
+                  else
+                     qmmm(ii) = 3
+                  end if
+               end do
+               i = i + 1
+            end if
+            goto 6
+8           continue
+c
+c     Select the QM/MM electrostatics interaction mode
+c
+         else if (keyword(1:20) .eq. 'QMMM-ELECTROSTATICS ') then
+            call gettext (record,keyword,next)
+            call upcase (keyword)
+            if (keyword(1:5) .eq. 'ESPF ') then
+               doespf = .true.
+            else if (keyword(1:7) .eq. 'DIRECT ') then
+               doespf = .false.
+            else if (keyword(1:5) .eq. 'NONE ') then
+               e4qmmm = -1
+            else
+               write (iout,*) ' QMMMSETUP -- Wrong QMMM-ELECTROSTATICS'
+               call fatal
+            end if
+c
+c     Select the MM micro-iterations mode
+c
+         else if (keyword(1:20) .eq. 'QMMM-MICROITERATION ') then
+            call gettext (record,keyword,next)
+            call upcase (keyword)
+            if (keyword(1:5) .eq. 'FULL ') then
+               micromode = 1
+            else if (keyword(1:3) .eq. 'ON ' 
+     &          .or. keyword(1:5) .eq. 'ONLY ') then
+               micromode = 2
+            else if (keyword(1:4) .eq. 'OFF ') then
+            else
+               write (iout,*) ' QMMMSETUP -- Wrong QMMM-MICROITERATION'
+               call fatal
+            end if
+c
+c     Select the QM/MM Hessian
+c
+         else if (keyword(1:13) .eq. 'QMMM-HESSIAN ') then
+            call gettext (record,keyword,next)
+            call upcase (keyword)
+            if (keyword(1:2) .eq. 'ON') then
+               doqmmmhessian = .true.
+            else if (keyword(1:3) .eq. 'OFF') then
+               doqmmmhessian = .false.
+            else
+               write (iout,*) ' QMMMSETUP -- Wrong QMMM-HESSIAN'
+               call fatal
+            end if
+c
+c     Select the QM/MM dynamics arguments
+c
+         else if (keyword(1:14) .eq. 'QMMM-EXTERNAL ') then
+            doqmmmdyn = .true.
+            call gettext (record,keyword,next)
+            call upcase (keyword)
+            if (keyword(1:7) .eq. 'MOLCAS ') then
+                qmcode = 1
+            else if (keyword(1:8) .eq. 'GAUSSIAN ') then
+                qmcode = 2
+            end if
+            qmline = record(next:120)
+c
+c     Is there any QM/MM scale factor ?
+c
+         else if (keyword(1:11) .eq. 'QMMM-SCALE ') then
+            read(string,*,err=10,end=10) qmmmscale,casroot
+10          if (casroot .gt. 0) then
+               write (iout,11) qmmmscale,casroot
+11             format(/,' Initial QM/MM scale factor:' ,f7.3,
+     &             ' for QM state ',i2)
+            else if (casroot .lt. 0) then
+               write (iout,12) qmmmscale,abs(casroot)
+12             format(/,' Constant QM/MM scale factor: ',f7.3,
+     &             ' for QM state ',i2)
+            else
+               write (iout,13) qmmmscale
+13             format(/,' Constant QM/MM scale factor: ',f7.3)
+            end if
+            if (qmmmscale .le. 0.0d0) call fatal
+         end if
+      end do
+      if (nqmmmtmp .ne. nbinqm) then
+         write(iout,19) nqmmmtmp, nbinqm
+19       format(/,' QMMMSETUP -- Found ',i4,' QM/MM/LA/YA atoms',
+     &          /,'              while ',i4,' were expected')
+      end if
+      if (.not.found) return
+c
+c     Check the mapping.
+c
+      do 20 i = 1, (n-1)
+         if (atinqm(i).eq.0) goto 20
+         do j = i+1, n
+            if (atinqm(i).eq.atinqm(j)) then
+               write(iout,21) i,j,atinqm(i)
+21             format(/,' QMMMSETUP -- Two atoms ',i4,' and ',i4,
+     &                   ' are mapped to the same QM atom ',i4)
+               call fatal
+            end if
+         end do
+20    continue
+      return
+      end
diff -abuN source/readxyz2.f source_distrib/readxyz2.f
--- source/readxyz2.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/readxyz2.f	2010-08-26 11:38:22.000000000 +0200
@@ -0,0 +1,295 @@
+c
+c
+c     ###################################################
+c     ##  COPYRIGHT (C)  1990  by  Jay William Ponder  ##
+c     ##              All Rights Reserved              ##
+c     ###################################################
+c
+c     ##############################################################
+c     ##                                                          ##
+c     ##  subroutine readxyz2  --  input of Cartesian coordinates ##
+c     ##                                                          ##
+c     ##############################################################
+c
+c
+c     "readxyz2" gets a set of Cartesian coordinates from
+c     an external disk file, without calling qmmmsetup
+c
+c
+      subroutine readxyz2 (ixyz)
+      implicit none
+      include 'sizes.i'
+      include 'atmtyp.i'
+      include 'atoms.i'
+      include 'couple.i'
+      include 'files.i'
+      include 'inform.i'
+      include 'iounit.i'
+      include 'titles.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
+      integer i,j,k,m,ixyz
+      integer next,size
+      integer first,last
+      integer nexttext
+      integer trimtext
+      integer list(maxatm)
+      logical exist,opened
+      logical quit,reorder
+      logical clash
+      character*120 record
+      character*120 string
+cqmmm
+      integer ia,ib,ilah,iya,kk
+      integer typetmp(maxatm),conn(maxval,maxatm)
+c
+c
+c     initialize the total number of atoms in the system
+c
+      n = 0
+c
+c     open the input file if it has not already been done
+c
+      inquire (unit=ixyz,opened=opened)
+      if (.not. opened) then
+         write(iout,11)
+   11    format (/,' READXYZ2  --  Unable to Open the Cartesian',
+     &                 ' Coordinates File')
+         call fatal
+      end if
+      inquire (unit=ixyz,exist=exist)
+      if (exist) then
+         open (unit=ixyz,status='old')
+         rewind (unit=ixyz)
+      else
+         write (iout,10)
+   10    format (/,' READXYZ2  --  Unable to Find the Cartesian',
+     &                 ' Coordinates File')
+         call fatal
+      end if
+c
+c     read first line and return if already at end of file
+c
+      quit = .false.
+      abort = .true.
+      size = 0
+      dowhile (size .eq. 0)
+         read (ixyz,20,err=60,end=60)  record
+   20    format (a120)
+         size = trimtext (record)
+      end do
+      abort = .false.
+      quit = .true.
+c
+c     parse the title line to get the number of atoms
+c
+      i = 0
+      next = 1
+      call gettext (record,string,next)
+      read (string,*,err=60,end=60)  n
+c
+c     extract the title and determine its length
+c
+      string = record(next:120)
+      first = nexttext (string)
+      last = trimtext (string)
+      if (last .eq. 0) then
+         title = ' '
+         ltitle = 0
+      else
+         title = string(first:last)
+         ltitle = trimtext (title)
+      end if
+c
+c     check for too many total atoms in the file
+c
+      if (n .gt. maxatm) then
+         write (iout,30)  maxatm
+   30    format (/,' READXYZ2  --  The Maximum of',i8,' Atoms',
+     &              ' has been Exceeded')
+         call fatal
+      end if
+c
+c     initialize coordinates and connectivities for each atom
+c
+      do i = 1, n
+         x(i) = 0.0d0
+         y(i) = 0.0d0
+         z(i) = 0.0d0
+c         type(i) = 0
+c         do j = 1, maxval
+c            i12(j,i) = 0
+c         end do
+      end do
+c
+c     read the coordinates and connectivities for each atom
+c
+      do i = 1, n
+         next = 1
+         size = 0
+         dowhile (size .eq. 0)
+            read (ixyz,40,err=60,end=60)  record
+   40       format (a120)
+            size = trimtext (record)
+         end do
+         read (record,*,err=60,end=60)  tag(i)
+         call getword (record,name(i),next)
+         string = record(next:120)
+         read (string,*,err=50,end=50)  x(i),y(i),z(i),typetmp(i),
+     &                                  (conn(j,i),j=1,maxval)
+   50    continue
+cqmmm
+c      determine the qm/mm type of each atom
+c      4 types : MM (0), Link Atom (1), QM (2), Y atom (3)
+c      OBSOLETE NOW, better use the QMMM keyword
+cqmmm
+c         qmmm(i) = type(i)/10000
+c         type(i) = type(i) - qmmm(i)*10000
+c         if (qmmm(i).lt.0 .or. qmmm(i).gt.3) then
+c            write(iout,55) i
+c   55       format(/,' Wrong QM/MM Type at Atom',i6)
+c            goto 60
+c          endif
+cqmmm
+      end do
+      quit = .false.
+   60 continue
+c
+c     an error occurred in reading the coordinate file
+c
+      if (quit) then
+         write (iout,70)  i
+   70    format (/,' READXYZ2  --  Error in Coordinate File at Atom',i6)
+         call fatal
+      end if
+cqmmm
+c     set up the qm/mm options
+cqmmm
+c      ilah = 0
+c      iya  = 0
+c
+c     for each atom, count and sort its attached atoms
+c
+c      do i = 1, n
+c         n12(i) = 0
+c         do j = maxval, 1, -1
+c            if (i12(j,i) .ne. 0) then
+c               n12(i) = j
+c               goto 80
+c            end if
+c         end do
+c   80    continue
+c         call sort (n12(i),i12(1,i))
+cqmmm
+c     cancel the link atom connectivity but keeps the numbering
+c     of the frontier bond atoms
+cqmmm
+c         if (qmmm(i).eq.1) then
+c            write (iout,81) i
+c   81       format (/,i6,' is defined as a QM/MM Link Atom.')
+c            ilah = ilah + 1
+c            if (ilah .gt. maxy) then
+c               write (iout,*) 'READXYZ2 -- Too much link atoms'
+c               call fatal
+c            end if
+c            if (n12(i).ne.2) then
+c               write (iout,82)
+c   82          format (/,' Wrong definition of this frontier bond')
+c               call fatal
+c            end if
+c            ia = i12(1,i)
+c            ib = i12(2,i)
+c            if (qmmm(ia).eq.0.and.qmmm(ib).eq.2) then
+c               i12(1,i) = ia
+c               i12(2,i) = ib
+c            else if (qmmm(ia).eq.2.and.qmmm(ib).eq.0) then
+c               i12(1,i) = ib
+c               i12(2,i) = ia
+c            else
+c               write (iout,83)
+c   83          format(/,' A frontier bond must be defined between ',
+c     &                  '1 MM atom and 1 QM atom.')
+c               call fatal
+c            end if
+c            n12(i) = 0
+c         end if
+cqmmm
+c    found a hybrid Y atom in LSCF/MM
+c
+c         if (qmmm(i).eq.3) then
+c            write (iout,85) i
+c   85       format (/,i6,' is defined as a LSCF/MM frontier Y atom.')
+c            do j = 1, n12(i)
+c               k = i12(j,i)
+c If kk is a QM atom, add them to the iybond list
+c               if (qmmm(k).eq.2) then
+c                  iya = iya + 1
+c                  if (iya .gt. maxy) then
+c                     write(iout,86)
+c   86                format(/,' READXYZ2 -- Too much QM-Y SLBO bonds.')
+c                     call fatal
+c                  end if
+c                  iybond (1,iya) = atinqm(i)
+c Look what is the numbering of the current QM atom in the QM code
+c                  iybond (2,iya) = atinqm(k)
+c              end if
+c            end do
+c         end if
+cqmmm
+c      end do
+c
+c     Check the LSCF/MM frontiers.
+c
+c      if (iya.ne.nybond) then
+c         write (iout,87)  iya,nybond
+c   87    format (/,' READXYZ2  --  Counted ',i2,' QM-Y bonds but ',
+c     &           i2,' are expected.')
+c         call fatal
+c      end if
+c
+c     check for scrambled atom order and attempt to renumber
+c
+c      reorder = .false.
+c      do i = 1, n
+c         list(tag(i)) = i
+c         if (tag(i) .ne. i)  reorder = .true.
+c      end do
+c      if (reorder) then
+c         write (iout,90)
+c   90    format (/,' READXYZ2  --  Atom Labels not Sequential,',
+c     &              ' Attempting to Renumber')
+c         do i = 1, n
+c            tag(i) = i
+c            do j = 1, n12(i)
+c               i12(j,i) = list(i12(j,i))
+c            end do
+c            call sort (n12(i),i12(1,i))
+c         end do
+c      end if
+c
+c     check for atom pairs with identical coordinates
+c
+c      clash = .false.
+c      call chkxyz (clash)
+c
+c     make sure that all connectivities are bidirectional
+cqmmm
+c     except for the link atoms
+cqmmm
+c
+c      do i = 1, n
+c         do j = 1, n12(i)
+c            k = i12(j,i)
+c            do m = 1, n12(k)
+c               if (i12(m,k) .eq. i)  goto 110
+c            end do
+c            write (iout,100)  k,i
+c  100       format (/,' READXYZ2  --  Check Connection of Atom',
+c     &                 i6,' to Atom',i6)
+c            call fatal
+c  110       continue
+c         end do
+c      end do
+      return
+      end
diff -abuN source/readxyz.f source_distrib/readxyz.f
--- source/readxyz.f	2010-08-24 22:58:16.000000000 +0200
+++ source_distrib/readxyz.f	2010-08-26 11:38:23.000000000 +0200
@@ -26,6 +26,9 @@
       include 'inform.i'
       include 'iounit.i'
       include 'titles.i'
+cqmmm
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,m,ixyz
       integer next,size
       integer first,last
@@ -38,6 +41,8 @@
       character*120 xyzfile
       character*120 record
       character*120 string
+cqmmm
+      integer ia,ib,ilah,iya,kk
 c
 c
 c     initialize the total number of atoms in the system
@@ -132,6 +137,19 @@
          read (string,*,err=50,end=50)  x(i),y(i),z(i),type(i),
      &                                  (i12(j,i),j=1,maxval)
    50    continue
+cqmmm
+c      determine the qm/mm type of each atom
+c      4 types : MM (0), Link Atom (1), QM (2), Y atom (3)
+c      OBSOLETE NOW, better use the QMMM keyword
+cqmmm
+         qmmm(i) = type(i)/10000
+         type(i) = type(i) - qmmm(i)*10000
+         if (qmmm(i).lt.0 .or. qmmm(i).gt.3) then
+            write(iout,55) i
+   55       format(/,' Wrong QM/MM Type at Atom',i6)
+            goto 60
+          endif
+cqmmm
       end do
       quit = .false.
    60 continue
@@ -144,6 +162,12 @@
    70    format (/,' READXYZ  --  Error in Coordinate File at Atom',i6)
          call fatal
       end if
+cqmmm
+c     set up the qm/mm options
+cqmmm
+      call qmmmsetup
+      ilah = 0
+      iya  = 0
 c
 c     for each atom, count and sort its attached atoms
 c
@@ -157,8 +181,73 @@
          end do
    80    continue
          call sort (n12(i),i12(1,i))
+cqmmm
+c     cancel the link atom connectivity but keeps the numbering
+c     of the frontier bond atoms
+cqmmm
+         if (qmmm(i).eq.1) then
+            write (iout,81) i
+   81       format (/,i6,' is defined as a QM/MM Link Atom.')
+            ilah = ilah + 1
+            if (ilah .gt. maxy) then
+               write (iout,*) 'READXYZ -- Too much link atoms'
+               call fatal
+            end if
+            if (n12(i).ne.2) then
+               write (iout,82)
+   82          format (/,' Wrong definition of this frontier bond')
+               call fatal
+            end if
+            ia = i12(1,i)
+            ib = i12(2,i)
+            if (qmmm(ia).eq.0.and.qmmm(ib).eq.2) then
+               i12(1,i) = ia
+               i12(2,i) = ib
+            else if (qmmm(ia).eq.2.and.qmmm(ib).eq.0) then
+               i12(1,i) = ib
+               i12(2,i) = ia
+            else
+               write (iout,83)
+   83          format(/,' A frontier bond must be defined between ',
+     &                  '1 MM atom and 1 QM atom.')
+               call fatal
+            end if
+            n12(i) = 0
+         end if
+cqmmm
+c    found a hybrid Y atom in LSCF/MM
+c
+         if (qmmm(i).eq.3) then
+            write (iout,85) i
+   85       format (/,i6,' is defined as a LSCF/MM frontier Y atom.')
+            do j = 1, n12(i)
+               k = i12(j,i)
+c If kk is a QM atom, add them to the iybond list
+               if (qmmm(k).eq.2) then
+                  iya = iya + 1
+                  if (iya .gt. maxy) then
+                     write(iout,86)
+   86                format(/,' READXYZ -- Too much QM-Y SLBO bonds.')
+                     call fatal
+                  end if
+                  iybond (1,iya) = atinqm(i)
+c Look what is the numbering of the current QM atom in the QM code
+                  iybond (2,iya) = atinqm(k)
+              end if
+            end do
+         end if
+cqmmm
       end do
 c
+c     Check the LSCF/MM frontiers.
+c
+      if (iya.ne.nybond) then
+         write (iout,87)  iya,nybond
+   87    format (/,' QMMMSETUP  --  Counted ',i2,' QM-Y bonds but ',
+     &           i2,' are expected.')
+         call fatal
+      end if
+c
 c     check for scrambled atom order and attempt to renumber
 c
       reorder = .false.
@@ -185,6 +274,9 @@
       call chkxyz (clash)
 c
 c     make sure that all connectivities are bidirectional
+cqmmm
+c     except for the link atoms
+cqmmm
 c
       do i = 1, n
          do j = 1, n12(i)
diff -abuN source/runqm.f source_distrib/runqm.f
--- source/runqm.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/runqm.f	2010-08-26 11:38:25.000000000 +0200
@@ -0,0 +1,190 @@
+cqmmm
+c
+c     #####################################################################
+c     ##                                                                 ##
+c     ##  subroutine RunQM -- driver calling the QM part of a QM/MM job  ##
+c     ##                                                                 ##
+c     #####################################################################
+c
+      subroutine RunQM
+      implicit none
+      include 'sizes.i'
+      include 'atmtyp.i'
+      include 'atoms.i'
+      include 'charge.i'
+      include 'argue.i'
+      include 'energi.i'
+      include 'iounit.i'
+      include 'units.i'
+      include 'usage.i'
+      include 'files.i'
+      include 'group.i'
+      include 'inform.i'
+      include 'potent.i'
+      include 'deriv.i'
+      include 'qmmm.i'
+      character*60 minfile
+      integer i,j,k,kk,imin,espfmode,freeunit
+      real*8  fx,fy,fz,qtmp,mux,muy,muz,epf,epg(3),eph(6)
+c
+c     atomic symbols
+c
+      character*2 atosym(103)
+      save atosym
+      data atosym/' H','He',
+     $ 'Li','Be',' B',' C',' N',' O',' F','Ne',
+     $ 'Na','Mg','Al','Si',' P',' S','Cl','Ar',
+     $ ' K','Ca','Sc','Ti',' V','Cr','Mn','Fe','Co','Ni','Cu',
+     $ 'Zn','Ga','Ge','As','Se','Br','Kr',
+     $ 'Rb','Sr',' Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag',
+     $ 'Cd','In','Sn','Sb','Te',' I','Xe',
+     $ 'Cs','Ba','La','Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy',
+     $ 'Ho','Er','Tm','Yb','Lu','Hf','Ta',' W','Re','Os','Ir','Pt',
+     $ 'Au','Hg','Tl','Pb','Bi','Po','At','Rn',
+     $ 'Fr','Ra','Ac','Th','Pa',' U','Np','Pu','Am','Cm','Bk','Cf','Es',
+     $ 'Fm','Md','No','Lr'/
+c
+c     initialization
+c
+      if (qmcode .lt. 0 .or. qmcode .gt. 2) then
+         write(iout,'(A,I2)') 'RUNQM -- wrong QM code: ',qmcode
+         call fatal
+      end if
+      doespf = .true.
+      e4qmmm = 0
+c
+c     the coordinates
+c
+      if (qmcode .eq. 0 .or. qmcode .eq. 1) then
+         imin = freeunit ()
+         minfile = filename(1:leng)//'.coor'
+         open (unit=imin,file=minfile,status='unknown')
+      else
+         imin = 54
+         open (unit=imin,status='unknown')
+      end if
+      rewind (unit=imin)
+      write(imin,'(i10,/,a)') nbinqm,'Coordinates from tinker'
+      do i = 1, nbinqm
+         do j = 1, n
+            if (i.eq.atinqm(j)) write(imin,1) atosym(atomic(j)),x(j),
+     &                                        y(j),z(j)
+   1        format (a,3f12.7)
+         end do
+      end do
+      close (unit=imin)
+c
+c     the electrostatic potential and its derivatives
+c
+      if (qmcode .eq. 0 .or. qmcode .eq. 1) then
+         imin = freeunit ()
+         minfile = filename(1:leng)//'.qmmm'
+         open (unit=imin,file=minfile,status='unknown')
+      else if (qmcode .eq. 2) then
+         imin = 55
+         open (unit=imin,status='unknown')
+      end if
+      rewind (unit=imin)
+      if (qmcode.ne.2) write(imin,'(A1)') '0'
+      do i = 1, nbinqm
+         do j = 1, n
+            if (i.eq.atinqm(j)) then
+               call elecpot(j,epf,epg,eph)
+               write(imin,10) epf*bohr,
+     &                        epg(1)*bohr*bohr,
+     &                        epg(2)*bohr*bohr,
+     &                        epg(3)*bohr*bohr,
+     &                        eph(1)*bohr*bohr*bohr,
+     &                        eph(2)*bohr*bohr*bohr,
+     &                        eph(3)*bohr*bohr*bohr,
+     &                        eph(4)*bohr*bohr*bohr,
+     &                        eph(5)*bohr*bohr*bohr,
+     &                        eph(6)*bohr*bohr*bohr
+   10          format (10f11.7)
+               if (debug) then
+                  write(iout,'(/,A,I5)') ' Ext. Pot. on Tinker atom ',j
+                  write(iout,11) ' V= ',epf * bohr
+                  write(iout,12) ' X= ',epg(1)*bohr*bohr,
+     &                           ' Y= ',epg(2)*bohr*bohr,
+     &                           ' Z= ',epg(3)*bohr*bohr
+                  write(iout,12) ' XX=',eph(1)*bohr*bohr*bohr,
+     &                           ' YY=',eph(2)*bohr*bohr*bohr,
+     &                           ' ZZ=',eph(3)*bohr*bohr*bohr
+                  write(iout,12) ' XY=',eph(4)*bohr*bohr*bohr,
+     &                           ' XZ=',eph(5)*bohr*bohr*bohr,
+     &                           ' YZ=',eph(6)*bohr*bohr*bohr
+   11            format(A,F10.5)
+   12            format(3(A,F10.5))
+            end if
+            end if
+         end do
+      end do
+      close (unit=imin)
+c
+c     run the QM code
+c
+      call system(qmline)
+c
+c     get back informations from the same .qmmm file
+c
+      if (qmcode .eq. 0 .or. qmcode .eq. 1) then
+         imin = freeunit ()
+         minfile = filename(1:leng)//'.qmmm'
+         open (unit=imin,file=minfile,status='unknown')
+      else
+         imin = 56
+         open (unit=imin,status='unknown')
+      end if
+      espfmode = -1
+      rewind (unit=imin)
+      read(imin,20) ex, espfmode
+   20 format(F12.7,I5)
+      ex = ex * hartree
+c
+c     in the near future, espfmode = 1 should be ok too
+c
+c      if (espfmode.ne.0 .or. espfmode.ne.1) then
+c
+      if (espfmode.ne.0) then
+         write(iout,'(A,I5)') 'RUNQM -- wrong ESPFMODE = ',espfmode
+         call fatal
+      end if
+      do i = 1, nbinqm
+          fx = 0.0d0
+          fy = 0.0d0
+          fz = 0.0d0
+        qtmp = 0.0d0
+         mux = 0.0d0
+         mux = 0.0d0
+         mux = 0.0d0
+         if (espfmode.eq.1) then
+            read(imin,21) fx,fy,fz,qtmp
+   21       format(4F12.7)
+         else
+            read(imin,22) fx,fy,fz,qtmp,mux,muy,muz
+   22       format(7F12.7)
+         end if
+         do j = 1, n
+            if (atinqm(j) .eq. i .and. qmmm(j).ne.0) then
+               dex(1,j) = qmmmscale * fx * hartree / bohr
+               dex(2,j) = qmmmscale * fy * hartree / bohr
+               dex(3,j) = qmmmscale * fz * hartree / bohr
+               do k = 1, nion
+                  kk = iion(k)
+                  if (j .eq. kk) then
+                     pchg(k) = qtmp
+                     if (debug) write (iout,23) j,pchg(k)
+   23                format(' RUNQM -- New QM point charge value for ',
+     &                      i4,' = ',f10.5)
+                     if (abs(qtmp) .gt. 1.0d0) write (iout,24) j,pchg(k)
+   24                format(' RUNQM -- Warning: pchg(',i4,')= ',f10.5)
+                  end if
+               end do
+            end if
+         end do
+      end do
+      close (unit=imin)
+      doespf = .false.
+c
+      return
+      end
diff -abuN source/server.c source_distrib/server.c
--- source/server.c	2010-08-24 22:58:17.000000000 +0200
+++ source_distrib/server.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,492 +0,0 @@
-/*
-   This file is an interface between TINKER Fortran code
-   and a Java Server used for socket based communication.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <jni.h>
-
-/* Rename functions for Intel Compilers on Windows */
-
-#ifdef windowsintel
-#define createjvm_ CREATEJVM
-#define destroyjvm_ DESTROYJVM
-#define getmonitor_ GETMONITOR
-#define releasemonitor_ RELEASEMONITOR
-#define createserver_ CREATESERVER
-#define destroyserver_ DESTROYSERVER
-#define needupdate_ NEEDUPDATE
-#define setupdated_ SETUPDATED
-#define createsystem_ CREATESYSTEM
-#define createupdate_ CREATEUPDATE
-#define setcoordinates_ SETCOORDINATES
-#define setconnectivity_ SETCONNECTIVITY
-#define setvdw_ SETVDW
-#define setcharge_ SETCHARGE
-#define setmass_ SETMASS
-#define setatomic_ SETATOMIC
-#define setatomtypes_ SETATOMTYPES
-#define setname_ SETNAME
-#define setstory_ SETSTORY
-#define setkeyword_ SETKEYWORD
-#define setforcefield_ SETFORCEFIELD
-#define settime_ SETTIME
-#define setenergy_ SETENERGY
-#define setstep_ SETSTEP
-#define settype_ SETTYPE
-#define setfile_ SETFILE
-#define setvelocity_ SETVELOCITY
-#define setacceleration_ SETACCELERATION
-#define setinduced_ SETINDUCED
-#define setgradients_ SETGRADIENTS
-#endif
-
-/* Some global variables */
-
-JNIEnv* env = 0;
-jobject serverobject = 0;
-jclass  serverclass = 0;
-jobject systemobject = 0;
-jclass  systemclass = 0;
-jobject updateobject = 0;
-jclass  updateclass = 0;
-
-jboolean InitializeJVM() {
-   JavaVMInitArgs args;
-   JavaVMOption options[1];
-   JavaVM *vm;
-   jint numOptions = 1;
-   jint r;
-   char *classpath;
-   char *def;
-
-   classpath = getenv("CLASSPATH");
-   if (classpath == NULL) {
-      return JNI_FALSE;
-   }
-   //printf("%s\n", classpath);
-
-   def = (char *) malloc(strlen(classpath) + 20);
-   sprintf(def, "-Djava.class.path=%s", classpath);
-   options[0].optionString = def;
-
-   args.version  = JNI_VERSION_1_4;
-   args.nOptions = numOptions;
-   args.options  = options;
-   args.ignoreUnrecognized = JNI_TRUE;
-
-   r = JNI_CreateJavaVM(&vm, (void **) &env, &args);
-   if (r == JNI_OK) {
-      //printf("JNI_CreateJavaVM Success: %i\n", r);
-      return JNI_TRUE;
-   } else {
-      //printf("JNI_CreateJavaVM Error: %i\n", r);
-      return JNI_FALSE;
-   }
-}
-
-void chksocket_(int *flag) {
-   *flag = 1;
-   return;
-}
-
-void createjvm_(int *flag) {
-   if (!InitializeJVM()) {
-      *flag = 0;
-      return;
-   }
-   *flag = 1;
-   return;
-}
-
-void destroyjvm_() {
-   JavaVM *vm;
-   (*env)->GetJavaVM(env, &vm);
-   (*vm)->DestroyJavaVM(vm);
-}
-
-void getmonitor_() {
-   (*env)->MonitorEnter(env, updateobject);
-}
-
-void releasemonitor_() {
-   (*env)->MonitorExit(env, updateobject);
-}
-
-void createserver_(jint *flag) {
-   jmethodID methodID;
-   jobject temp;
-
-   // Find the Java ffe.tinker.TinkerServer class
-   serverclass = (*env)->FindClass(env, "ffe/tinker/TinkerServer");
-   if (serverclass == 0) {
-      printf("Could not find ffe.tinker.TinkerServer\n");
-      *flag = 0;
-      return;
-   }
-   methodID = (*env)->GetMethodID(env, serverclass, "<init>",
-      "(Lffe/tinker/TinkerSystem;)V");
-   temp =  (*env)->NewObject(env, serverclass, methodID, systemobject);
-   methodID = (*env)->GetMethodID(env, serverclass, "start", "()V");
-   (*env)->CallVoidMethod(env, temp, methodID, "()V");
-   serverobject =  (*env)->NewGlobalRef(env, temp);
-   (*env)->DeleteLocalRef(env, temp);
-   *flag = 1;
-   return;
-}
-
-void destroyserver_() {
-   jmethodID methodID;
-   jboolean jffe = JNI_FALSE;
-
-   // Tell the server to close down
-   methodID = (*env)->GetMethodID(env, serverclass, "stop", "()V");
-   (*env)->CallVoidMethod(env, serverobject, methodID, "()V");
-
-   // Wait while it closes any clients
-   methodID = (*env)->GetMethodID(env, serverclass, "isAlive", "()Z");
-   while ((*env)->CallBooleanMethod(env, serverobject, methodID, "()Z")) {
-   }
-
-   (*env)->DeleteGlobalRef(env, serverobject);
-   return;
-}
-
-void needupdate_(int *status) {
-   jmethodID methodID;
-   jboolean ret;
-
-   methodID = (*env)->GetMethodID(env, serverclass, "needUpdate", "()Z");
-   ret = (*env)->CallBooleanMethod(env, serverobject, methodID, "()Z");
-   if (ret) *status = 1;
-   else *status = 0;
-   return;
-}
-
-void setupdated_() {
-   jmethodID methodID;
-
-   methodID = (*env)->GetMethodID(env, serverclass, "setUpdated", "()V");
-   (*env)->CallVoidMethod(env, serverobject, methodID, "()V");
-   return;
-}
-
-jstring char2jstring(const char *str, int len) {
-   jstring result;
-   jbyteArray bytes = 0;
-   jmethodID methodID;
-   jclass class;
-
-   if ((*env)->EnsureLocalCapacity(env, 2) < 0) {
-      printf("Out of memory\n");
-      exit(-1);
-   }
-   bytes = (*env)->NewByteArray(env, len);
-   if (bytes != NULL) {
-      (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte *)str);
-      class = (*env)->FindClass(env, "Ljava/lang/String;");
-      methodID = (*env)->GetMethodID(env, class, "<init>", "([B)V");
-      result = (*env)->NewObject(env, class, methodID, bytes);
-      (*env)->DeleteLocalRef(env, bytes);
-      if (result != NULL) return result;
-    } /* else fall through */
-    printf("Problem creating java string for: %s\nLength: %i", str, len);
-    exit(-1);
-}
-
-void createsystem_(jint *atoms, jint *keywords, jint* flag) {
-   jmethodID methodID;
-   jobject temp;
-
-   systemclass = (*env)->FindClass(env, "ffe/tinker/TinkerSystem");
-   if (systemclass == 0) {
-      printf("Could not find ffe.tinker.TinkerSystem\n");
-      *flag = 0;
-      return;
-   }
-   methodID = (*env)->GetMethodID(env, systemclass, "<init>", "(II)V");
-   temp = (*env)->NewObject(env, systemclass, methodID, *atoms, *keywords);
-   systemobject = (*env)->NewGlobalRef(env, temp);
-   (*env)->DeleteLocalRef(env, temp);
-   *flag = 1;
-   return;
-}
-
-void createupdate_(jint *n, jint *type, jint* amoeba, jint* flag) {
-   jmethodID methodID;
-   jobject temp;
-   jboolean jbool;
-
-   updateclass = (*env)->FindClass(env, "ffe/tinker/TinkerUpdate");
-   if (updateclass == 0) {
-      printf("Could not find ffe.tinker.TinkerUpdate\n");
-      *flag = 0;
-      return;
-   }
-
-   methodID = (*env)->GetMethodID(env, updateclass, "<init>", "(IIZ)V");
-
-   if (amoeba == 0) jbool = JNI_FALSE;
-   else jbool = JNI_TRUE;
-
-   temp = (*env)->NewObject(env, updateclass, methodID, *n, *type, jbool);
-   updateobject  = (*env)->NewGlobalRef(env, temp);
-   (*env)->DeleteLocalRef(env, temp);
-   methodID = (*env)->GetMethodID(env,serverclass,"loadUpdate",
-                                   "(Lffe/tinker/TinkerUpdate;)V");
-   (*env)->CallObjectMethod(env, serverobject, methodID, updateobject);
-   *flag = 1;
-   return;
-}
-
-void setcoordinates_(jint *n, jdouble *x, jdouble *y, jdouble *z) {
-   jfieldID fieldID;
-   jobjectArray coords;
-   jdoubleArray jx;
-   jobject object;
-   jclass class;
-
-   object = updateobject;
-   class = updateclass;
-   if (updateobject == 0) {
-      object = systemobject;
-      class = systemclass;
-   }
-   fieldID = (*env)->GetFieldID(env, class, "coordinates", "[[D");
-   coords = (*env)->GetObjectField(env, object, fieldID);
-   jx = (*env)->GetObjectArrayElement(env, coords, 0);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, x);
-   jx = (*env)->GetObjectArrayElement(env, coords, 1);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, y);
-   jx = (*env)->GetObjectArrayElement(env, coords, 2);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, z);
-}
-
-void setconnectivity_(jint *n, jint *a, jint *b, jint *c, jint *d) {
-   jfieldID fieldID;
-   jobjectArray connect;
-   jintArray ci;
-
-   fieldID = (*env)->GetFieldID(env, systemclass, "connectivity", "[[I");
-   connect = (*env)->GetObjectField(env, systemobject, fieldID);
-   ci = (*env)->GetObjectArrayElement(env, connect, 0);
-   (*env)->SetIntArrayRegion(env, ci, 0, *n, a);
-   ci = (*env)->GetObjectArrayElement(env, connect, 1);
-   (*env)->SetIntArrayRegion(env, ci, 0, *n, b);
-   ci = (*env)->GetObjectArrayElement(env, connect, 2);
-   (*env)->SetIntArrayRegion(env, ci, 0, *n, c);
-   ci = (*env)->GetObjectArrayElement(env, connect, 3);
-   (*env)->SetIntArrayRegion(env, ci, 0, *n, d);
-}
-
-/*
-void setvdw_(jint *n, jdouble *vdw) {
-   jfieldID fieldID;
-   jdoubleArray jvdw;
-
-   fieldID = (*env)->GetFieldID(env, systemclass, "vdw", "[D");
-   jvdw = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetDoubleArrayRegion(env, jvdw, 0, *n, *vdw);
-}
-*/
-
-void setcharge_(jint *n, jdouble *charge) {
-   jfieldID fieldID;
-   jdoubleArray jcharge;
-
-   fieldID = (*env)->GetFieldID(env, systemclass, "charge", "[D");
-   jcharge = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetDoubleArrayRegion(env, jcharge, 0, *n, charge);
-}
-
-void setmass_(jint *n, jdouble *mass) {
-   jfieldID fieldID;
-   jdoubleArray jmass;
-
-   fieldID = (*env)->GetFieldID(env, systemclass, "mass", "[D");
-   jmass = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetDoubleArrayRegion(env, jmass, 0, *n, mass);
-}
-
-void setatomic_(jint *n, jint *atomic) {
-   jfieldID fieldID;
-   jintArray jatomic;
-
-   fieldID = (*env)->GetFieldID(env, systemclass, "atomic", "[I");
-   jatomic = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetIntArrayRegion(env, jatomic, 0, *n, atomic);
-}
-
-void setatomtypes_(jint *n, jint *t) {
-   jfieldID fieldID;
-   jintArray types;
-
-   fieldID = (*env)->GetFieldID(env, systemclass, "types", "[I");
-   types = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetIntArrayRegion(env, types, 0, *n, t);
-}
-
-void setname_(jint *num, char *s, jint len) {
-   jfieldID fieldID;
-   jstring string;
-   jobjectArray name;
-   jint index;
-
-   index = (*num) - 1;
-   if (index < 0) {
-      printf("Negative index into name array\n");
-      exit(-1);
-   }
-    string = char2jstring(s, len);
-   fieldID = (*env)->GetFieldID(env, systemclass, "name",
-                                "[Ljava/lang/String;");
-   name = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetObjectArrayElement(env, name, index, string);
-}
-
-void setstory_(jint *num, char *s, jint len) {
-   jfieldID fieldID;
-   jstring string;
-   jobjectArray story;
-   jint index;
-
-   index = (*num) - 1;
-   if (index < 0) {
-      printf("Negative index into story array\n");
-      exit(-1);
-   }
-   string = char2jstring(s, len);
-   fieldID = (*env)->GetFieldID(env, systemclass, "story",
-                                "[Ljava/lang/String;");
-   story = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetObjectArrayElement(env, story, index, string);
-}
-
-void setkeyword_(jint *num, char *keyword, jint len) {
-   jfieldID fieldID;
-   jstring string;
-   jobjectArray keywords;
-   jint index;
-
-   index = (*num) - 1;
-   if (index < 0) {
-      printf("Negative index into keyword array\n");
-      exit(0);
-   }
-
-   string = char2jstring(keyword, len);
-   fieldID = (*env)->GetFieldID(env, systemclass, "keywords",
-                                "[Ljava/lang/String;");
-   keywords = (*env)->GetObjectField(env, systemobject, fieldID);
-   (*env)->SetObjectArrayElement(env, keywords, index, string);
-}
-
-void setforcefield_(char *forcefield, jint len) {
-   jfieldID fieldID;
-   jstring string;
-
-   string = char2jstring(forcefield, len);
-   fieldID = (*env)->GetFieldID(env, systemclass, "forcefield",
-                                "Ljava/lang/String;");
-   (*env)->SetObjectField(env, systemobject, fieldID, string);
-}
-
-void settime_(jdouble *time) {
-   jfieldID fieldID;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "time", "D");
-   (*env)->SetDoubleField(env, updateobject, fieldID, *time);
-}
-
-void setenergy_(jdouble *e) {
-   jfieldID fieldID;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "energy", "D");
-   (*env)->SetDoubleField(env, updateobject, fieldID, *e);
-}
-
-void setstep_(jint *step) {
-   jfieldID fieldID;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "step", "I");
-   (*env)->SetIntField(env, updateobject, fieldID, *step);
-}
-
-void settype_(jint *type) {
-   jfieldID fieldID;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "type", "I");
-   (*env)->SetIntField(env, updateobject, fieldID, *type);
-}
-
-void setfile_(char *name, jint len) {
-   jfieldID fieldID;
-   jstring string;
-
-   string = char2jstring(name, len);
-   fieldID = (*env)->GetFieldID(env, systemclass, "file",
-                                "Ljava/lang/String;");
-   (*env)->SetObjectField(env, systemobject, fieldID, string);
-}
-
-void setvelocity_(jint *n, jdouble *x, jdouble *y, jdouble *z) {
-   jfieldID fieldID;
-   jobjectArray ind;
-   jdoubleArray jx;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "velocity", "[[D");
-   ind = (*env)->GetObjectField(env, updateobject, fieldID);
-   jx = (*env)->GetObjectArrayElement(env, ind, 0);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, x);
-   jx = (*env)->GetObjectArrayElement(env, ind, 1);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, y);
-   jx = (*env)->GetObjectArrayElement(env, ind, 2);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, z);
-}
-
-void setacceleration_(jint *n, jdouble *x, jdouble *y, jdouble *z) {
-   jfieldID fieldID;
-   jobjectArray ind;
-   jdoubleArray jx;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "acceleration", "[[D");
-   ind = (*env)->GetObjectField(env, updateobject, fieldID);
-   jx = (*env)->GetObjectArrayElement(env, ind, 0);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, x);
-   jx = (*env)->GetObjectArrayElement(env, ind, 1);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, y);
-   jx = (*env)->GetObjectArrayElement(env, ind, 2);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, z);
-}
-
-void setinduced_(jint *n, jdouble *x, jdouble *y, jdouble *z) {
-   jfieldID fieldID;
-   jobjectArray ind;
-   jdoubleArray jx;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "induced", "[[D");
-   ind = (*env)->GetObjectField(env, updateobject, fieldID);
-   jx = (*env)->GetObjectArrayElement(env, ind, 0);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, x);
-   jx = (*env)->GetObjectArrayElement(env, ind, 1);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, y);
-   jx = (*env)->GetObjectArrayElement(env, ind, 2);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, z);
-}
-
-void setgradients_(jint *n, jdouble *x, jdouble *y, jdouble *z) {
-   jfieldID fieldID;
-   jobjectArray ind;
-   jdoubleArray jx;
-
-   fieldID = (*env)->GetFieldID(env, updateclass, "gradients", "[[D");
-   ind = (*env)->GetObjectField(env, updateobject, fieldID);
-   jx = (*env)->GetObjectArrayElement(env, ind, 0);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, x);
-   jx = (*env)->GetObjectArrayElement(env, ind, 1);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, y);
-   jx = (*env)->GetObjectArrayElement(env, ind, 2);
-   (*env)->SetDoubleArrayRegion(env, jx, 0, *n, z);
-}
diff -abuN source/tkr2qm.f source_distrib/tkr2qm.f
--- source/tkr2qm.f	1970-01-01 01:00:00.000000000 +0100
+++ source_distrib/tkr2qm.f	2010-12-11 07:13:35.000000000 +0100
@@ -0,0 +1,1050 @@
+cqmmm
+c
+c     ##############################################################
+c     ##                                                          ##
+c     ##  program Tkr2QM -- tinker's part of a qm/mm calculation  ##
+c     ##                                                          ##
+c     ##############################################################
+c
+c     "Tkr2QM" performs the mm part of a qm/mm calculation, i.e calculates
+c     energy and gradients:
+c       - between mm atoms for electrostatic interactions ;
+c       - between atoms with at least one mm atom for other interactions.
+c     Also returns the electrostatic potential (and derivatives) on
+c     QM atoms.
+c     This program is built to be called from Molcas or Gaussian QM packages,
+c     but could be used - in principle - by any external program,
+c     provided that it is able to write/read the informations stored
+c     in the file 'foo.qmmm'.
+c
+c     The xyz and key files are supposed to be correct at the beginning
+c     of the run.
+c
+      Program Tkr2QM
+      implicit none
+      include 'sizes.i'
+      include 'argue.i'
+      include 'atmtyp.i'
+      include 'atoms.i'
+      include 'bound.i'
+      include 'charge.i'
+      include 'couple.i'
+      include 'energi.i'
+      include 'files.i'
+      include 'group.i'
+      include 'inform.i'
+      include 'iounit.i'
+      include 'moldyn.i'
+      include 'mpole.i'
+      include 'polar.i'
+      include 'potent.i'
+      include 'qmmm.i'
+      include 'scales.i'
+      include 'units.i'
+      include 'usage.i'
+      character*7 ext
+      character*20 keyword
+      character*60 minfile
+      character*120 record
+      character*120 string
+      integer i,j,k,l,ii,ic,imm,kk,nbla,freeunit,imin,nvar
+      integer ifirst
+      real*8 xqmi(maxqmmm),yqmi(maxqmmm),zqmi(maxqmmm)
+      integer next,lext,icycle
+      integer list(maxatm)
+      integer size(maxgrp)
+      real*8 energy,atchmm
+      real*8 derivs(3,maxatm)
+      real*8 epf,epg(3),eph(6)
+      real*8 minimiz1,minimum
+      real*8 grdmin,gnorm,grms
+      real*8 xx(maxvar)
+      real*8 xtmp,ytmp,ztmp,qtmp,muxtmp,muytmp,muztmp
+      logical found,chg_1st,file_1st,espf_alone
+      logical exist
+      logical doespf_save
+      logical mechemb,dorunmd,domicro
+c
+      include 'hescut.i'
+      include 'math.i'
+      integer hinit(3,maxatm)
+      integer hstop(3,maxatm)
+      integer hindex(maxhess)
+      integer qmmmmap(maxqmmm)
+      integer ihes,nfreq,nvib,m,mm,ndummy,ivib
+      integer ij,ijn,imap,jmap
+      real*8 h(maxhess),hdiag(3,maxatm)
+      real*8 matrix((maxvib+1)*maxvib/2)
+      real*8 matrix2((maxvib+1)*maxvib/2)
+      real*8 eigen(maxvib)
+      real*8 vects(maxvib,maxvib)
+      real*8 ap(maxvib+1),b(maxvib+1)
+      real*8 p(maxvib+1),w(maxvib+1)
+      real*8 ta(maxvib+1),tb(maxvib+1)
+      real*8 ty(maxvib+1)
+      real*8 mass2(maxatm)
+      real*8 factor,vnorm
+      character*1 eigunits(maxvib)
+      character*120 hessfile
+      character*1 axis(3)
+      data axis  / 'X','Y','Z' /
+c
+      include 'bath.i'
+      include 'bond.i'
+      include 'mdstuf.i'
+      include 'analyz.i'
+      integer istep,idyn,iavg
+      integer modstep
+      character*60 dynfile 
+c
+      logical doqtmp
+      character*12 MMSymbol,ctmp
+      character*2 zsymbol(0:103)
+      save zsymbol
+      data zsymbol/
+     &      ' X',
+     &      ' H','He','Li','Be',' B',' C',' N',' O',' F','Ne',
+     &      'Na','Mg','Al','Si',' P',' S','Cl','Ar',' K','Ca',
+     &      'Sc','Ti',' V','Cr','Mn','Fe','Co','Ni','Cu','Zn',
+     &      'Ga','Ge','As','Se','Br','Kr','Rb','Sr',' Y','Zr',
+     &      'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
+     &      'Sb','Te',' I','Xe','Cs','Ba','La','Ce','Pr','Nd',
+     &      'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
+     &      'Lu','Hf','Ta',' W','Re','Os','Ir','Pt','Au','Hg',
+     &      'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
+     &      'Pa',' U','Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
+     &      'Md','No','Lr'
+     &      /
+c
+      external minimiz1
+      external optsave
+c
+c     Set up the structure and mechanics calculation.
+c
+      domicro = .false.
+      dorunmd = .false.
+      call initial
+      call getxyz
+      call mechanic
+      mechemb = (e4qmmm .eq. -1)
+c
+c     Check some incompatibilities
+c
+      if (qmline(1:7) .ne. 'NOTHING') then
+         write(iout,*) qmline
+         write (iout,*) ' TKR2QM -- QMMM-EXTERNAL keyword found. Abort'
+         call fatal
+      end if
+      doespf_save = doespf
+      do i = 1, n
+         if (atinqm(i) .ne. 0 .and.  .not.use(i)) then
+            write (iout,9) i
+    9       format(' TKR2QM -- ',i6,' was inactive. Now active.')
+            use(i) = .true.
+            nuse = nuse + 1
+         end if
+c
+c     Atoms in QM input have to be put in group 0 to make them inactive
+c     in rigid body calculations
+c
+         if (atinqm(i) .ne. 0 .and. use_group) then
+            j = grplist(i)
+            grplist(i) = 0
+            kgrp(i) = 0
+            if (i .eq. igrp(1,j)) igrp(1,j) = 1
+            if (i .eq. igrp(2,j)) then 
+               igrp(2,j) = 0
+               ngrp = ngrp - 1
+            end if
+         end if
+      end do
+      if ((use_polar .or. use_mpole) .and. nybond.ne.0) then
+         write (iout,*) ' TKR2QM -- QM/MM Pol with LSCF NYI !!!'
+         call fatal
+      end if
+      do i = 1, n
+         if (qmmm(i) .eq. 0 .and. atinqm(i) .ne. 0 .and. use_mpole) then
+            write (iout,*) 'TKR2QM -- cannot include a multipolar MM ',
+     &        'atom in the QM input'
+            call fatal
+         end if
+      end do
+      chg_1st = .false.
+      inquire(file='first.xyz',exist=file_1st)
+c
+c     Now read new coordinates coming from the QM code
+c     Optionally read new point charges (and dipoles ?)
+c     Must be in a file named foo.qmmm
+c
+      imin = freeunit ()
+      minfile = filename(1:leng)//'.qmmm'
+      inquire (file=minfile,exist=found)
+      if (.not.found) goto 23
+      open (unit=imin,file=minfile,status='old')
+      rewind (unit=imin)
+      read (imin,10,end=20,err=21)  record
+   10 format(a120)
+      next = 1
+      call gettext (record,keyword,next)
+      call upcase(keyword)
+      if (keyword(1:3) .ne. 'GAU' .and. keyword(1:3) .ne. 'MOL') goto 20
+      call gettext (record,string,next)
+      read (string,*) j
+      if (j .eq. 0) then
+         domicro = .false.
+         dorunmd = .false.
+      else if (j .eq. -1) then
+         write(iout,*) 'Tinker prepares an input for ',keyword(1:10)
+         close (unit=imin)
+         imin = freeunit ()
+         open (unit=imin,file=minfile,status='old')
+         rewind (unit=imin)
+         write(imin,'(i10)') nbinqm
+         write(imin,'(a8)') 'Angstrom'
+         do j = 1, nbinqm
+            i = 1
+            do while (j .ne. atinqm(i) .and. i .le. n)
+               i = i + 1
+            end do
+            MMSymbol='            '
+            if (qmmm(i) .eq. 0) then
+               qtmp = 0.0d0
+               doqtmp = .false.
+               if (use_charge) then
+                  do k = 1, nion
+                     kk = iion(k)
+                     if (i .eq. kk) then
+                       doqtmp = .true.
+                       qtmp = pchg(k)
+                     end if
+                  end do
+               else if (use_polar .or. use_mpole) then
+                  write(iout,*) ' TKR2QM -- Direct QM/MM'//
+     &                        ' electrostatics cannot use multipoles'
+                  call fatal
+               end if
+               if (doqtmp) then
+                  write(ctmp,'(f12.3)') qtmp
+                  do l = 1, len(ctmp)
+                     if (ctmp(l:l) .ne. ' ') goto 8
+                  end do
+    8             MMSymbol='_(MM-'//ctmp(l:)//')'
+               else
+                  MMSymbol='_MM         '
+               end if
+            end if
+            write(imin,'(a2,a12,3f12.6)') zsymbol(atomic(i)),
+     &                                 MMSymbol(1:12),x(i),y(i),z(i)
+         end do
+         close(unit=imin)
+         goto 9998
+      end if
+      call gettext (record,string,next)
+      read (string,*) j
+      doespf = j.eq.1
+      doespf_save = doespf
+      call gettext (record,string,next)
+      read (string,*) j
+      espf_alone = j.eq.0
+      if ((use_mpole .or. use_polar) .and. .not.doespf) then
+         write (iout,*) ' TKR2QM -- Amoeba FF works only with ESPF'
+         call fatal
+      end if
+c      if (use_bounds .and. .not.doespf) then
+c         write (iout,*) ' TKR2QM -- QM/MM PBC requires ESPF !!!'
+c         call fatal
+c      end if
+      if (dorunmd .and. .not.doespf) then
+         write (iout,*) ' TKR2QM -- QM/MM-MD requires ESPF !!!'
+         call fatal
+      end if
+      if (verbose) write (iout,11) keyword
+   11 format(/,' Updated coordinates given by ',a20,/)
+      do j = 1, nbinqm
+         xtmp = 1.0d10
+         ytmp = 1.0d10
+         ztmp = 1.0d10
+         read (imin,*,end=21,err=21) xtmp, ytmp, ztmp
+         i = 0
+   12    i = i + 1
+         if (i .lt. n .and. atinqm(i) .ne. j) goto 12
+         if (atinqm(i) .eq. j) then
+            x(i) = xtmp
+            y(i) = ytmp
+            z(i) = ztmp
+         else
+            write (iout,13) j
+   13       format(' TKR2QM -- ',i3,'th QM atom has no Tinker ',
+     &             ' equivalent')
+            call fatal
+         end if
+         if (verbose) write (iout,14) i,x(i),y(i),z(i)
+   14    format(i4,3F15.6)
+      end do
+      read  (imin,10,end=20,err=21)  record
+      next = 1
+      call gettext (record,keyword,next)
+      call upcase(keyword)
+      if (keyword(1:10) .eq. 'MULTIPOLES') then
+         chg_1st = .true. 
+         if (verbose) write (iout,'(/,A,/)') ' Updated multipoles'
+   15    read (imin,'(A120)',end=20,err=21) record
+         qtmp = 0.0d0
+         muxtmp = 0.0d0
+         muytmp = 0.0d0
+         muztmp = 0.0d0
+         next = 1
+         read (record,'(i6,4f15.8)') j,qtmp,muxtmp,muytmp,muztmp
+         if (mechemb) then
+            qtmp = 0.0d0
+            muxtmp = 0.0d0
+            muytmp = 0.0d0
+            muztmp = 0.0d0
+         end if
+         i = 0
+   16    i = i + 1
+         if (i .lt. n .and. atinqm(i) .ne. j) goto 16
+c Case 1: this is a QM atom, its MM charge must be updated
+         if (atinqm(i) .eq. j .and. qmmm(i).ne.0) then
+            if (use_polar .or. use_mpole) then
+               do k = 1, npole
+                  kk = ipole(k)
+                  if (i .eq. kk) then
+                     pole(1,k) = qtmp
+                     pole(2,k) = muxtmp
+                     pole(3,k) = muytmp
+                     pole(4,k) = muztmp
+                     do l = 5, maxpole
+                        pole(l,k) = 0.0d0
+                     enddo
+                     if (verbose) write (iout,18) i,pole(1,k),pole(2,k),
+     &                                            pole(3,k),pole(4,k)
+   18                format(' New QM point charge value for atom ',i4,
+     &                      ' = ',f15.8,/,'    New Dipole is : ',3f15.8)
+                  end if
+               end do
+            else if (use_charge) then
+               do k = 1, nion
+                  kk = iion(k)
+                  if (i .eq. kk) then
+                     pchg(k) = qtmp
+                     if (verbose) write (iout,17) i,pchg(k)
+   17                format(' New QM point charge value for atom ',i4,
+     &                      ' = ',f10.5)
+                  end if
+               end do
+            end if
+c Case 2: this is a MM atom, its MM charge does not change
+         else if (atinqm(i) .eq. j .and. qmmm(i) .eq. 0) then
+            if (verbose) write (iout,181) i
+  181       format(i4,' is a MM atom, its charge remains the same.')
+c Case 3: bug in the input
+         else
+            write (iout,19) j
+   19       format(' TKR2QM -- ',i3,'th QM atom has no Tinker ',
+     &             ' equivalent or is defined like a MM atom')
+            call fatal
+         end if
+         goto 15
+      end if
+   20 close (unit=imin)
+      goto 25
+c
+   21 write (iout,22) minfile,string
+   22 format(/,' Error when reading ',a60,/,' Last string was: ',/,a120)
+      call fatal
+   23 write (iout,24) minfile
+   24 format(/,' TKR2QM -- File not found: ',a60)
+   25 continue
+c
+c    MICROIT OFF
+c
+      if (micromode .eq. 0) domicro = .false.
+c
+c    MICROIT ON - microit with standalone ESPF (having charges) or during
+c                 the first call in SCF
+c
+      if (micromode .eq. 2) domicro = (espf_alone .and. chg_1st) .or.
+     &   (.not.file_1st .and. chg_1st)
+c
+c    MICROIT FULL:
+c
+      if (micromode .eq. 1) then
+c
+c    if QMMM-MD OFF, microit is only inside SCF
+c
+         if (mmmdmode .eq. 0) domicro = .not.espf_alone
+c
+c    if QMMM-MD ON or FULL, microit are like MICROIT ON
+c
+
+         if ((mmmdmode .eq. 1) .or. (mmmdmode .eq. 2))
+     &      domicro = (espf_alone .and. chg_1st) .or. (.not.file_1st 
+     &                .and. chg_1st)
+      end if
+c
+c     If requested, perform the MM minimization.
+c     MM minimization may also be performed before MD
+c     At least 1 MM atom must be active (see the ACTIVE keyword)
+c
+      if (domicro) then
+         domicro = .false.
+         do i = 1, n
+            if (atinqm(i).eq. 0 . and. use(i)) domicro = .true.
+         end do
+      end if
+c
+c     Begin of the microiteration run
+c
+      if (domicro) then
+         iwrite = 0
+         e4qmmm = 3
+         doespf_save = doespf
+         doespf = .false.
+         do i = 1, n
+            if ((atinqm(i).ne.0) .and. use(i)) then 
+               use(i) = .false.
+               nuse = nuse - 1
+            end if
+         end do
+c
+c     get termination criterion as RMS gradient per atom
+c
+         grdmin = -1.0d0
+         call nextarg (string,exist)
+         if (exist)  read (string,*,err=32,end=32)  grdmin
+   32    continue
+         if (grdmin .le. 0.0d0)  grdmin = 0.01d0
+         write (iout,33) grdmin
+   33    format(/,' Convergence criterion = ',f7.4,
+     &            ' kcal/mol/angstrom.')
+         if (debug) then
+            write (iout,34)
+   34       format (/,' Analysis before microiterations')
+            call analysis(minimum)
+         end if
+c
+c     set scaling parameter for function and derivative values;
+c     use square root of median eigenvalue of typical Hessian
+c
+         set_scale = .true.
+         nvar = 0
+         do i = 1, n
+            if (use(i)) then
+               do j = 1, 3
+                  nvar = nvar + 1
+                  scale(nvar) = 12.0d0
+               end do
+            end if
+         end do
+c
+c     scale the coordinates of each active atom
+c
+         nvar = 0
+         do i = 1, n
+            if (use(i)) then
+               nvar = nvar + 1
+               xx(nvar) = x(i) * scale(nvar)
+               nvar = nvar + 1
+               xx(nvar) = y(i) * scale(nvar)
+               nvar = nvar + 1
+               xx(nvar) = z(i) * scale(nvar)
+            end if
+         end do
+c
+c     make the call to the optimization routine
+c
+         call lbfgs (nvar,xx,minimum,grdmin,minimiz1,optsave)
+c
+c     unscale the final coordinates for active atoms
+c
+         nvar = 0
+         do i = 1, n
+            if (use(i)) then
+               nvar = nvar + 1
+               x(i) = xx(nvar) / scale(nvar)
+               nvar = nvar + 1
+               y(i) = xx(nvar) / scale(nvar)
+               nvar = nvar + 1
+               z(i) = xx(nvar) / scale(nvar)
+            end if
+         end do
+c
+c    save the minimized structure for further use
+c
+         if (.not. file_1st) then
+            ifirst = freeunit ()
+            open(unit=ifirst,file='first.xyz',status='new')
+            call prtxyz (ifirst)
+            close (unit=ifirst)
+         end if
+c
+c     compute the final function and RMS gradient values
+c
+         call gradient (minimum,derivs)
+         gnorm = 0.0d0
+         do i = 1, n
+            if (use(i)) then
+               do j = 1, 3
+                  gnorm = gnorm + derivs(j,i)**2
+               end do
+            end if
+         end do
+         gnorm = sqrt(gnorm)
+         grms = gnorm / sqrt(dble(nvar/3))
+c
+c     write out the final function and gradient values
+c
+         write (iout,35)  minimum,grms,gnorm
+   35    format (/,' Final Function Value :',2x,f20.8,
+     &           /,' Final RMS Gradient :',4x,d20.8,
+     &           /,' Final Gradient Norm :',3x,d20.8)
+         doespf = doespf_save
+      end if
+c
+c     Compute the MM component of the QM/MM energy (excluding
+c     electrostatic interactions).
+c
+c     WARNING: also some MM/MM interactions must be discarded
+c     if the ESPF method is used !!!
+c
+      doespf = doespf_save
+      if (mechemb) then
+         write(iout,'(/,A)') ' QM/MM mechanical embedding activated'
+      else if (doespf) then 
+         write(iout,'(/,A)') ' QM/MM ESPF electrostatics activated'
+      else
+         write(iout,'(/,A)') ' QM/MM direct electrostatics activated'
+      end if
+      e4qmmm = 0
+      do i = 1, n
+         use(i) = use(i) .or. (atinqm(i).ne.0)
+      end do
+c
+c     Components of MM energy
+c
+      if (debug) then
+         write (iout,36)
+   36    format (/,' Analysis of the MM energy')
+         call analysis(minimum)
+      end if
+c
+c     MM energy and gradients
+c     Computed now if MD is not run,
+c     otherwise average ones are used
+c
+c
+      if (.not. dorunmd) then 
+         call gradient (energy,derivs)
+         if (verbose) then 
+            write (iout,37) energy
+   37       format(/,' Full MM part of the QM/MM energy: ',2x,f20.8)
+         end if
+         if (debug) then
+            write(iout,'(/)')
+            do imm = 1, n
+               if (use(imm)) write(iout,38) imm,derivs(1,imm),
+     &                                     derivs(2,imm),derivs(3,imm)
+   38       format(' Gradient on atom ',i5,' = ',3f20.8)
+            end do
+         endif
+         write(iout,'(/,A)') ' MM energy components passed:' 
+c
+c    If MD is run, the energy terms to be passed to QM are 
+c    the average energies computed in avgmd.f
+c
+      else
+         eb = avgen(1)
+         ea = avgen(2)
+         eba = avgen(3)
+         eub = avgen(4)
+         eaa = avgen(5)
+         eopb = avgen(6)
+         eopd = avgen(7)
+         eid = avgen(8)
+         eit = avgen(9)
+         et = avgen(10)
+         ebt = avgen(11)
+         ett = avgen(12)
+         ev = avgen(13)
+         ec = avgen(14)
+         ecd = avgen(15)
+         ed = avgen(16)
+         em = avgen(17)
+         ep = avgen(18)
+         er = avgen(19)
+         es = avgen(20)
+         elf = avgen(21)
+         eg = avgen(22)
+         ex = avgen(23)  
+         write(iout,'(/,A)') ' Average MM energy components passed:'
+      end if
+c
+      if(eb  .ne.0.0d0) write(iout,39) ' eb   = ',eb  /hartree,eb
+      if(ea  .ne.0.0d0) write(iout,39) ' ea   = ',ea  /hartree,ea
+      if(eba .ne.0.0d0) write(iout,39) ' eba  = ',eba /hartree,eba
+      if(eub .ne.0.0d0) write(iout,39) ' eub  = ',eub /hartree,eub
+      if(eaa .ne.0.0d0) write(iout,39) ' eaa  = ',eaa /hartree,eaa
+      if(eopb.ne.0.0d0) write(iout,39) ' eopb = ',eopb/hartree,eopb
+      if(eopd.ne.0.0d0) write(iout,39) ' eopd = ',eopd/hartree,eopd
+      if(eid .ne.0.0d0) write(iout,39) ' eid  = ',eid /hartree,eid
+      if(eit .ne.0.0d0) write(iout,39) ' eit  = ',eit /hartree,eit
+      if(et  .ne.0.0d0) write(iout,39) ' et   = ',et  /hartree,et
+      if(ebt .ne.0.0d0) write(iout,39) ' ebt  = ',ebt /hartree,ebt
+      if(ett .ne.0.0d0) write(iout,39) ' ett  = ',ett /hartree,ett
+      if(ev  .ne.0.0d0) write(iout,39) ' ev   = ',ev  /hartree,ev
+      if(ec  .ne.0.0d0) write(iout,39) ' ec   = ',ec  /hartree,ec
+      if(ecd .ne.0.0d0) write(iout,39) ' ecd  = ',ecd /hartree,ecd
+      if(ed  .ne.0.0d0) write(iout,39) ' ed   = ',ed  /hartree,ed
+      if(em  .ne.0.0d0) write(iout,39) ' em   = ',em  /hartree,em
+      if(ep  .ne.0.0d0) write(iout,39) ' ep   = ',ep  /hartree,ep
+      if(er  .ne.0.0d0) write(iout,39) ' er   = ',er  /hartree,er
+      if(es  .ne.0.0d0) write(iout,39) ' es   = ',es  /hartree,es
+      if(elf .ne.0.0d0) write(iout,39) ' elf  = ',elf /hartree,elf
+      if(eg  .ne.0.0d0) write(iout,39) ' eg   = ',eg  /hartree,eg
+      if(ex  .ne.0.0d0) write(iout,39) ' ex   = ',ex  /hartree,ex
+   39 format(A,F15.8,' ua = ',F15.8,' kcal/mol')
+c
+c     Output the results in foo.qmmm
+c     All data are not converted to atomic units
+c
+      imin = freeunit ()
+      minfile = filename(1:leng)//'.qmmm'
+      open (unit=imin,file=minfile,status='unknown')
+      rewind (unit=imin)
+c
+c     Writes the energy, the coordinates, the forces and the partial charges
+c
+c      if ((micromode .eq. 1 .and. .not.(mmmdmode .eq. 0))
+c     &   .or. mmmdmode .eq. 1) write(imin,'(A14)') 'TKFullCoupling'
+      if (micromode .eq. 1 .or. mmmdmode .eq. 1)
+     &   write(imin,'(A14)') 'TKFullCoupling'
+      if (use_polar) write (imin,'(A7)') 'TKPolar'
+      write(imin,40) (n-nbinqm)
+   40 format ('TKOnlyMM    ',i5)
+      write (imin,41) energy
+   41 format ('TKEnergy    ',f20.8)
+      j = 0
+      do imm = 1, n
+         if (dorunmd) then
+            do k = 1, 3
+               if (mmmdmode .eq. 1) then
+                  x(imm)=xpre(imm)
+                  y(imm)=ypre(imm)
+                  z(imm)=zpre(imm)
+               end if
+               if (atinqm(imm) .ne. 0) then
+                  derivs(k,imm) = avgderiv(k,imm)
+               end if
+            end do
+         end if
+         i = atinqm(imm)
+         if (i.ne.0) then
+            write (imin,42) i,x(imm),y(imm),z(imm)
+   42       format ('TKCoords    ',i5,3f20.8)
+            if (dorunmd) then
+               write (imin,43) i,avgderiv(1,imm),avgderiv(2,imm),
+     &                                           avgderiv(3,imm)
+            else
+               write (imin,43) i,derivs(1,imm),derivs(2,imm),
+     &                                         derivs(3,imm)
+            end if
+   43       format ('TKGradient  ',i5,3f20.8)
+            atchmm = 0.0d0
+            do ii = 1, nion
+               ic = iion(ii)
+               if (imm.eq.ic .and. qmmm(imm).eq.0)
+     &            atchmm = pchg(ii)
+               if (imm.eq.ic .and. qmmm(imm) .eq. 3) then
+                  j = j + 1
+                  atchmm = qybond(j)
+               end if
+               if (.not. use_charge) atchmm = 0.0d0
+            end do
+            if (.not. mechemb) write (imin,44) i,atchmm
+   44       format ('TKActPChg   ',i5,f10.4)
+         else
+            write(imin,45) atomic(imm),x(imm),y(imm),z(imm)
+   45       format ('TKInaCoords ',i5,3f20.8)
+         end if
+      end do
+c
+c     Copy inactive MM point charges (coordinates and values)
+c
+      if (.not. mechemb .and. .not.doespf .and. use_charge) then
+         imm = 0
+         do ii = 1, nion
+            i = iion(ii)
+            if (atinqm(i).eq.0) then
+               imm = imm + 1
+               write (imin,46) x(i), y(i), z(i), pchg(ii)
+   46          format ('TKInactPChg ',3f20.8,f10.4)
+            endif
+         end do
+         nbla = imm
+         write (imin,47) nbla
+   47    format ('TKNbInacPChg',i5)
+      end if
+c
+c     Copy the LSCF/MM frontier bonds
+c
+      do i = 1, nybond
+         write (imin,48) iybond(1,i),iybond(2,i)
+   48    format ('TKYBond     ',2i5)
+      end do
+c
+c     Determine the scaling factors defining a link atom position
+c     g = r(QM-LAH) / r(QM-MM) where r = the sum of the vdW radii
+c
+      j = 0
+      do i = 1, n
+         if (qmmm(i) .eq. 1) then
+            j = j + 1
+            if (lahg(j) .le. 0.0d0) then
+              lahg(j) = (rcov(atomic(i12(2,i)))+rcov(atomic(i)))/
+     &                  (rcov(atomic(i12(2,i)))+rcov(atomic(i12(1,i))))
+            end if
+            write (imin,49) atinqm(i),(atinqm(i12(k,i)),k=1,2),lahg(j)
+  49        format('TKLAH       ',3i5,f6.3)
+         end if
+      end do
+c
+c     Compute the electrostatic potential (and derivatives)
+c     on the QM atoms
+c
+      if (doespf.and.use_charge.and..not.(use_mpole.or.use_polar)) then
+         do i = 1, n
+            j = atinqm(i)
+            if (j.ne.0) then
+               if (dorunmd) then
+c                  write(iout,*) 'EPavg: ',epavg(i)
+                  epf = epavg(i)
+                  do k = 1, 3 
+                     epg(k) = epgavg(k,i)
+                     eph(k) = ephavg(k,i)
+                  end do
+                  do k = 4, 6
+                     eph(k) = ephavg(k,i)
+                  end do
+               else
+                  call elecpot(i,epf,epg,eph)
+               end if
+               if (mechemb .and. qmmm(i).ne.0) then
+                  epf    = 0.0d0
+                  epg(1) = 0.0d0
+                  epg(2) = 0.0d0
+                  epg(3) = 0.0d0
+                  eph(1) = 0.0d0
+                  eph(2) = 0.0d0
+                  eph(3) = 0.0d0
+                  eph(4) = 0.0d0
+                  eph(5) = 0.0d0
+                  eph(6) = 0.0d0
+               end if
+               write(imin,50) j,epf,epg(1),epg(2),epg(3)
+   50          format ('TKESPF1     ',i5,4f20.8)
+               write(imin,51) j,eph(1),eph(2),eph(3)
+   51          format ('TKESPF21    ',i5,3f20.8)
+               write(imin,52) j,eph(4),eph(5),eph(6)
+   52          format ('TKESPF22    ',i5,3f20.8)
+               if (verbose) then
+                  write(iout,'(/,A,I5)') ' Ext. Pot. on Tinker atom ',i
+                  write(iout,53) ' V= ',epf
+                  write(iout,54) ' X= ',epg(1),
+     &                           ' Y= ',epg(2),
+     &                           ' Z= ',epg(3)
+                  write(iout,54) ' XX=',eph(1),
+     &                           ' YY=',eph(2),
+     &                           ' ZZ=',eph(3)
+                  write(iout,54) ' XY=',eph(4),
+     &                           ' XZ=',eph(5),
+     &                           ' YZ=',eph(6)
+   53             format(A,F10.5)
+   54             format(3(A,F10.5))
+               end if
+            end if
+         end do
+      end if
+c
+c     Compute the electrostatic potential (and derivatives)
+c     on the QM atoms, in the case of dipoles.
+c
+      if (doespf .and. (use_mpole .or. use_polar)) then
+         do i = 1, n
+            j = atinqm(i)
+            if (j.ne.0) then
+               call elecpol(i,epf,epg,eph)
+               if (mechemb .and. qmmm(i).ne.0) then
+                  epf    = 0.0d0
+                  epg(1) = 0.0d0
+                  epg(2) = 0.0d0
+                  epg(3) = 0.0d0
+                  eph(1) = 0.0d0
+                  eph(2) = 0.0d0
+                  eph(3) = 0.0d0
+                  eph(4) = 0.0d0
+                  eph(5) = 0.0d0
+                  eph(6) = 0.0d0
+               end if
+               write(imin,50) j,epf,epg(1),epg(2),epg(3)
+               write(imin,51) j,eph(1),eph(2),eph(3)
+               write(imin,52) j,eph(4),eph(5),eph(6)
+               if (verbose) then
+                  write(iout,'(/,A,I5)') ' Ext. Pot. on Tinker atom ',i
+                  write(iout,53) ' V= ',epf
+                  write(iout,54) ' X= ',epg(1),
+     &                           ' Y= ',epg(2),
+     &                           ' Z= ',epg(3)
+                  write(iout,54) ' XX=',eph(1),
+     &                           ' YY=',eph(2),
+     &                           ' ZZ=',eph(3)
+                  write(iout,54) ' XY=',eph(4),
+     &                           ' XZ=',eph(5),
+     &                           ' YZ=',eph(6)
+               end if
+            end if
+         end do
+      end if
+c
+c     Sub-Hessian for the atoms defined in the QM code
+c
+      e4qmmm = 3
+      doespf = .false.
+      if (.not. doqmmmhessian) goto 70
+      if (debug) then
+         write (iout,60)
+   60    format (/,' Analysis before Hessian')
+         call analysis(minimum)
+      end if
+      hesscut = 0.0d0
+      call hess4qm (h,hinit,hstop,hindex,hdiag)
+      if (debug) then
+         hessfile = filename(1:leng)//'.hes'
+         call version (hessfile,'new')
+         ihes = freeunit ()
+         open (unit=ihes,file=hessfile,status='new')
+         write (iout,61)  hessfile
+   61    format (/,' Hessian Matrix written to File :  ',a40)
+         write (ihes,62)
+   62    format (/,' Diagonal Hessian Elements  (3 per Atom)',/)
+         do i = 1, n
+	    if (atinqm(i).ne.0) then
+               write (ihes,63)  (hdiag(j,i),j=1,3)
+            end if
+         end do
+   63    format (6f12.4)
+         do i = 1, n
+	    if (atinqm(i).ne.0) then
+               do j = 1, 3
+                  if (hinit(j,i) .le. hstop(j,i)) then
+                     write (ihes,64)  i,axis(j)
+   64              format (/,' Off-diagonal Hessian Elements for Atom',
+     & i6,1x,a1,/)
+                     write (ihes,65)  (h(k),k=hinit(j,i),hstop(j,i))
+   65                format (6f12.4)
+                  end if
+               end do
+	    end if
+         end do
+         close (unit=ihes)
+      end if
+c
+c     store upper triangle of the Hessian in "matrix"
+c
+      ihes = 0
+      do i = 1, n
+         do j = 1, 3
+            ihes = ihes + 1
+            matrix(ihes) = hdiag(j,i)
+            do k = hinit(j,i), hstop(j,i)
+               ihes = ihes + 1
+               matrix(ihes) = h(k)
+            end do
+         end do
+      end do
+c
+c     tentatively re-organize the Hessian upper triangle
+c
+c     first I need a mapping array
+c
+      do i = 1, nbinqm
+         qmmmmap(i) = -1
+         j = 0
+  66     j = j + 1
+         if (atinqm(j) .ne. i .and. j .lt. n) goto 66
+         if (atinqm(j) .ne. i) then
+            write (iout,'(A)') 'TKR2QM -- error'
+	    call fatal
+         else
+            qmmmmap(i) = j
+         end if
+      end do
+      do i = 1, 3*nbinqm
+         do j = i, 3*nbinqm
+            ij = ((2 * (3*nbinqm) - i) * (i - 1))/2 + j
+            imap = 3*(qmmmmap((i-1)/3+1)-1)
+            if (mod(i,3) .eq. 0) then
+               imap = imap + 3
+            else
+               imap = imap + mod(i,3)
+            end if
+            jmap = 3*(qmmmmap((j-1)/3+1)-1)
+            if (mod(j,3) .eq. 0) then
+               jmap = jmap + 3
+            else
+               jmap = jmap + mod(j,3)
+            end if
+            if (jmap .ge. imap) then
+               ijn=((2*(3*n)-imap)*(imap-1))/2 + jmap
+            else
+               ijn=((2*(3*n)-jmap)*(jmap-1))/2 + imap
+            end if
+            matrix2(ij) = matrix(ijn)
+         end do
+      end do
+      do i = 1, nbinqm
+         write(imin,67) i,(hdiag(j,qmmmmap(i)),j=1,3)
+   67    format ('TKHDiag     ',i5,3f20.8)
+      end do
+      do i = 1, 3*nbinqm-1
+         ij = ((2 * (3*nbinqm) - i) * (i - 1))/2 + i
+         m = (i-1)/3+1
+         mm = i-3*(m-1)
+         write (imin,68) m,mm,3*nbinqm-i
+   68    format ('TKHOff     ',i5,1x,i5,1x,i5)
+         write (imin,69) (matrix2(ij+k),k=1,3*nbinqm-i)
+   69    format (4f20.8)
+      end do
+   70 write(imin,'(A)') 'TKEnd'
+      close (unit=imin)
+c
+      if (verbose .and. doqmmmhessian) then
+c
+c        perform diagonalization to get Hessian eigenvalues
+c
+         nfreq = 3 * n
+         do i = 1, n
+            if (atomic(i) .eq. 0) then
+               ndummy = ndummy + 1
+               mass(i) = 0.001d0
+            end if
+            mass2(i) = sqrt(mass(i))
+         end do
+         nvib = nfreq - 3*ndummy
+         call diagq (nfreq,maxvib,nfreq,matrix,eigen,vects,
+     &                        ap,b,p,w,ta,tb,ty)
+         write (iout,80)
+  80     format (/,' Eigenvalues of the Hessian Matrix :',/)
+         write (iout,81)  (i,eigen(i),i=1,nvib)
+  81     format (5(i5,f9.3,1x))
+         write (iout,82)
+  82     format ()
+c
+c        perform diagonalization to get block Hessian eigenvalues
+c
+         nfreq = 3 * nbinqm
+         nvib = nfreq
+         call diagq (nfreq,maxvib,nfreq,matrix2,eigen,vects,
+     &                        ap,b,p,w,ta,tb,ty)
+         write (iout,83)
+  83     format (/,' Eigenvalues of the QM-block Hessian Matrix :',/)
+         write (iout,84)  (i,eigen(i),i=1,nvib)
+  84     format (5(i5,f9.3,1x))
+         write (iout,85)
+  85     format ()
+      end if
+c
+c     save the coordinates into a file
+c
+      imin = freeunit ()
+      minfile = filename(1:leng)//'.xyz'
+      open (unit=imin,file=minfile,status='unknown')
+      rewind (unit=imin)
+      call prtxyz (imin)
+      close (unit=imin)
+c
+c     Save the coordinates into a numbered file too
+c     only if the microiteration mode is ON
+c
+      if ((domicro).and.(.not.dorunmd)) then
+         icycle = 0
+         exist = .true.
+         lext = 3
+ 1999    icycle = icycle + 1
+         call numeral (icycle,ext,lext)
+         minfile = filename(1:leng)//'.'//ext(1:lext)
+         inquire (file=minfile,exist=exist)
+         if (exist) goto 1999 
+         imin = freeunit ()
+         open (unit=imin,file=minfile,status='unknown')
+         call prtxyz (imin)
+         close (unit=imin)
+      end if
+c
+c     perform any final tasks before program exit
+c
+9998  write(iout,9999)
+9999  format (/,' End of this Tinker run',//)
+      call final
+      end
+c
+c
+c     ###############################################################
+c     ##                                                           ##
+c     ##  function minimiz1  --  energy and gradient for minimize  ##
+c     ##                                                           ##
+c     ###############################################################
+c
+c
+c     "minimiz1" is a service routine that computes the energy and
+c     gradient for a low storage BFGS optimization in Cartesian
+c     coordinate space
+c
+c
+      function minimiz1 (xx,g)
+      implicit none
+      include 'sizes.i'
+      include 'atoms.i'
+      include 'scales.i'
+      include 'usage.i'
+      integer i,nvar
+      real*8 minimiz1,e
+      real*8 xx(maxvar)
+      real*8 g(maxvar)
+      real*8 derivs(3,maxatm)
+c
+c
+c     translate optimization parameters to atomic coordinates
+c
+      nvar = 0
+      do i = 1, n
+         if (use(i)) then
+            nvar = nvar + 1
+            x(i) = xx(nvar) / scale(nvar)
+            nvar = nvar + 1
+            y(i) = xx(nvar) / scale(nvar)
+            nvar = nvar + 1
+            z(i) = xx(nvar) / scale(nvar)
+         end if
+      end do
+c
+c     compute and store the energy and gradient
+c
+      call gradient (e,derivs)
+      minimiz1 = e
+c
+c     store Cartesian gradient as optimization gradient
+c
+      nvar = 0
+      do i = 1, n
+         if (use(i)) then
+            nvar = nvar + 1
+            g(nvar) = derivs(1,i) / scale(nvar)
+            nvar = nvar + 1
+            g(nvar) = derivs(2,i) / scale(nvar)
+            nvar = nvar + 1
+            g(nvar) = derivs(3,i) / scale(nvar)
+         end if
+      end do
+      return
+      end
diff -abuN source/torsions.f source_distrib/torsions.f
--- source/torsions.f	2010-08-24 22:58:17.000000000 +0200
+++ source_distrib/torsions.f	2010-08-26 11:38:23.000000000 +0200
@@ -23,8 +23,15 @@
       include 'couple.i'
       include 'iounit.i'
       include 'tors.i'
+cqmmm
+      include 'qmmm.i'
+      include 'angle.i'
+cqmmm
       integer i,j,k
       integer ia,ib,ic,id
+cqmmm
+      integer ii,iix
+cqmmm
 c
 c
 c     loop over all bonds, storing the atoms in each torsion
@@ -39,6 +46,12 @@
                do k = 1, n12(ic)
                   id = i12(k,ic)
                   if (id.ne.ib .and. id.ne.ia) then
+cqmmm Remove torsions between QM-only atoms
+                     if(qmmm(ia).ge.2 .and. qmmm(ib).eq.2 .and.
+     &                  qmmm(ic).ge.2 .and. qmmm(id).ge.2) goto 20
+                     if(qmmm(ia).ge.2 .and. qmmm(ib).ge.2 .and.
+     &                  qmmm(ic).eq.2 .and. qmmm(id).ge.2) goto 20
+cqmmm
                      ntors = ntors + 1
                      if (ntors .gt. maxtors) then
                         write (iout,10)
@@ -50,10 +63,51 @@
                      itors(2,ntors) = ib
                      itors(3,ntors) = ic
                      itors(4,ntors) = id
+cqmmm
+   20                continue
+cqmmm
                   end if
                end do
             end if
          end do
       end do
+cqmmm Torsions with only one mm atom are added
+      do i = 1, nangle
+         ia = iang(1,i)
+         ib = iang(2,i)
+         ic = iang(3,i)
+         if(qmmm(ia).eq.2 .and. qmmm(ib).ge.2) then
+            do ii = 1, n12(ia)
+               iix = i12(ii,ia)
+               if (iix.ne.ib .and. iix.ne.ic) then
+                  ntors = ntors + 1
+                  if (ntors .gt. maxtors) then
+                    write (iout,10)
+                    call fatal
+                  end if
+                  itors(1,ntors) = iix
+                  itors(2,ntors) = ia
+                  itors(3,ntors) = ib
+                  itors(4,ntors) = ic
+               end if
+            end do
+         else if(qmmm(ib).ge.2 .and. qmmm(ic).eq.2) then
+            do ii = 1, n12(ic)
+               iix = i12(ii,ic)
+               if (iix.ne.ia .and. iix.ne.ib) then
+                  ntors = ntors + 1
+                  if (ntors .gt. maxtors) then
+                     write (iout,10)
+                     call fatal
+                  end if
+                  itors(1,ntors) = ia
+                  itors(2,ntors) = ib
+                  itors(3,ntors) = ic
+                  itors(4,ntors) = iix
+               end if
+            end do
+         end if
+      end do
+cqmmm
       return
       end
diff -abuN source/xyzedit.f source_distrib/xyzedit.f
--- source/xyzedit.f	2010-08-24 22:58:17.000000000 +0200
+++ source_distrib/xyzedit.f	2011-05-12 14:26:14.000000000 +0200
@@ -30,6 +30,13 @@
       include 'titles.i'
       include 'units.i'
       include 'usage.i'
+cqmmm
+      include 'bond.i'
+      include 'charge.i'
+      include 'fields.i'
+      include 'potent.i'
+      include 'qmmm.i'
+cqmmm
       integer i,j,k,it,ixyz
       integer natom,atmnum
       integer nmode,mode
@@ -54,6 +61,29 @@
       real*8 rad(maxatm)
       real*8 a(3,3)
       logical write
+cqmmm
+      character symbol
+      logical add1la
+      integer iqm,imm,nold,qmfix,iinput
+      real*8 xlink,ylink,zlink,xqm,yqm,zqm,xmm,ymm,zmm,qi,kla
+      character*10 iname
+      character*2 zsymbol(0:103)
+      save zsymbol
+      data zsymbol/
+     &      ' X',
+     &      ' H','He','Li','Be',' B',' C',' N',' O',' F','Ne',
+     &      'Na','Mg','Al','Si',' P',' S','Cl','Ar',' K','Ca',
+     &      'Sc','Ti',' V','Cr','Mn','Fe','Co','Ni','Cu','Zn',
+     &      'Ga','Ge','As','Se','Br','Kr','Rb','Sr',' Y','Zr',
+     &      'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
+     &      'Sb','Te',' I','Xe','Cs','Ba','La','Ce','Pr','Nd',
+     &      'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
+     &      'Lu','Hf','Ta',' W','Re','Os','Ir','Pt','Au','Hg',
+     &      'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
+     &      'Pa',' U','Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
+     &      'Md','No','Lr'
+     &      /
+cqmmm
       character*120 xyzfile
       character*120 record
       external merge
@@ -92,12 +122,20 @@
      &        /,3x,'(15) Move Stray Molecules into Periodic Box',
      &        /,3x,'(16) Create and Fill a Periodic Boundary Box',
      &        /,3x,'(17) Soak Current Molecule in Box of Solvent',
-     &        /,3x,'(18) Append a Second XYZ file to Current One')
+cqmmm     &        /,3x,'(18) Append a Second XYZ file to Current One')
+cqmmm
+     &        /,3x,'(18) Append another XYZ file to Current One',
+     &        /,3x,'(19) Prepare a QM/MM input (G03/Tinker)',
+     &        /,3x,'(20) Prepare a QM/MM input (Molcas/Tinker)',
+     &        /,3x,'(21) Dump the inactive point charges')
+cqmmm
 c
 c     get the desired type of coordinate file modification
 c
    20 continue
-      nmode = 18
+cqmmm
+      nmode = 21
+cqmmm      nmode = 18
       mode = -1
       dowhile (mode.lt.0 .or. mode.gt.nmode)
          mode = 0
@@ -567,6 +605,277 @@
          write = .true.
          goto 20
       end if
+cqmmm
+c
+c     prepare QM/MM inputs for G03 or Molcas
+c
+      if (mode .eq. 19 .or. mode .eq. 20) then
+         call mechanic
+         nold = n
+c
+c        first: find the missing link atoms
+c
+         do i = 1, nbond
+            add1la = .false.
+            if(qmmm(ibnd(1,i)).eq.0 .and. qmmm(ibnd(2,i)).eq.2) then
+               iqm = ibnd(2,i)
+               imm = ibnd(1,i)
+               xqm = x(iqm)
+               yqm = y(iqm)
+               zqm = z(iqm)
+               xmm = x(imm)
+               ymm = y(imm)
+               zmm = z(imm)
+               kla = (rcov(atomic(iqm))+rcov(1))/
+     &                  (rcov(atomic(iqm))+rcov(atomic(imm)))
+               xlink = xqm + kla*(xmm-xqm)
+               ylink = yqm + kla*(ymm-yqm)
+               zlink = zqm + kla*(zmm-zqm)
+               add1la = .true.
+               do j = 1, n
+                  if ((qmmm(j).eq.1).and.(i12(1,j).eq.imm).and.
+     &                (i12(2,j).eq.iqm)) add1la = .false.
+               end do
+            end if
+            if(qmmm(ibnd(1,i)).eq.2 .and. qmmm(ibnd(2,i)).eq.0) then
+               iqm = ibnd(1,i)
+               imm = ibnd(2,i)
+               xqm = x(iqm)
+               yqm = y(iqm)
+               zqm = z(iqm)
+               xmm = x(imm)
+               ymm = y(imm)
+               zmm = z(imm)
+               kla = (rcov(atomic(iqm))+rcov(1))/
+     &                  (rcov(atomic(iqm))+rcov(atomic(imm)))
+               xlink = xqm + kla*(xmm-xqm)
+               ylink = yqm + kla*(ymm-yqm)
+               zlink = zqm + kla*(zmm-zqm)
+               add1la = .true.
+               do j = 1, n
+                  if ((qmmm(j).eq.1).and.(i12(1,j).eq.imm).and.
+     &                (i12(2,j).eq.iqm)) add1la = .false.
+               end do
+            end if
+            if (add1la) then
+               n = n + 1
+               nbinqm = nbinqm + 1
+               atinqm(n) = nbinqm
+               x(n) = xlink
+               y(n) = ylink
+               z(n) = zlink
+               type(n) = 2999
+               class(n) = 99
+               qmmm(n) = 1
+               n12(n) = 0
+               i12(1,n) = imm
+               i12(2,n) = iqm
+               use(n) = .true.
+               name(n) = 'HLA'
+               atomic(n) = 1
+            end if
+         end do
+c
+c        second: the .xyz file (if some HLA have been added)
+c
+         if (nold .ne. n) then
+            ixyz = freeunit ()
+            xyzfile = filename(1:leng)//'.xyz'
+            call version (xyzfile,'new')
+            open(unit=ixyz,file=xyzfile,status='new')
+            if (ltitle .eq. 0) then
+               write (ixyz,450)  n
+  450          format (i6)
+            else
+               write (ixyz,460)  n,title(1:ltitle)
+  460          format (i6,2x,a)
+            end if
+            do i = 1, n
+               if (qmmm(i).eq.1) n12(i) = 2
+               write(ixyz,480) i,name(i),x(i),y(i),z(i),
+     &                         type(i),(i12(j,i),j=1,n12(i))
+  480         format(i5,x,a3,3f12.6,5i6)
+               if (qmmm(i).eq.1) n12(i) = 0
+            end do
+            close(unit=ixyz)
+         end if
+c
+c        third: the g03 file
+c
+         if (mode .eq. 19) then
+            ixyz = freeunit ()
+            xyzfile = 'Gau_'//filename(1:leng)//'.com'
+            call version (xyzfile,'new')
+            open(unit=ixyz,file=xyzfile,status='new')
+            write(ixyz,500) filename(1:leng)
+  500       format('%SUBST L101 ',/,
+     &             '%SUBST L301 ',/,
+     &             '%SUBST L302 ',/,
+     &             '%SUBST L397 ',/,
+     &             '%SUBST L701 ',/,
+     &             '%CHK=',a,/,
+     &             '%MEM=',/,
+     &             '#P KEYWORDS HERE',/,
+     &             ' NoSym QMMM=(LinkAtom1,Tinker1)',/,/,
+     &             ' TITLE HERE',/,/
+     &             ' CHARGE & MULTIPLICITY HERE')
+            do j = 1, nbinqm
+               i = 0
+  501          i = i + 1
+               if (atinqm(i).eq.j) goto 502
+               if (i.gt.n) then
+                  write (iout,503) j
+  503             format(' No Tinker atom associated with the ',i4,
+     &             'th QM code atom !')
+                  call fatal
+               end if
+               goto 501
+  502          continue
+               if (qmmm(i).eq.0) then
+                  symbol = 'L'
+               else if (qmmm(i).eq.1) then
+                  symbol = 'M'
+               else if (qmmm(i).eq.2) then
+                  symbol = 'H'
+               else if (qmmm(i).eq.3) then
+                  symbol = 'M'
+               end if
+               qmfix = 0
+               if (.not.use(i)) then
+               qmfix = -1
+               write(iout,504) j
+  504          format(' WARNING: QM code',i4,
+     &                'th atom position must be frozen')
+               end if
+               write(ixyz,520) zsymbol(atomic(i)),qmfix,x(i),y(i),z(i),
+     &                         symbol
+  520          format(a2,i3,3(f10.5,2x),a1)
+            end do
+            write(ixyz,540) filename(1:leng),n
+  540       format(/,a,x,i7)
+            write(ixyz,560)
+  560       format(/,/)
+            close(unit=ixyz)
+            write(iout,599)
+  599       format(/,' Do not forget to finish the set-up of G03 !')
+c
+c        third: the Molcas file
+c
+         else
+            ixyz = freeunit ()
+            xyzfile = filename(1:leng)//'.input'
+            call version (xyzfile,'new')
+            open(unit=ixyz,file=xyzfile,status='new')
+            write(ixyz,600)
+  600       format('&Gateway')
+            write (iout,601)
+  601       format(/,' Standard (0, default) or older (1) input :  ',$)
+            iinput = 0
+            read (input,602)  iinput
+  602       format (i10)
+            if (iinput .eq. 0) then
+               write(ixyz,605) filename(1:leng)
+  605          format(  ' Tinker',/,' Group = NoSym',/,' Basis = ',/,
+     &                /,'&Seward',/,' Title = QM/MM ',a,/,
+     &                /,'&Espf',/,' External = Tinker')
+            else
+               do j = 1, nbinqm
+                  i = 0
+  611             i = i + 1
+                  if (atinqm(i).eq.j) goto 612
+                  if (i.gt.n) then
+                     write (iout,613) j
+  613                format(' No Tinker atom associated with the ',i4,
+     &                      'th QM code atom !')
+                     call fatal
+                  end if
+                  goto 611
+  612             continue
+                  iname = zsymbol(atomic(i))//'        '
+                  if (j .lt. 10) then
+                     write(iname(3:3),'(i1)') j
+                  else if (j .ge. 10 .and. j .lt. 100) then
+                     write(iname(3:4),'(i2)') j
+                  else if (j .ge. 100 .and. j .lt. maxqmmm) then
+                     write(iname(3:5),'(i3)') j
+                  else
+                     write(iout,*) 'XYZEDIT -- Too much QM/MM atoms'
+                   write(iout,*) 'XYZEDIT -- Increase maxqmmm in qmmm.i'
+                     call fatal
+                  end if
+                  if (qmmm(i).eq.0) then
+                     qi = 0.0d0
+                     if (use_charge) then
+                        do k = 1, nion
+                           if (i .eq. iion(k)) qi = pchg(k)
+                        end do
+                     end if
+                     write(ixyz,614) zsymbol(atomic(i)),iname,
+     &                               x(i),y(i),z(i),qi
+  614                format(' Basis set',/,
+     &                      a2,'...... / MM',/,
+     &                      a10,3f12.6,'  Angstrom',/,
+     &                      ' Charge = ',f12.6,/
+     &                      ' End of Basis')
+                  else if (qmmm(i).eq.1 .or .qmmm(i) .eq. 2) then
+                     write(ixyz,615) zsymbol(atomic(i)),iname,
+     &                               x(i),y(i),z(i)
+  615                format(' Basis set',/,
+     &                      a2,'......',/,
+     &                      a10,3f12.6,'  Angstrom',/,
+     &                      ' End of Basis')
+                  else if (qmmm(i).eq.3) then
+                     write (iout,619)
+  619                format(' LSCF method is not available in Molcas')
+                     call fatal
+                  end if
+                  if (.not.use(i)) then
+                  write(iout,620) j
+  620             format(' WARNING: QM code',i4,
+     &                   'th atom position must be frozen')
+                  end if
+               end do
+               write(ixyz,630) filename(1:leng)
+  630          format(/,/,'&Seward',/,' Title = QM/MM ',a,/,/,
+     &                    '&Espf',/,' External = @tinker')
+            end if
+            close(unit=ixyz)
+            write(iout,700)
+  700       format(/,' Do not forget to finish the set-up of Molcas !')
+         end if
+         if (nold.ne.n) write(iout,800) filename(1:leng)//'.key',
+     &                  n-nold
+  800    format(' Please update the QMMM keyword in ',a,':',/,i2,
+     &          ' Link Atoms (LA) has been added to the xyz file !')
+         write = .false.
+      end if
+c
+c     dump the inactive point charges together with their coordinates
+c
+      if (mode .eq. 21) then
+         call mechanic
+         ixyz = freeunit ()
+         xyzfile = filename(1:leng)//'.q'
+         call version (xyzfile,'new')
+         open(unit=ixyz,file=xyzfile,status='new')
+         write(ixyz,900) nion-nbinqm
+  900    format(i5,' 0 0 0 0 Angstrom')
+         qi = 0.0d0
+         do i = 1, nion
+            k = iion (i)
+            if (atinqm(k) .eq. 0) then
+               write (ixyz,910) x(k), y(k), z(k), pchg(i)
+               qi = qi + pchg(i)
+            end if
+  910       format(4f12.6)
+         end do
+         close(unit=ixyz)
+         write(iout,920) nion-nbinqm,qi,filename(1:leng)//'.q'
+  920    format(i6, ' charges have been dumped (total charge = ',f7.3,
+     &        ')',/,' Please check the number of point charges in ',a)
+         write = .false.
+      end if
+cqmmm
 c
 c     write out the new coordinates file in its new format
 c
